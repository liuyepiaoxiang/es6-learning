[TOC]

《JavaScript高级程序设计（第三版）》读书笔记
# 简介
一个完整的JavaScript实现由三部分组成：
- 核心(ECMAScript)
- 文档对象模型(DOM)
- 浏览器对象模型(BOM)

1. ECMAScript规定的内容：
- 语法
- 类型
- 语句
- 关键字
- 保留字
- 操作符
- 对象

2. 文档对象模型(DOM)
文档对象模型(DOM，Document Object Model)是针对XML但经过扩展用于HTML的应用程序编程接口(API，Application Programming Interface)。

    1. DOM级别：
    DOM1级由两个模块组成：DOM核心和DOM HTML。其中DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。\
    DOM2级引入以下模块：
    - DOM视图：定义了跟踪不同文档(例如，应用CSS之前和之后的文档)视图的接口；
    - DOM事件：定义了事件和事件处理的接口；
    - DOM样式：定义了基于CSS为元素应用样式的接口；
    - DOM遍历和视图：定义了遍历和操作文档树的接口；
    
    DOM3引入了以统一方式加载和保存文档的方法——在DOM加载和保存模块中定义；新增了验证文档的方法——在DOM验证模块中定义。
      
    2. 其他DOM标准
    除了DOM核心和DOM HTML接口之外，另外几种语言还发布了只针对自己的DOM标准。
    - SVG(可伸缩矢量图)1.0
    - MathML(数学标记语言)1.0
    - SMIL(同步多媒体集成语言)
    
    3. Web浏览器对DOM的支持
3. 浏览器对象模型(BOM)
---
# 在HTML中使用JavaScript

1. `<script>`元素
向HTML页面插入JavaScript的主要方法，HTML4.01为`<script>`定义了下列6个属性：
- async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效。
- charset：可选。表示通过src属性指定的代码的字符集。（大多数浏览器会忽略该值）
- defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。
- language：已废弃。
- src：可选。表示包含要执行代码的外部文件（如果需要包含JavaScript文件，则src属性就是必需的）。
- type：可选。可看做language的替代属性；表示编写代码使用脚本语言的内容类型（也称为MIME类型）。
    1. 标签的位置：现代Web应用程序一般都把全部JavaScript引用放在`<body>`元素中页面内容的后面。
    2. 延迟脚本：defer属性是表明脚本在执行时不会影响页面的构造。脚本被延迟到整个页面都解析完毕后再运行。defer属性只适用于外部脚本文件。
    3. 异步脚本：async脚本同样只用于外部脚本文件。
    4. 在XHTML中的用法：HTML的代码块在XHTML中无法正常识别，因为<在XHTML中被当做开始的新标签来解析。避免在XHTML中出现类似语法错误的方法有两个。一个是用相应的HTML实体(&lt替换<)；一个是用一个CDATA片段包含JavaScript代码`<script><![CDATA[代码片段]]></script>`

2. 嵌入外部代码与外部文件
- 可维护性：遍历不同HTML页面的JavaScript会造成维护问题。但把所有JavaScript文件都放在一个文件夹中，维护就方便多了。
- 可缓存：浏览器能够根据具体的设置缓存链接的所有外部JavaScript文件。
- 适应未来：通过外部文件来包含JavaScript无须使用前面提到XHTML或者注释hack。

3. 文档模式
混合模式（quirks mode）
标准模式（standards mode）：
```html
<!-- HTML 4.01严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3c.org/TR/html4/strict.dtd">
<!-- XHTML 1.0严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3c.org/TR/xhtml/DTD/XHTML-strict.dtd">
<!-- HTML 5 -->
<!DOCTYPE HTML>
```
对于标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发。
4. `<noscript>`模式
- 浏览器不支持脚本
- 浏览器支持脚本，但脚本被禁用

---
# 基本概念
## 语法
### 区分大小写

### 标识符
所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。格式规则为：
- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
- 其他字符可以是字母、下划线、美元符号或数字。
- 不能把关键字、保留字、true、false和null用作标识符。

### 注释
ECMAScript使用C风格的注释，包括单行注释和块级注释。单行注释以两个斜杠开头。
块级注释以一个斜杠和一个星号（/*）开头，以一个星号和一个斜杠（*/）结尾。
```html
// 单行注释
/*
* 这是一个多行
* （块级）注释
*/
```

### 严格模式
```js
"use strict"
```
看起来是字符串，也没有赋值给任何变量，其实是一个编译指令。

### 语句
以分号结尾；如果省略分号，则由解释器确定语句的结尾。

## 关键字和保留字
```
abstract
boolean break byte
case catch char class const continue
debugger default delete do double 
else enum export extends
false final finally float for function
goto
if implements import in instanceof int interface
long let
native new null
package private protected public
return
short static super switch synchronized
this throw throws transient true try typeof
var volatile void
while with
yield
```


## 变量
用var操作符定义的变量将成为定义该变量的作用域中的局部变量。

## 数据类型
ECMAScript中有5种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number、String。一种复杂数据类型：Object

### typeof操作符

对一个值使用typeof操作符返回下列某个字符串：

- "undefined"——如果这个值未定义；
- "boolean"——如果这个值是布尔值；
- "string"——如果这个值是字符串；
- "number"——如果这个值是数值；
- "object"——如果这个值是对象或null；
- "function"——如果这个值是函数。
typeof操作符的操作数可以是变量，也可以是数值字面量。\
typeof是一个操作符而不是函数

### Undefined类型
Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。

### Null类型
Null类型只有一个值，即特殊的null。null值表示一个空对象指针。
实际上，undefined值是派生自null值，因此对它们进行相等性测试返回true。
```js
alert(undefined == null); // true
alert(undefined === null); // false
```
### Boolean类型
Boolean类型只有两个字面值：true和false。区分大小写。这两个值与数字值不是一回事，true不一定等于1，false不一定等于0.
ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()。

数据类型 | 转换为true的值 | 转换为false的值
--- | --- | ---
Boolean | true | false
String | 任何非空字符串 | ""(空字符串)
Number | 任何非零数字值(包括无穷大) | 0 和NaN
Object | 任何对象 | null
Undefined | n/a(不适用) | undefined

### Number类型
最基本的数值字面量格式是十进制整数。整数还可以通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。\
其中，八进制字面量的第一位必须是零(0)，然后是八进制数字序列。十六进制字面值的前两位必须是0x，后跟任何十六进制数字(0-9及A-F)。
1. 浮点数值
所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。\
对于极大或极小的数值，可以用e表示法(即科学计数法)表示的浮点数值表示。
2. 数值范围
ECMAScript能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在Number_MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308.
3. NaN
NaN,即非数值是一个特殊的数值。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。
NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作都会返回NaN；其次，NaN与任何值都不相等，包括NaN本身。

4. 数值转换
Number()可用于任何数据类型，其转换规则如下：
- 如果是Boolean值，true和false将分别被转换为1和0；
- 如果是数字值，只是简单的传入和返回；
- 如果是null值，返回0；
- 如果是undefined，返回NaN;
- 如果是字符串，遵循以下规则：
    - 如果字符串中只包含数字，则将其转换为十进制数值；
    - 如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值；
    - 如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值；
    - 如果字符产是空的（不包含任何字符），则将其转换为0；
    - 如果字符串中包含除上述格式之外的字符，则将其转换为NaN.
- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN,则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

parseInt()函数在转换字符串时，会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN;如果第一个字符是数字字符，则继续解析直到解析完或者遇到非数字字符。（小数点不是有效的数字字符）
parseInt提供第二个参数，转换时使用的基数（即多少进制）。

parseFloat()函数只解析十进制。

### String类型
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号(")或单引号(')表示。

1. 字符串变量
String数据类型包含一些特殊的字符字面量，也叫转义序列。

字面量 | 含义
--- | ---
`\n` | 换行
`\t` | 制表
`\b` | 退格
`\r` | 回车
`\f` | 进纸
`\\` | 斜杠
`\'` | 单引号(')，在用单引号表示的字符串中使用。
`\"` | 双引号(")，在用双引号表示的字符串中使用。
`\xnn` | 以十六进制代码nn表示的一个字符（其中n为0-F）。
`\unnnn` | 以十六进制代码nnnn表示的一个Unicode字符（其中n为0-F）。

2. 字符串的特点
ECMAScript中字符串是不可变的。

3. 转换为字符串
第一种是使用几乎每个值都有的toString()方法（null和undefined除外）。该方法可以不传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。
第二种是String()，不知道转型的值是不是null和undefined时使用，转换规则如下：
- 如果值有toString()方法，则调用该方法并返回相应的结果；
- 如果值是null，则返回"null"；
- 如果值是undefined，则返回"undefined"。

### Object类型
ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。
Object的每个实例都具有下列属性和方法。
- constructor：保存着用于创建当前对象的函数。
- hasOwnproperty(propertyName)：用于检查给定属性在当前对象实例中（而不是在实例的原型中）是否存在。
- isPrototypeOf：用于检查传入的对象是否是传入对象的原型。
- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString()：返回对象的字符串表示。
- valueOf()：返回对象的字符串、数值或布尔值表示。

## 操作符
### 一元操作符
只能操作一个值的操作符叫做***一元操作符***。
1. 递增和递减操作符：前置型和后置型
2. 一元加和减操作符：表示正负

### 位操作符
位操作符用于最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript中所有数值都以IEEE-754 64
位格式储存，即位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再转换回64位

对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表述数值的符号：0表示正数，1表示负数。
正数以纯二进制格式存储。负数同样以二进制码存储，但使用的格式是二进制补码。
1. 按位非（NOT）
按位非操作符有一个波浪线（~）表示，执行按位非的结果就是返回数值的反码（操作数的负数减1）。

2. 按位与（AND）
按位与操作符由一个和号字符（&）表示，它有两个操作符数。按位与操作就是将两个数值的每一位对齐，
然后根据下表中的规则，对相同位置上的两个数执行AND操作：

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
1 | 1 | 1
1 | 0 | 0
0 | 1 | 0
0 | 0 | 0

3. 按位或（OR）
按位或操作符由一个竖线符号（|）表示，有两个操作数。按位或操作遵循下面这个真假表。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
1 | 1 | 1
1 | 0 | 1
0 | 1 | 1
0 | 0 | 0

4. 按位异或（XOR）
按位异或操作符由一个插入符号（^）表示，也是两个操作数。以下是按位异或的真假值。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
1 | 1 | 0
1 | 0 | 1
0 | 1 | 1
0 | 0 | 0

5. 左移
左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。

6. 有符号的右移
有符号的右移操作符由两个小于号（>>）表示，这个操作符会将数值的所有位向右移动，但保留符号位（即正负号标记）。

7. 无符号右移
无符号的右移操作符由三个小于号（>>>）表示，这个操作符会将数值的所有32都位向右移动。


### 布尔操作符
布尔操作符一共有3个：非（NOT）、与（AND）和或（OR）
1. 逻辑非
逻辑非操作符由一个叹号（！）表示，可以应用于ECMAScript中的任何值。逻辑非操作符遵循下列规则：
- 如果操作数是一个对象，返回false；
- 如果操作数是一个空字符串，返回true；
- 如果操作数是一个非空字符串，返回false；
- 如果操作数是数值0，返回true；
- 如果操作数是任意非0数值（包括Infinity），返回false；
- 如果操作数是null，返回true；
- 如果操作数是NaN，返回true；
- 如果操作数是undefined，返回true。

2. 逻辑与
逻辑与操作符由两个和号（&&）表示，有两个操作数。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
true | true | true
true | false | false
false | true | false
false | false | false

3. 逻辑或
逻辑或操作符由两个和号（||）表示，有两个操作数。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
true | true | true
true | false | true
false | true | true
false | false | false

### 乘性操作符
ECMAScript定义了3个乘性操作符：乘法、除法和求模。
1. 乘法
乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。遵循下列特殊的规则：
- 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，
而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了数值的表示范围，则返回Infinity或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity与0相乘，则结果是NaN;
- 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
- 如果是Infinity与Infinity相乘，则结果是Infinity；
- 如果有一个操作符不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

2. 除法
除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算。遵循下列特殊的规则：
- 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相乘的结果还是正数，
而如果只有一个操作数有符号，那么结果就是负数。如果商超过了数值的表示范围，则返回Infinity或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity被Infinity除，则结果是NaN;
- 如果是零被零除，则结果是NaN;
- 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
- 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

3. 求模
求模（余数）操作符由一个百分号（%）表示，规则如下：
- 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
- 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN;
- 如果被除数是有限大的数值而除数是零，则结果是NaN;
- 如果是Infinity被Infinity除，则结果是NaN;
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
- 如果被除数是零，则结果是零；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

### 加性操作符
1. 加法
如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：
- 如果有一个操作数是NaN,则结果是NaN;
- 如果是Infinity加Infinity，则结果是Infinity;
- 如果是-Infinity加-Infinity，则结果是-Infinity;
- 如果是Infinity加-Infinity，则结果是NaN;
- 如果是+0加+0，则结果是+0;
- 如果是-0加-0，则结果是-0;
- 如果是+0加-0，则结果是+0;
不过，如果有一个操作数是字符串，那么就要应用如下规则：
- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。

如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。
对于undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"。

2. 减法
- 如果两个操作符都是数值，执行常规的算数减法操作并返回结果；
- 如果有一个操作数是NaN,则结果是NaN;
- 如果是Infinity减Infinity，则结果是NaN;
- 如果是-Infinity减-Infinity，则结果是NaN;
- 如果是Infinity减-Infinity，则结果是Infinity;
- 如果是-Infinity减Infinity，则结果是-Infinity;
- 如果是+0减+0，则结果是+0;
- 如果是+0减-0，则结果是-0;
- 如果是+0减-0，则结果是+0;
- 如果有一个操作数是字符串、布尔值、null和undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。
如果转换的结果是NaN，则减法的结果就是NaN；
- 如果只有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。
如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用起toString()方法并将得到的字符串转换为数值。



### 关系操作符
小于（<）、大于（>）、小于等于（<=）、大于等于（>=）
- 如果两个操作数都是数值，则执行数值比较。
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执
  行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面
  的规则执行比较。
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。
### 相等操作符
ECMAScript 提供两组操作符： 相等和不相等——先转换再比较， 全等和不
全等——仅比较而不转换。
1. 相等和不相等
ECMAScript 中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回 true。而不
相等操作符由叹号后跟等于号（!=）表示，如果两个操作数不相等，则返回 true。这两个操作符都会
先转换操作数（通常称为强制转型），然后再比较它们的相等性。
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：
- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而
  true 转换为 1；
- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
- 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类
  型值按照前面的规则进行比较；
  这两个操作符在进行比较时则要遵循下列规则。
- null 和 undefined 是相等的。
- 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。
- 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：
  即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则， NaN 不等于 NaN。
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，
  则相等操作符返回 true；否则，返回 false。
  
2. 全等和不全等
 
### 条件操作符

### 赋值操作符
简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量，
每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：
- 乘/赋值（*=）；
- 除/赋值（/=）；
- 模/赋值（%=）；
- 加/赋值（+=）；
- 减/赋值（-=）；
- 左移/赋值（<<=）；
- 有符号右移/赋值（>>=）；
- 无符号右移/赋值（>>>=）。

### 逗号操作符
逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号
操作符总会返回表达式中的最后一项，

## 语句

### if语句

### do-while语句
do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。
换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。
### while语句
while 语句属于前测试循环语句， 也就是说， 在循环体内的代码被执行之前，就会对出口条件求值。
### for语句
for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代
码的能力。
### for-in语句
for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。
### label语句
使用 label 语句可以在代码中添加标签，以便将来使用。
### break和continue语句
break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，
强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶
部继续执行。
### with语句
with 语句的作用是将代码的作用域设置到一个特定的对象中。
### switch语句
switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。
可以在
switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有
问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。


## 函数
函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、
任何时候调用执行。 ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。
### 理解参数
ECMAScript 函数的参数与大多数其他语言中函数的参数有所不同。 ECMAScript 函数不介意传递进
来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，
在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不
会有什么怨言。之所以会这样，原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收
到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任
何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来
访问这个参数数组，从而获取传递给函数的每一个参数。
### 没有重载
ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数
编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述， ECMAScirpt
函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可
能做到的。


---
# 变量、作用域和内存问题

## 基本类型和引用类型的值
ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 基本类型值指的是
简单的数据段，而引用类型值指那些可能由多个值构成的对象。


### 动态的属性
定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保
存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属
性和方法，也可以改变和删除其属性和方法。

### 复制变量值
除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不
同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制
到为新变量分配的位置上。

### 传递参数
ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参
数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而
引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因
为访问变量有按值和按引用两种方式，而参数只能按值传递。

### 检测类型
 typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。如果变
量的值是一个对象或 null，则 typeof 操作符会返回"object"。
## 执行环境及作用域
执行环境（execution context，为简单起见，有时也称为“环境”）是 JavaScript 中最为重要的一个概
念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个
与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们
编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环
境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象（第 7 章将详细讨论），因
此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完
毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退
出——例如关闭网页或浏览器——时才会被销毁）。
每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。
而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 ECMAScript 程序中的执行流
正是由这个方便的机制控制着。
当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是
保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所
在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对
象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中
的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延
续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，
然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。
### 延长作用域链
虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。
这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移
除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会
得到加长：
- try-catch 语句的 catch 块；
- with 语句。
这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来说，会将指定的对象添加到
作用域链中。对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

### 没有块级作用域
1. 声明变量
使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部
环境；在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自
动被添加到全局环境。

2. 查询标识符
当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什
么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到
了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上
搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味
着该变量尚未声明。


## 垃圾收集
JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。
而在 C 和 C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问
题的一个根源。在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无
用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变
量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），
周期性地执行这一操作。

### 标记清除
JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函
数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变
量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其
标记为“离开环境”。
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方
式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记
的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器
完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
### 引用计数
另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每
个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。
如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取
得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这
个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那
些引用次数为零的值所占用的内存。
Netscape Navigator 3.0 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循
环引用。 循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的
引用。
### 性能问题

### 管理内存
使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是， JavaScript
在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web
浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，
目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量
分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。
因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行
中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个
做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在
它们离开执行环境时自动被解除引用。

---
# 引用类型

## Object类型
到目前为止，我们看到的大多数引用类型值都是 Object 类型的实例；而且， Object 也是
ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储
和传输数据而言，它们确实是非常理想的选择。
创建 Object 实例的方式有两种。第一种是使用 new 操作符后跟 Object 构造函数。\
另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建
包含大量属性的对象的过程。\
一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，
在 JavaScript 也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性
以字符串的形式放在方括号中。\
从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量
来访问属性。\
如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括
号表示法。
## Array类型
创建数组的基本方式有两种。第一种是使用 Array 构造函数，如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成 length属性的值。
也可以向 Array 构造函数传递数组中应该包含的项。
另外，在使用 Array 构造函数时也可以省略 new 操作符。

创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表
示，多个数组项之间以逗号隔开。

在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引，方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值。\
如果设置某个值的索引超过了数组现有项数，数组就会自动增加到该索引值加 1 的长度。

### 检测数组
ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。

### 转换方法
所有对象都具有 toLocaleString()、 toString()和 valueOf()方法。其中，调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。
而调用 valueOf()返回的还是数组。

### 栈方法
数组可以表
现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种 LIFO（Last-In-First-Out，
后进先出）的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做
弹出），只发生在一个位置——栈的顶部。 ECMAScript 为数组专门提供了 push()和 pop()方法，以便
实现类似栈的行为。
push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而
pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。

### 队列方法
栈数据结构的访问规则是 LIFO（后进先出），而队列数据结构的访问规则是 FIFO（First-In-First-Out，
先进先出）。队列在列表的末端添加项，从列表的前端移除项。由于 push()是向数组末端添加项的方法，
因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 shift()，它能够移
除数组中的第一个项并返回该项，同时将数组长度减 1。结合使用 shift()和 push()方法，可以像使
用队列一样使用数组。\
ECMAScript 还为数组提供了一个 unshift()方法。顾名思义，unshift()与 shift()的用途相反：
它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用 unshift()和 pop()方法，可以
从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。
### 重排序方法
数组中已经存在两个可以直接用来重排序的方法： reverse()和 sort()。
sort()方法接受参数。
比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等
则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。

### 操作方法
ECMAScript 为操作已经包含在数组中的项提供了很多方法。其中， concat()方法可以基于当前数
组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数
添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是
复制当前数组并返回副本。如果传递给 concat()方法的是一或多个数组，则该方法会将这些数组中的
每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。

下一个方法是 slice()，它能够基于当前数组中的一或多个项创建一个新数组。 slice()方法可以
接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该
参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项—
—但不包括结束位置的项。注意， slice()方法不会影响原始数组。

下面我们来介绍 splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。
splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种。
- 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。
  例如， splice(0,2)会删除数组中的前两项。
- 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）
  和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，
  splice(2,0,"red","green")会从当前数组的位置 2 开始插入字符串"red"和"green"。
- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起
  始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，
  splice (2,1,"red","green")会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串
  "red"和"green"。
  
### 位置方法
ECMAScript 5 为数组实例添加了两个位置方法： indexOf()和 lastIndexOf()。这两个方法都接收
两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， indexOf()方法从数组的开头（位
置 0）开始向后查找， lastIndexOf()方法则从数组的末尾开始向前查找。

### 迭代方法
ECMAScript 5 为数组定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和
（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数
组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能
会也可能不会影响方法的返回值。以下是这 5 个迭代方法的作用。
- every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。
- filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。
- forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
- some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。

### 归并方法
ECMAScript 5 还新增了两个归并数组的方法： reduce()和 reduceRight()。这两个方法都会迭
代数组的所有项，然后构建一个最终返回的值。其中， reduce()方法从数组的第一项开始，逐个遍历
到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。
这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给
 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这
个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第
一个参数是数组的第一项，第二个参数就是数组的第二项。



## Date类型
ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。为此， Date
类型使用自 UTC（Coordinated Universal Time，国际协调时间） 1970 年 1 月 1 日午夜（零时）开始经过
的毫秒数来保存日期。在使用这种数据存储格式的条件下， Date 类型保存的日期能够精确到 1970 年 1
月 1 日之前或之后的 285 616 年。\
在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根
据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 1970 年 1 月 1 日午
夜起至该日期止经过的毫秒数）。为了简化这一计算过程， ECMAScript 提供了两个方法： Date.parse()
和 Date.UTC()。\
其中， Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日
期的毫秒数。 ECMA-262 没有定义 Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现
而异，而且通常是因地区而异。将地区设置为美国的浏览器通常都接受下列日期格式：
- “月/日/年”，如 6/13/2004；
- “英文月名 日,年”，如 January 12,2004；
- “英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700。
- ISO 8601 扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ（例如 2004-05-25T00:00:00）。只有兼容
ECMAScript 5的实现支持这种格式。\

Date.UTC()方法同样也返回表示日期的毫秒数，但它与 Date.parse()在构建值时使用不同的信
息。 Date.UTC()的参数分别是年份、基于 0的月份（一月是 0，二月是 1，以此类推）、月中的哪一天
（1 到 31）、小时数（0 到 23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必
需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。\

ECMAScript 5 添加了 Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方
法简化了使用 Data 对象分析代码的工作。


### 继承的方法
与其他引用类型一样， Date 类型也重写了 toLocaleString()、toString()和 valueOf()方法；
但这些方法返回的值与其他类型中的方法不同。 Date 类型的 toLocaleString()方法会按照与浏览器
设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含 AM 或 PM，但不会包含时
区信息（当然，具体的格式会因浏览器而异）。而 toString()方法则通常返回带有时区信息的日期和
时间，其中时间一般以军用时间（即小时的范围是 0 到 23）表示。

### 日期格式化方法
Date 类型还有一些专门用于将日期格式化为字符串的方法，
- toDateString()——以特定于实现的格式显示星期几、月、日和年；
- toTimeString()——以特定于实现的格式显示时、分、秒和时区；
- toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
- toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
- toUTCString()——以特定于实现的格式完整的 UTC 日期。

与 toLocaleString()和 toString()方法一样，以上这些字符串格式方法的输出也是因浏览器
而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。

### 日期/时间组件方法
到目前为止，剩下还未介绍的 Date 类型的方法（如下表所示），都是直接取得和设置日期值中特
定部分的方法了。需要注意的是， UTC 日期指的是在没有时区偏差的情况下（将日期转换为 GMT 时间）
的日期值。

方法 | 说明
--- | ---
getTime() | 返回表示日期的毫秒数；与valueOf()方法返回的值相同
setTime(毫秒) | 以毫秒数设置日期，会改变整个日期
getFullYear() | 取得4位数的年份（如2007而非仅07）
getUTCFullYear() | 返回UTC日期的4位数年份
setFullYear(年) | 设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
setUTCFullYear(年) | 设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
getMonth() | 返回日期中的月份，其中0表示一月， 11表示十二月
getUTCMonth() | 返回UTC日期中的月份，其中0表示一月， 11表示十二月
setMonth(月) | 设置日期的月份。传入的月份值必须大于0，超过11则增加年份
setUTCMonth(月) | 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份
getDate() | 返回日期月份中的天数（1到31）
getUTCDate() | 返回UTC日期月份中的天数（1到31）
setDate(日) | 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
setUTCDate(日) | 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
getDay() | 返回日期中星期的星期几（其中0表示星期日， 6表示星期六）
getUTCDay() | 返回UTC日期中星期的星期几（其中0表示星期日， 6表示星期六）
getHours() | 返回日期中的小时数（0到23）
getUTCHours() | 返回UTC日期中的小时数（0到23）
setHours(时) | 设置日期中的小时数。传入的值超过了23则增加月份中的天数
setUTCHours(时) | 设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数
getMinutes() | 返回日期中的分钟数（0到59）
getUTCMinutes() | 返回UTC日期中的分钟数（0到59）
setMinutes(分) | 设置日期中的分钟数。传入的值超过59则增加小时数
setUTCMinutes(分) | 设置UTC日期中的分钟数。传入的值超过59则增加小时数
getSeconds() | 返回日期中的秒数（0到59）
getUTCSeconds() | 返回UTC日期中的秒数（0到59）
setSeconds(秒) | 设置日期中的秒数。传入的值超过了59会增加分钟数
setUTCSeconds(秒) | 设置UTC日期中的秒数。传入的值超过了59会增加分钟数
getMilliseconds() | 返回日期中的毫秒数
getUTCMilliseconds() | 返回UTC日期中的毫秒数
setMilliseconds(毫秒) | 设置日期中的毫秒数
setUTCMilliseconds(毫秒) | 设置UTC日期中的毫秒数
getTimezoneOffset() | 返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某
地进入夏令时的情况下，这个值会有所变化。

<<<<<<< HEAD:front_basic/chp6/profession.md
## RegExp方法
ECMAScript 通过 RegExp 类型来支持正则表达式。
其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、
向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。
正则表达式的匹配模式支持下列 3 个标志。
- g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即
停止；
- i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模
式匹配的项。

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。

方法 | 说明
--- | ---
getTime() | 返回表示日期的毫秒数；与valueOf()方法返回的值相同
setTime(毫秒) | 以毫秒数设置日期，会改变整个日期
getFullYear() | 取得4位数的年份（如2007而非仅07）
getUTCFullYear() |  返回UTC日期的4位数年份
setFullYear(年) | 设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
setUTCFullYear(年) | 设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
getMonth() | 返回日期中的月份，其中0表示一月， 11表示十二月
getUTCMonth()  | 返回UTC日期中的月份，其中0表示一月， 11表示十二月
setMonth(月)  | 设置日期的月份。传入的月份值必须大于0，超过11则增加年份
setUTCMonth(月) | 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份
getDate() | 返回日期月份中的天数（1到31）
getUTCDate() | 返回UTC日期月份中的天数（1到31）
setDate(日) | 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
setUTCDate(日) | 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加
getDay() | 返回日期中星期的星期几（其中0表示星期日， 6表示星期六）
getUTCDay() | 返回UTC日期中星期的星期几（其中0表示星期日， 6表示星期六）
getHours() | 返回日期中的小时数（0到23）
getUTCHours() | 返回UTC日期中的小时数（0到23）
setHours(时) | 设置日期中的小时数。传入的值超过了23则增加月份中的天数
setUTCHours(时) | 设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数
getMinutes() | 返回日期中的分钟数（0到59）
getUTCMinutes() | 返回UTC日期中的分钟数（0到59）
setMinutes(分) | 设置日期中的分钟数。传入的值超过59则增加小时数
setUTCMinutes(分) | 设置UTC日期中的分钟数。传入的值超过59则增加小时数
getSeconds()  | 返回日期中的秒数（0到59）
getUTCSeconds()  | 返回UTC日期中的秒数（0到59）
setSeconds(秒) | 设置日期中的秒数。传入的值超过了59会增加分钟数
setUTCSeconds(秒) | 设置UTC日期中的秒数。传入的值超过了59会增加分钟数
getMilliseconds() | 返回日期中的毫秒数
getUTCMilliseconds() | 返回UTC日期中的毫秒数
setMilliseconds(毫秒) | 设置日期中的毫秒数
setUTCMilliseconds(毫秒) | 设置UTC日期中的毫秒数
getTimezoneOffset() | 返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某
地进入夏令时的情况下，这个值会有所变化。

## RegExp方法
ECMAScript 通过 RegExp 类型来支持正则表达式。使用下面类似 Perl 的语法，就可以创建一个正
则表达式。
```javascript
var expression = / pattern /flags ;
```
其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、
向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。
正则表达式的匹配模式支持下列 3 个标志。
- g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即
停止；
- i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模
式匹配的项。

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：
`( [ { \ ^ $ | ) ? * + .]}`
这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，
就必须对它们进行转义。
### RegExp实例属性
RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。
- global：布尔值，表示是否设置了 g 标志。
- ignoreCase：布尔值，表示是否设置了 i 标志。
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。
- multiline：布尔值，表示是否设置了 m 标志。
- source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。
通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含
在模式声明中。

### RegExp实例方法
RegExp 对象的主要方法是 exec()，该方法是专门为捕获组而设计的。 exec()接受一个参数，即
要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null。
返回的数组虽然是 Array 的实例，但包含两个额外的属性： index 和 input。其中， index 表示匹配
项在字符串中的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配
的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。

正则表达式的第二个方法是 test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回
true；否则，返回 false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的
情况下，使用这个方法非常方便。因此， test()方法经常被用在 if 语句中。

### RegExp构造函数属性
RegExp 构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用
域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独
特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名
（Opera 是例外，它不支持短属性名）。

长属性名 | 短属性名 | 说 明
--- | --- | ---
input | $_ | 最近一次要匹配的字符串。 Opera未实现此属性
lastMatch | $& | 最近一次的匹配项。 Opera未实现此属性
lastParen | $+ | 最近一次匹配的捕获组。 Opera未实现此属性
leftContext | $` | input字符串中lastMatch之前的文本
multiline | $* | 布尔值，表示是否所有表达式都使用多行模式。 IE和Opera未实现此属性
rightContext | $' | Input字符串中lastMatch之后的文本

除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。访问这些属性的语
法是 RegExp.$1、 RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在
调用 exec()或 test()方法时，这些属性会被自动填充。

### 模式的局限性
尽管 ECMAScript 中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是 Perl）所支
持的高级正则表达式特性。下面列出了 ECMAScript 正则表达式不支持的特性（要了解更多相关信息，
请访问 www.regular-expressions.info）。
- 匹配字符串开始和结尾的\A 和\Z 锚①
- 向后查找（lookbehind） ②
- 并集和交集类
- 原子组（atomic grouping）
- Unicode 支持（单个字符除外，如\uFFFF）
- 命名的捕获组③
- s（single，单行）和 x（free-spacing，无间隔）匹配模式
- 条件匹配
- 正则表达式注释

## Function类型
每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函
数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函
数声明语法定义的。
```javascript
function sum (num1, num2) {
return num1 + num2;
}

var sum = function(num1, num2){
return num1 + num2;
};
```

function 关键字后面没有函数名。这是因为在使用函数表达式定义函数时，没有必要使用函数名——通过变量 sum 即可以引
用函数。另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。
最后一种定义函数的方式是使用 Function 构造函数。Function 构造函数可以接收任意数量的参数，
但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。
### 没有重载（深入理解）
将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。

### 函数声明与函数表达式
而实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行
任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真
正被解释执行。
```javascript
alert(sum(10,10));
function sum(num1, num2){
return num1 + num2;
}
```
以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升
（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时， JavaScript
引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后
面， JavaScript 引擎也能把函数声明提升到顶部。如果像下面例子所示的，把上面的函数声明改为等价
的函数表达式，就会在执行期间导致错误。
```javascript
alert(sum(10,10));  // 报错
var sum = function(num1, num2){
return num1 + num2;
};
```
 
### 作为值的函数
因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以
像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。


### 函数内部属性
在函数内部，有两个特殊的对象： arguments 和 this。其中， arguments 在第 3 章曾经介绍过，
它是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，
但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。
```
function factorial(num){
if (num <=1) {
return 1;
} else {
return num * factorial(num-1)
}
}
```
定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变
的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为
了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee。
```js
function factorial(num){
if (num <=1) {
return 1;
} else {
return num * arguments.callee(num-1)
}
}
```
### 函数属性和方法
每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数。
每个函数都包含两个非继承而来的方法：apply()和call()。
这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。
首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数值。其中，第二个参数可以是Array的实例，也可以是arguments对象。
call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。使用call()方法时，传递给函数的参数必须逐个列举出来。

事实上，传递参数并非 apply()和 call()真正的用武之地；它们真正强大的地方是能够扩充函数
赖以运行的作用域。
```js
window.color = "red";
var o = { color: "blue" };
function sayColor(){
alert(this.color);
}
sayColor(); //red
sayColor.call(this); //red
sayColor.call(window); //red
sayColor.call(o); //blue
```
使用 call()（或 apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。

ECMAScript 5 还定义了一个方法： bind()。这个方法会创建一个函数的实例，其 this 值会被绑
定到传给 bind()函数的值。

## 基本包装类型
为了便于操作基本类型值， ECMAScript 还提供了 3 个特殊的引用类型： Boolean、 Number 和
String。这些类型与其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。
实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们
能够调用一些方法来操作这些数据。

引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，
在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一
行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。

当然，可以显式地调用 Boolean、 Number 和 String 来创建基本包装类型的对象。不过，应该在
绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的
值。对基本包装类型的实例调用 typeof 会返回"object"，而且所有基本包装类型的对象都会被转换
为布尔值 true。
### Boolean类型
Boolean 类型是与布尔值对应的引用类型。
基本类型与引用类型的布尔值还有两个区别。首先， typeof 操作符对基本类型返回"boolean"，
而对引用类型返回"object"。其次，由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof
操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false。
### Number类型
Number 是与数字值对应的引用类型。要创建 Number 对象，可以在调用 Number 构造函数时向其
中传递相应的数值。

这里给 toFixed()方法传入了数值 2，意思是显示几位小数。于是，这个方法返回了"10.00"，即
以 0 填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值
就会舍入。

另外可用于格式化数值的方法是 toExponential()，该方法返回以指数表示法（也称 e 表示法）
表示的数值的字符串形式。与 toFixed()一样， toExponential()也接收一个参数，而且该参数同样
也是指定输出结果中的小数位数。

### String类型
String 类型是字符串的对象包装类型，String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf()、toLocale
String()和 toString()方法，都返回对象所表示的基本字符串值。

1. 字符方法
两个用于访问字符串中特定字符的方法是： charAt()和 charCodeAt()。这两个方法都接收一个
参数，即基于 0 的字符位置。其中， charAt()方法以单字符字符串的形式返回给定位置的那个字符
（ECMAScript 中没有字符类型）。

2. 字符串操作方法
 concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。
ECMAScript还提供了三个基于子字符串创建新字符串的方法： slice()、 substr()和 substring()。
这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字
符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说， slice()和
substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而 substr()的第二个参数指
定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与
concat()方法一样， slice()、 substr()和 substring()也不会修改字符串本身的值——它们只是
返回一个基本类型的字符串值，对原始字符串没有任何影响。

在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中， slice()方法会将传
入的负值与字符串的长度相加， substr()方法将负的第一个参数加上字符串的长度，而将负的第二个
参数转换为 0。最后， substring()方法会把所有负值参数都转换为 0。

3. 字符串位置方法
有两个可以从字符串中查找子字符串的方法： indexOf()和 lastIndexOf()。这两个方法都是从
一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。
这两个方法的区别在于： indexOf()方法从字符串的开头向后搜索子字符串，而 lastIndexOf()方法
是从字符串的末尾向前搜索子字符串。这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。

4. trim()方法
ECMAScript 5 为所有字符串定义了 trim()方法。这个方法会创建一个字符串的副本，删除前置及
后缀的所有空格，然后返回结果。

5. 字符串大小写转换方法
ECMAScript 中涉及字符串大小写转换的方
法有 4 个： toLowerCase()、 toLocaleLowerCase()、 toUpperCase()和 toLocaleUpperCase()。
其中， toLowerCase()和 toUpperCase()是两个经典的方法，借鉴自 java.lang.String 中的同名
方法。而 toLocaleLowerCase()和 toLocaleUpperCase()方法则是针对特定地区的实现。对有些地
区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为 Unicode 大小
写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。

6. 字符串的模式匹配方法
String 类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是 match()，在字符串上
调用这个方法，本质上与调用 RegExp 的 exec()方法相同。 match()方法只接受一个参数，要么是一
个正则表达式，要么是一个 RegExp 对象。

replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的
情况下，会向这个函数传递 3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在
正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹
配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始
字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace()方法的第
二个参数可以实现更加精细的替换操作。

7. localeCompare()方法
与操作字符串有关的最后一个方法是 localeCompare()，这个方法比较两个字符串，并返回下列
值中的一个：
- 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体
  的值要视实现而定）；
- 如果字符串等于字符串参数，则返回 0；
- 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1，具体的
  值同样要视实现而定）。

8. fromCharCode()方法
另外， String 构造函数本身还有一个静态方法： fromCharCode()。这个方法的任务是接收一或
多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法 charCodeAt()
执行的是相反的操作。

## 单体内置对象
ECMA-262 对内置对象的定义是：“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对
象在 ECMAScript 程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因
为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如 Object、 Array 和 String。
ECMA-262 还定义了两个单体内置对象： Global 和 Math。

### Global对象
不属于任何其他对象的属性和方法，最终都是它的属性和方法。

1. URI编码方法
Global 对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform Resource
Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如
空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，
从而让浏览器能够接受和理解。
其中， encodeURI()主要用于整个 URI（例如， http://www.wrox.com/illegal value.htm），而 encodeURIComponent()主要用于对 URI 中的某一段（例如前面 URI 中的 illegal value.htm）进行编码。
它们的主要区别在于， encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、
问号和井字号；而 encodeURIComponent()则会对它发现的任何非标准字符进行编码。

与 encodeURI()和 encodeURIComponent()方法对应的两个方法分别是 decodeURI()和
decodeURIComponent()。其中， decodeURI()只能对使用 encodeURI()替换的字符进行解码。
同样地， decodeURIComponent()能够解码使用 encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。

2. eval()方法
现在，我们介绍最后一个——大概也是整个 ECMAScript 语言中最强大的一个方法：eval()。eval()
方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的 ECMAScript （或 JavaScript）
字符串。

当解析器发现代码中调用 eval()方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，
然后把执行结果插入到原位置。通过 eval()执行的代码被认为是包含该次调用的执行环境的一部分，
因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过 eval()执行的代码可以引用在包
含环境中定义的变量。

严格模式下，在外部访问不到 eval()中创建的任何变量或函数。

3. Global对象的属性

属性 | 说明
--- | ---
 undefined | 特殊值undefined
 NaN | 特殊值NaN
 Infinity | 特殊值Infinity
 Object | 构造函数Object
 Array | 构造函数Array
 Function | 构造函数Function
 Boolean | 构造函数Boolean
 String | 构造函数String
 Number | 构造函数Number
 Date | 构造函数Date
 RegExp | 构造函数RegExp
 Error | 构造函数Error
 EvalError | 构造函数EvalError
 RangeError | 构造函数RangeError
 ReferenceError | 构造函数ReferenceError
 SyntaxError | 构造函数SyntaxError
 TypeError | 构造函数TypeError
 URIError | 构造函数URIError
 ECMAScript 5 明确禁止给 undefined、 NaN 和 Infinity 赋值，这样做即使在非严格模式下也会
 导致错误。
 
 4. window对象
 ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为
 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window
 对象的属性。
 
### Math对象
ECMAScript 还为保存数学公式和信息提供了一个公共位置，即 Math 对象。与我们在 JavaScript 直
接编写的计算功能相比， Math 对象提供的计算功能执行起来要快得多。 Math 对象中还提供了辅助完成
这些计算的属性和方法。

1. Math对象的属性

属性 | 说明
--- | ---
Math.E | 自然对数的底数，即常量e的值
Math.LN10 | 10的自然对数
Math.LN2 | 2的自然对数
Math.LOG2E | 以2为底e的对数
Math.LOG10E | 以10为底e的对数
Math.PI | π的值
Math.SQRT1_2 | 1/2的平方根（即2的平方根的倒数
Math.SQRT2 | 2的平方根

2. min()和max()方法
Math 对象还包含许多方法，用于辅助完成简单和复杂的数学计算。
其中， min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多
个数值参数。

3. 舍入方法
下面来介绍将小数值舍入为整数的几个方法： Math.ceil()、 Math.floor()和 Math.round()。
这三个方法分别遵循下列舍入规则：
- Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；
- Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；
- Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课
上学到的舍入规则）。

4. random()方法
Math.random()方法返回大于等于 0 小于 1 的一个随机数。

5. 其他方法
Math 对象中还包含其他一些与完成各种简单或复杂计算有关的方法，但详细讨论其中每一个方法
的细节及适用情形超出了本书的范围。下面我们就给出一个表格，其中列出了这些没有介绍到的 Math
对象的方法。

方法 | 说明
--- | ---
Math.abs(num) | 返回num 的绝对值 
Math.asin(x) | 返回x 的反正弦值
Math.exp(num) | 返回Math.E 的num 次幂 
Math.atan(x) | 返回x 的反正切值
Math.log(num) | 返回num 的自然对数
Math.atan2(y,x) | 返回y/x 的反正切值
Math.pow(num,power) | 返回num 的power 次幂 
Math.cos(x) | 返回x 的余弦值
Math.sqrt(num) | 返回num 的平方根 
Math.sin(x) | 返回x 的正弦值
Math.acos(x) | 返回x 的反余弦值 
Math.tan(x) | 返回x 的正切值

---
# 面向对象的程序设计
面向对象（Object-Oriented,OO）的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。
ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，
这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射
到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript 的对象想象成散列表：无
非就是一组名值对，其中值可以是数据或函数。

## 理解对象
创建自定义对象的最简单方式就是创建一个 Object 的实例，然后再为它添加
属性和方法。也可通过对象字面量来创建。

### 属性类型
ECMA-262 第 5 版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。
ECMA-262 定义这些特性是为了实现 JavaScript 引擎用的，因此在 JavaScript 中不能直接访问它们。为了
表示特性是内部值，该规范把它们放在了两对儿方括号中。

ECMAScript 中有两种属性：数据属性和访问器属性。
1. 数据属性
数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的
特性。
- [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特
  性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，它们的这个特性默认值为true。
- [[Enumerable]]：表示能否通过 for-in 循环返回属性。直接在对象上定
  义的属性，它们的这个特性默认值为 true。
- [[Writable]]：表示能否修改属性的值。直接在对象上定义的属性，它们的
  这个特性默认值为 true。
- [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，
  把新值保存在这个位置。这个特性的默认值为 undefined。
  
要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty()方法。这个方法
接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属
性必须是： configurable、 enumerable、 writable 和 value。设置其中的一或多个值，可以修改
对应的特性值。
```js
var person = {};
Object.defineProperty(person, "name", {
writable: false,
value: "Nicholas"
});
alert(person.name); //"Nicholas"
person.name = "Greg";
alert(person.name); //"Nicholas"
```  
这个例子创建了一个名为 name 的属性，它的值"Nicholas"是只读的。这个属性的值是不可修改
的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导
致抛出错误。

类似的规则也适用于不可配置的属性。
```js
var person = {};
Object.defineProperty(person, "name", {
configurable: false,
value: "Nicholas"
});
alert(person.name); //"Nicholas"
delete person.name;
alert(person.name); //"Nicholas"
```

把 configurable 设置为 false，表示不能从对象中删除属性。如果对这个属性调用 delete，则
在非严格模式下什么也不会发生，而在严格模式下会导致错误。而且，一旦把属性定义为不可配置的，
就不能再把它变回可配置了。此时，再调用 Object.defineProperty()方法修改除 writable 之外
的特性，都会导致错误。

2. 访问器属性
访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。
在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用
setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。
- [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特
  性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为
  true。
- [[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这
  个特性的默认值为 true。
- [[Get]]：在读取属性时调用的函数。默认值为 undefined。
- [[Set]]：在写入属性时调用的函数。默认值为 undefined。

访问器属性不能直接定义，必须使用 Object.defineProperty()来定义。
```js
var book = {
_year: 2004,
edition: 1
};
Object.defineProperty(book, "year", {
get: function(){
return this._year;
},
set: function(newValue){
if (newValue > 2004) {
this._year = newValue;
this.edition += newValue - 2004;
}
}
});
book.year = 2005;
alert(book.edition); //2
```

 不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性是不能写，尝试写入属性会被忽略。
 在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也
 不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。
 支持 ECMAScript 5 的这个方法的浏览器有 IE9+（IE8 只是部分实现）、 Firefox 4+、 Safari 5+、 Opera
 12+ 和 Chrome 。 在 这 个 方 法 之 前 ， 要 创 建 访 问 器 属 性 ， 一 般 都 使 用 两 个 非 标 准 的 方 法 ：
 __defineGetter__()和__defineSetter__()。这两个方法最初是由 Firefox 引入的，后来 Safari 3、
 Chrome 1 和 Opera 9.5 也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子。
 ```js
var book = {
_year: 2004,
edition: 1
};
//定义访问器的旧有方法
book.__defineGetter__("year", function(){
return this._year;
});
book.__defineSetter__("year", function(newValue){
if (newValue > 2004) {
this._year = newValue;
this.edition += newValue - 2004;
}
});
book.year = 2005;
alert(book.edition); //2
```

### 定义多个属性
由于为对象定义多个属性的可能性很大， ECMAScript 5 又定义了一个 Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一
个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对
应。
```js
var book = {};
Object.defineProperties(book, {
_year: {
value: 2004
},
edition: {
value: 1
},
year: {
get: function(){
return this._year;
},
set: function(newValue){
if (newValue > 2004) {
this._year = newValue;
this.edition += newValue - 2004;
}
}
}
});  
```
### 读取属性的特性
使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述
符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果
是访问器属性，这个对象的属性有 configurable、 enumerable、 get 和 set；如果是数据属性，这
个对象的属性有 configurable、 enumerable、 writable 和 value。

## 创建对象
虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同
一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。

### 工厂模式
工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。
考虑到在 ECMAScript 中无法创建类，开发人员
就发明了一种函数，用函数来封装以特定接口创建对象的细节。
```javascript
function createPerson(name, age, job){
var o = new Object();
o.name = name;
o.age = age;
o.job = job;
o.sayName = function(){
alert(this.name);
};
return o;
}
var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");
```

### 构造函数模式
ECMAScript 中的构造函数可用来创建特定类型的对象。像 Object 和 Array 这样
的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义
自定义对象类型的属性和方法。
```javascript
function Person(name, age, job){
this.name = name;
this.age = age;
this.job = job;
this.sayName = function(){
alert(this.name);
};
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
```
在这个例子中， Person()函数取代了 createPerson()函数。我们注意到， Person()中的代码
除了与 createPerson()中相同的部分外，还存在以下不同之处：
- 没有显式地创建对象；
- 直接将属性和方法赋给了 this 对象；
- 没有 return 语句。
此外，还应该注意到函数名 Person 使用的是大写字母 P。按照惯例，构造函数始终都应该以一个
大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他 OO 语言，主要是为了
区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。
要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4
个步骤：
(1) 创建一个新对象；
(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；
(3) 执行构造函数中的代码（为这个新对象添加属性）；
(4) 返回新对象。
在前面例子的最后， person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都
有一个 constructor（构造函数）属性，该属性指向 Person。
对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person
的实例，这一点通过 instanceof 操作符可以得到验证。

1. 将构造函数当作函数
构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不
存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数；而
任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。

2. 构造函数的问题
构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个
实例上重新创建一遍。在前面的例子中， person1 和 person2 都有一个名为 sayName()的方法，但那
两个方法不是同一个 Function 的实例。不要忘了——ECMAScript 中的函数是对象，因此每定义一个
函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。
然而，创建两个完成同样任务的 Function 实例的确没有必要；况且有 this 对象在，根本不用在
执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外
部来解决这个问题。
```javascript
function Person(name, age, job){
this.name = name;
this.age = age;
this.job = job;
this.sayName = sayName;
}
function sayName(){
alert(this.name);
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
```
在这个例子中，我们把 sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们
将 sayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数
的指针，因此 person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName()函数。这
样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只
能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方
法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，
这些问题可以通过使用原型模式来解决。

### 原型模式
在这个例子中，我们把 sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们
将 sayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数
的指针，因此 person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName()函数。这
样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只
能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方
法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，
这些问题可以通过使用原型模式来解决。
```javascript
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
alert(this.name);
};
var person1 = new Person();
person1.sayName(); //"Nicholas"
var person2 = new Person();
person2.sayName(); //"Nicholas"
alert(person1.sayName == person2.sayName); //true
```

1. 理解原型对象
无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype
属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor
（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。

创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则
都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部
属性），指向构造函数的原型对象。 ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中
没有标准的方式访问[[Prototype]]，但 Firefox、 Safari 和 Chrome 在每个对象上都支持一个属性
__proto__；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就
是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。

虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之
间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用 isPrototypeOf()方法的对象
（Person.prototype），那么这个方法就返回 true。

ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个
方法返回[[Prototype]]的值。

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先
从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，
则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这
个属性，则返回该属性的值。

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们
在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该
属性将会屏蔽原型中的那个属性。使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。

使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不
要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。

2. 原型与in操作符
有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时， in 操作符会在通
过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。
```javascript
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
alert(this.name);
};
var person1 = new Person();
var person2 = new Person();
alert(person1.hasOwnProperty("name")); //false
alert("name" in person1); //true
person1.name = "Greg";
alert(person1.name); //"Greg" —— 来自实例
alert(person1.hasOwnProperty("name")); //true
alert("name" in person1); //true
alert(person2.name); //"Nicholas" —— 来自原型
alert(person2.hasOwnProperty("name")); //false
alert("name" in person2); //true
delete person1.name;
alert(person1.name); //"Nicholas" —— 来自原型
alert(person1.hasOwnProperty("name")); //false
alert("name" in person1); //true
```
在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中
既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将
[[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所
有开发人员定义的属性都是可枚举的——只有在 IE8 及更早版本中例外。

要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 Object.keys()方法。

如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames()
方法。

3. 更简单的原型语法
为减少
不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的
对象字面量来重写整个原型对象。
```javascript
function Person(){
}
Person.prototype = {
name : "Nicholas",
age : 29,
job: "Software Engineer",
sayName : function () {
alert(this.name);
}
};
```
在上面的代码中，我们将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。
最终结果相同，但有一个例外： constructor 属性不再指向 Person 了。

4. 原型的动态性
由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上
反映出来——即使是先创建了实例后修改原型也照样如此。

尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重
写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的
[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。
请记住：实例中的指针仅指向原型，而不指向构造函数。

5. 原生对象的原型
原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式
创建的。所有原生引用类型（Object、 Array、 String，等等）都在其构造函数的原型上定义了方法。

6. 原型对象的问题
原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在
默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。
原型模式的最大问题是由其共享的本性所导致的。

原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒
也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属
性。然而，对于包含引用类型值的属性来说，问题就比较突出了。


### 组合使用构造函数模式和原型模式
创建自定义类型的最常见的方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性。，
而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，
最大限度地节省了内存。。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。
```javascript
function Person(name, age, job){
this.name = name;
this.age = age;
this.job = job;
this.friends = ["Shelby", "Court"];
}
Person.prototype = {
constructor : Person,
sayName : function(){
alert(this.name);
}
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
person1.friends.push("Van");
alert(person1.friends); //"Shelby,Count,Van"
alert(person2.friends); //"Shelby,Count"
alert(person1.friends === person2.friends); //false
alert(person1.sayName === person2.sayName); //true
```

### 动态原型模式
有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原
型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数
中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过
检查某个应该存在的方法是否有效，来决定是否需要初始化原型。
```javascript
function Person(name, age, job){
//属性
this.name = name;
this.age = age;
this.job = job;
//方法
if (typeof this.sayName != "function"){
Person.prototype.sayName = function(){
alert(this.name);
};
}
}
var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName();
```
这里只在 sayName()方法不存在的情况下，才会将它添加到原
型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修
改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可
以说非常完美。其中， if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆
if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使
用 instanceof 操作符确定它的类型。

### 寄生构造函数模式
通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式
的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但
从表面上看，这个函数又很像是典型的构造函数。
```javascript
function Person(name, age, job){
var o = new Object();
o.name = name;
o.age = age;
o.job = job;
o.sayName = function(){
alert(this.name);
};
return o;
}
var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName(); //"Nicholas"
```
关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属
性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，
不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情
况下，不要使用这种模式。

### 稳妥构造函数模式
所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在
一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup
程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的
实例方法不引用 this；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面
的 Person 构造函数重写如下。
```javascript
function Person(name, age, job){
//创建要返回的对象
var o = new Object();
//可以在这里定义私有变量和函数
//添加方法
o.sayName = function(){
alert(name);
};
//返回对象
return o;
}
```

## 继承
继承是 OO 语言中的一个最为人津津乐道的概念。许多 OO 语言都支持两种继承方式：接口继承和
实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，
在 ECMAScript 中无法实现接口继承。 ECMAScript 只支持实现继承，而且其实现继承主要是依靠原型链
来实现的。

### 原型链
ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原
型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每
个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型
对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的
原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数
的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实
例与原型的链条。这就是所谓原型链的基本概念。
```javascript
function SuperType(){
this.property = true;
}
SuperType.prototype.getSuperValue = function(){
return this.property;
};
function SubType(){
this.subproperty = false;
}
//继承了 SuperType
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function (){
return this.subproperty;
};
var instance = new SubType();
alert(instance.getSuperValue()); //true
```

1. 别忘记默认的原型
事实上，前面例子中展示的原型链还少一环。我们知道，所有引用类型默认都继承了 Object，而
这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是 Object 的实例，因此默认原
型都会包含一个内部指针，指向 Object.prototype。这也正是所有自定义类型都会继承 toString()、
valueOf()等默认方法的根本原因。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层
次。

2. 确定原型和实例的关系
可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用 instanceof 操作符，只要用
这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。
由于原型链的关系，我们可以说 instance 是 Object、 SuperType 或 SubType 中任何一个类型
的实例。因此，测试这三个构造函数的结果都返回了 true。

第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该
原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true。

3. 谨慎地定义方法
子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎
样，给原型添加方法的代码一定要放在替换原型的语句之后。

**在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这
  样做就会重写原型链**
  
4. 原型链的问题
原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引
用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；而
这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原
型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。

原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，
应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上
前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。

### 借用构造函数
在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数
（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即
在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，
因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数。
```javascript
function SuperType(){
this.colors = ["red", "blue", "green"];
}
function SubType(){
//继承了 SuperType
SuperType.call(this);
}
var instance1 = new SubType();
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"
var instance2 = new SubType();
alert(instance2.colors); //"red,blue,green"
```
1. 传递参数
相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函
数传递参数。
```javascript
function SuperType(name){
this.name = name;
}
function SubType(){
//继承了 SuperType，同时还传递了参数
SuperType.call(this, "Nicholas");
//实例属性
this.age = 29;
}
var instance = new SubType();
alert(instance.name); //"Nicholas";
alert(instance.age); //29
```
2. 借用构造函数的问题
如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定
义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结
果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。

### 组合继承
组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的
技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方
法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数
复用，又能够保证每个实例都有它自己的属性。
```javascript
function SuperType(name){
this.name = name;
this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
alert(this.name);
};
function SubType(name, age){
//继承属性
SuperType.call(this, name);
this.age = age;
}
//继承方法
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){
alert(this.age);
};
var instance1 = new SubType("Nicholas", 29);
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //"Nicholas";
instance1.sayAge(); //29
var instance2 = new SubType("Greg", 27);
alert(instance2.colors); //"red,blue,green"
instance2.sayName(); //"Greg";
instance2.sayAge(); //27
```

### 原型式继承
道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript （JavaScript
中的原型式继承）。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的
构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为
了达到这个目的，他给出了如下函数。
```javascript
function object(o){
function F(){}
F.prototype = o;
return new F();
}
```
ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一
个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，
Object.create()与 object()方法的行为相同。
Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相
同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属
性。

### 寄生式继承
寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广
之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该
函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。
```javascript
function createAnother(original){
var clone = object(original); //通过调用函数创建一个新对象
clone.sayHi = function(){ //以某种方式来增强这个对象
alert("hi");
};
return clone; //返回这个对象
}
```

### 寄生组合式继承
前面说过，组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的
问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是
在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子
类型构造函数时重写这些属性。


---
# 函数表达式
函数表达式是 JavaScript 中的一个既强大又容易令人困惑的特性。定义函数的
 方式有两种：一种是函数声明，另一种就是函数表达式。函数声明的语法是这样的。
```javascript
function functionName(arg0, arg1, arg2) {
//函数体
}
``` 
关于函数声明，它的一个重要特征就是函数声明提升（function declaration hoisting），意思是在执行
代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。
 
第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。
```javascript
var functionName = function(arg0, arg1, arg2){
//函数体
};
``` 
这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量 functionName。
这种情况下创建的函数叫做匿名函数（anonymous function），因为 function 关键字后面没有标识符。
（匿名函数有时候也叫拉姆达函数。）匿名函数的 name 属性是空字符串。

理解函数提升的关键，就是理解函数声明与函数表达式之间的区别。

## 递归
递归函数是在一个函数通过名字调用自身的情况下构成的。
```javascript
function factorial(num){
if (num <= 1){
return 1;
} else {
return num * factorial(num-1);
}
}
```
arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数
的递归调用，
```javascript
function factorial(num){
if (num <= 1){
return 1;
} else {
return num * arguments.callee(num-1);
}
}
```
通过使用 arguments.callee 代替函数名，可以确保无论怎样调用函数都不会
出问题。因此，在编写递归函数时，使用 arguments.callee 总比使用函数名更保险。
但在严格模式下，不能通过脚本访问 arguments.callee，访问这个属性会导致错误。不过，可
以使用命名函数表达式来达成相同的结果。
```javascript
var factorial = (function f(num){
if (num <= 1){
return 1;
} else {
return num * f(num-1);
}
});
```

## 闭包
闭包是指有权访问另一个
函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数
```javascript
function createComparisonFunction(propertyName) {
return function(object1, object2){
var value1 = object1[propertyName];
var value2 = object2[propertyName];
if (value1 < value2){
return -1;
} else if (value1 > value2){
return 1;
} else {
return 0;
}
};
}
```

1. 闭包与变量
作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最
后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。

2. 关于this对象
在闭包中使用 this 对象也可能会导致一些问题。我们知道， this 对象是在运行时基于函数的执
行环境绑定的：在全局函数中， this 等于 window，而当函数被作为某个对象的方法调用时， this 等
于那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window①。但有时候
由于编写闭包的方式不同，这一点可能不会那么明显。

3. 内存泄漏

## 模仿块级作用域
JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不
见（不过，它会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。
```javascript
(function(){
//这里是块级作用域
})();
```
函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式，
只要像下面这样给它加上一对圆括号即可。

## 私有变量
严格来讲， JavaScript 中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有
变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。
私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。
```javascript
function add(num1, num2){
var sum = num1 + num2;
return sum;
}
```
在这个函数内部，有 3 个私有变量： num1、 num2 和 sum。在函数内部可以访问这几个变量，但在
函数外部则不能访问它们。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访
问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。
我们把有权访问私有变量和私有函数的公有方法称为特权方法（privileged method）。有两种在对象
上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。
```javascript
function MyObject(){
//私有变量和私有函数
var privateVariable = 10;
function privateFunction(){
return false;
}
//特权方法
this.publicMethod = function (){
privateVariable++;
return privateFunction();
};
}
```

### 静态私有变量
通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下所示。
```javascript
(function(){
//私有变量和私有函数
var privateVariable = 10;
function privateFunction(){
return false;
}
//构造函数
MyObject = function(){
};
//公有/特权方法
MyObject.prototype.publicMethod = function(){
privateVariable++;
return privateFunction();
};
})();
```

### 模块模式
前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module
pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。
按照惯例， JavaScript 是以对象字面量的方式来创建单例对象的。

模块模式通过为单例添加私有变量和特权方法能够使其得到增强。
```javascript
var singleton = function(){
//私有变量和私有函数
var privateVariable = 10;
function privateFunction(){
return false;
}
//特权/公有方法和属性
return {
publicProperty: true,
publicMethod : function(){
privateVariable++;
return privateFunction();
}
};
}();
```

### 增强的模块模式
有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那
些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。
```javascript
var application = function(){
//私有变量和函数
var components = new Array();
//初始化
components.push(new BaseComponent());
//创建 application 的一个局部副本
var app = new BaseComponent();
//公共接口
app.getComponentCount = function(){
return components.length;
};
app.registerComponent = function(component){
if (typeof component == "object"){
components.push(component);
}
};
//返回这个副本
return app;
}();
```

---
# BOM
ECMAScript 是 JavaScript 的核心，但如果要在 Web 中使用 JavaScript，那么 BOM（浏览器对象模
型）则无疑才是真正的核心。 BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任
何网页内容无关。多年来，缺少事实上的规范导致 BOM 既有意思又有问题，因为浏览器提供商会按照各
自的想法随意去扩展它。于是，浏览器之间共有的对象就成为了事实上的标准。这些对象在浏览器中得以
存在，很大程度上是由于它们提供了与浏览器的互操作性。 W3C 为了把浏览器中 JavaScript 最基本的部分
标准化，已经将 BOM 的主要方面纳入了 HTML5 的规范中。

## window对象
BOM 的核心对象是 window，它表示浏览器的一个实例。在浏览器中， window 对象有双重角色，
它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。这意味着
在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象，因此有权访问
parseInt()等方法。

### 全局作用域
由于 window 对象同时扮演着 ECMAScript 中 Global 对象的角色，因此所有在全局作用域中声明
的变量、函数都会变成 window 对象的属性和方法。

抛开全局变量会成为 window 对象的属性不谈，定义全局变量与在 window 对象上直接定义属性还
是有一点差别：全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。

尝试访问未声明的变量会抛出错误，但是通过查询 window 对象，可以知
道某个可能未声明的变量是否存在。

### 窗口关系及框架
如果页面中包含框架，则每个框架都拥有自己的 window 对象，并且保存在 frames 集合中。在 frames
集合中，可以通过数值索引（从 0 开始，从左至右，从上到下）或者框架名称来访问相应的 window 对
象。每个 window 对象都有一个 name 属性，其中包含框架的名称。
```html
<html>
<head>
<title>Frameset Example</title>
</head>
<frameset rows="160,*">
<frame src="frame.htm" name="topFrame">
<frameset cols="50%,50%">
<frame src="anotherframe.htm" name="leftFrame">
<frame src="yetanotherframe.htm" name="rightFrame">
</frameset>
</frameset>
</html>
```
![img](./img/frame.png)

### 窗口位置
用来确定和修改 window 对象位置的属性和方法有很多。 IE、 Safari、 Opera 和 Chrome 都提供了
screenLeft 和 screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。 Firefox 则在
screenX 和 screenY 属性中提供相同的窗口位置信息， Safari 和 Chrome 也同时支持这两个属性。 Opera
虽然也支持 screenX 和 screenY 属性，但与 screenLeft 和 screenTop 属性并不对应，因此建议大
家不要在 Opera 中使用它们。使用下列代码可以跨浏览器取得窗口左边和上边的位置。
```javascript
var leftPos = (typeof window.screenLeft == "number") ?
window.screenLeft : window.screenX;
var topPos = (typeof window.screenTop == "number") ?
window.screenTop : window.screenY;
```

### 窗口大小
跨浏览器确定一个窗口的大小不是一件简单的事。 IE9+、 Firefox、 Safari、 Opera 和 Chrome 均为此提
供了 4 个属性： innerWidth、 innerHeight、 outerWidth 和 outerHeight。

在 IE、 Firefox、 Safari、 Opera 和 Chrome 中， document.documentElement.clientWidth 和
document.documentElement.clientHeight 中保存了页面视口的信息。
虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小.
```javascript
var pageWidth = window.innerWidth,
pageHeight = window.innerHeight;
if (typeof pageWidth != "number"){
if (document.compatMode == "CSS1Compat"){
pageWidth = document.documentElement.clientWidth;
pageHeight = document.documentElement.clientHeight;
} else {
pageWidth = document.body.clientWidth;
pageHeight = document.body.clientHeight;
}
}
```

### 导航和打开窗口
使用 window.open()方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。这个
方法可以接收 4 个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览
器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情
况下使用。

1.弹出窗口
如果给 window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根
据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会
打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页—
—根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。
第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出了可以出现
在这个字符串中的设置选项。

设置 | 值 | 说明
--- | --- | ---
fullscreen | yes或no | 表示浏览器窗口是否最大化。仅限IE
height | 数值 |  表示新窗口的高度。不能小于100
left | 数值 | 表示新窗口的左坐标。不能是负值
location | yes或no | 表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器）
menubar | yes或no | 表示是否在浏览器窗口中显示菜单栏。默认值为no
resizable | yes或no | 表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no
scrollbars | yes或no | 表示如果内容在视口中显示不下，是否允许滚动。默认值为no
status | yes或no | 表示是否在浏览器窗口中显示状态栏。默认值为no
toolbar | yes或no | 表示是否在浏览器窗口中显示工具栏。默认值为no
top | 数值 | 表示新窗口的上坐标。不能是负值
width | 数值 | 表示新窗口的宽度。不能小于100

表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号
表示（注意，整个特性字符串中不允许出现空格）

2. 安全限制
曾经有一段时间，广告商在网上使用弹出窗口达到了肆无忌惮的程度。他们经常把弹出窗口打扮成
系统对话框的模样，引诱用户去点击其中的广告。由于看起来像是系统对话框，一般用户很难分辨是真
是假。为了解决这个问题，有些浏览器开始在弹出窗口配置方面增加限制

3. 弹出窗口屏蔽程序

### 间歇调用和超时调用
JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。
前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。
超时调用需要使用 window 对象的 setTimeout()方法，它接受两个参数：要执行的代码和以毫秒
表示的时间（即在执行代码前需要等待多少毫秒）。其中，第一个参数可以是一个包含 JavaScript 代码的
字符串（就和在 eval()函数中使用的字符串一样），也可以是一个函数。

调用 setTimeout()之后，该方法会返回一个数值 ID，表示超时调用。这个超时调用 ID 是计划执
行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用
clearTimeout()方法并将相应的超时调用 ID 作为参数传递给它，
```javascript
//设置超时调用
var timeoutId = setTimeout(function() {
alert("Hello world!");
}, 1000);
//注意：把它取消
clearTimeout(timeoutId);
```
间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或
者页面被卸载。设置间歇调用的方法是 setInterval()，它接受的参数与 setTimeout()相同：要执
行的代码（字符串或函数）和每次执行之前需要等待的毫秒数。

在使用超时调用时，没有必要跟踪超时调用 ID，因为每次执行代码之后，如果不再设置另
一次超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开
发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。
而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。

### 系统对话框
浏览器通过 alert()、 confirm()和 prompt()方法可以调用系统对话框向用户显示消息。系统对
话框与在浏览器中显示的网页没有关系，也不包含 HTML。它们的外观由操作系统及（或）浏览器设置
决定，而不是由 CSS 决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这
些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。


## location对象
location 是最有用的 BOM 对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一
些导航功能。事实上， location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是
document 对象的属性；换句话说， window.location 和 document.location 引用的是同一个对象。
location 对象的用处不只表现在它保存着当前文档的信息，还表现在它将 URL 解析为独立的片段，让
开发人员可以通过不同的属性访问这些片段。

属性名 | 例子 | 说明 
--- | --- | ---
hash | "#contents" | 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串
host | "www.wrox.com:80" | 返回服务器名称和端口号（如果有）
hostname | "www.wrox.com" | 返回不带端口号的服务器名称
href | "http:/www.wrox.com" | 返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值
pathname | "/WileyCDA/" | 返回URL中的目录和（或）文件名
port | "8080" | 返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串
protocol | "http:" | 返回页面使用的协议。通常是http:或https:
search | "?q=javascript" | 返回URL的查询字符串。这个字符串以问号开头

### 查询字符串参数
虽然通过上面的属性可以访问到 location 对象的大多数信息，但其中访问 URL 包含的查询字符
串的属性并不方便。尽管 location.search 返回从问号到 URL 末尾的所有内容，但却没有办法逐个
访问其中的每个查询字符串参数。为此，可以像下面这样创建一个函数，用以解析查询字符串，然后返
回包含所有参数的一个对象。
```javascript
function getQueryStringArgs(){
//取得查询字符串并去掉开头的问号
var qs = (location.search.length > 0 ? location.search.substring(1) : ""),
//保存数据的对象
args = {},
//取得每一项
items = qs.length ? qs.split("&") : [],
item = null,
name = null,
value = null,
//在 for 循环中使用
i = 0,
len = items.length;
//逐个将每一项添加到 args 对象中
for (i=0; i < len; i++){
item = items[i].split("=");
name = decodeURIComponent(item[0]);
value = decodeURIComponent(item[1]);
if (name.length) {
args[name] = value;
}
}
return args;
}
```
### 位置操作
使用 location 对象可以通过很多方式来改变浏览器的位置。首先，也是最常用的方式，就是使用
assign()方法并为其传递一个 URL.
```javascript
location.assign("http://www.wrox.com");
```
这样，就可以立即打开新 URL 并在浏览器的历史记录中生成一条记录。如果是将 location.href
或 window.location 设置为一个 URL 值，也会以该值调用 assign()方法。

下列两行代码与显式调用 assign()方法的效果完全一样。
```javascript
window.location = "http://www.wrox.com";
location.href = "http://www.wrox.com";
```
另外，修改location 对象的其他属性也可以改变当前加载的页面。下面的例子展示了通过将hash、
search、 hostname、 pathname 和 port 属性设置为新值来改变 URL。
```javascript
//假设初始 URL 为 http://www.wrox.com/WileyCDA/
//将 URL 修改为"http://www.wrox.com/WileyCDA/#section1"
location.hash = "#section1";
//将 URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"
location.search = "?q=javascript";
//将 URL 修改为"http://www.yahoo.com/WileyCDA/"
location.hostname = "www.yahoo.com";
//将 URL 修改为"http://www.yahoo.com/mydir/"
location.pathname = "mydir";
//将 URL 修改为"http://www.yahoo.com:8080/WileyCDA/"
location.port = 8080;
```

当通过上述任何一种方式修改 URL 之后，浏览器的历史记录中就会生成一条新记录，因此用户通
过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用 replace()方法。这个方法
只接受一个参数，即要导航到的 URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记
录。

## navigator对象
最早由 Netscape Navigator 2.0 引入的 navigator 对象，现在已经成为识别客户端浏览器的事实标
准。虽然其他浏览器也通过其他方式提供了相同或相似的信息，但 navigator 对象却是所有支持 JavaScript 的浏览器所共有
的。与其他 BOM 对象的情况一样，每个浏览器中的 navigator 对象也都有一套自己的属性。

属性或方法 | 说明 | IE | Firefox | Safari/Chrome | Opera
--- | --- | --- | --- | --- | ---
appCodeName | 浏览器的名称。通常都是Mozilla，即使在非Mozilla浏览器中也是如此 | 3.0+ | 1.0+ | 1.0+ | 7.0+
appMinorVersion | 次版本信息 | 4.0+ | －| － | 9.5+
appName | 完整的浏览器名称 | 3.0+ | 1.0+ | 1.0+ | 7.0+
appVersion | 浏览器的版本。一般不与实际的浏览器版本对应 | 3.0+ | 1.0+ | 1.0+ | 7.0+
buildID | 浏览器编译版本 | － | 2.0+ | － | －
cookieEnabled | 表示cookie是否启用 | 4.0+ | 1.0+ | 1.0+ | 7.0+
cpuClass | 客户端计算机中使用的CPU类型（x86、68K、 Alpha、 PPC或Other） | 4.0+ | － | － | －
javaEnabled() | 表示当前浏览器中是否启用了Java | 4.0+ | 1.0+ | 1.0+ | 7.0+
language | 浏览器的主语言 | － | 1.0+ | 1.0+ | 7.0+
mimeTypes | 在浏览器中注册的MIME类型数组 | 4.0+ | 1.0+ | 1.0+ | 7.0+
onLine | 表示浏览器是否连接到了因特网 | 4.0+ | 1.0+ | － | 9.5+
opsProfile | 似乎早就不用了。查不到相关文档 | 4.0+ | － | － | －
oscpu | 客户端计算机的操作系统或使用的CPU | － | 1.0+ | － | －
platform | 浏览器所在的系统平台 | 4.0+ | 1.0+ | 1.0+ | 7.0+
plugins | 浏览器中安装的插件信息的数组 | 4.0+ | 1.0+ | 1.0+ | 7.0+
preference() | 设置用户的首选项 | － | 1.5+ | － | －
product | 产品名称（如 Gecko） | － | 1.0+ | 1.0+ | －
productSub | 关于产品的次要信息（如Gecko的版本） | － | 1.0+ | 1.0+ | －
registerContentHandler() | 针对特定的MIME类型将一个站点注册为处理程序 | － | 2.0+ | － | －
registerProtocolHandler() | 针对特定的协议将一个站点注册为处理程序 | －  | 2.0 | －  | －
securityPolicy | 已经废弃。安全策略的名称。为了与Netscape Navigator 4向后兼容而保留下来 | － | 1.0+ | － | －
systemLanguage | 操作系统的语言 | 4.0+ | － | － | －
taintEnabled() | 已经废弃。表示是否允许变量被修改（taint）。为了与Netscape Navigator 3向后兼容而保留下来 | 4.0+ | 1.0+ | － | 7.0+
userAgent | 浏览器的用户代理字符串 | 3.0+ | 1.0+ | 1.0+ | 7.0+
userLanguage | 操作系统的默认语言 | 4.0+ | － | － | 7.0+
userProfile | 借以访问用户个人信息的对象 | 4.0+ | － | － | －
vendor | 浏览器的品牌 | － | 1.0+ | 1.0+ | －
vendorSub | 有关供应商的次要信息 | － | 1.0+ | 1.0+ | －

### 检测插件
检测浏览器中是否安装了特定的插件是一种最常见的检测例程。对于非 IE 浏览器，可以使用
plugins 数组来达到这个目的。该数组中的每一项都包含下列属性。
- name：插件的名字。
- description：插件的描述。
- filename：插件的文件名。
- length：插件所处理的 MIME 类型数量。
一般来说， name 属性中会包含检测插件必需的所有信息，但有时候也不完全如此。在检测插件时，
需要像下面这样循环迭代每个插件并将插件的 name 与给定的名字进行比较。
```javascript
//检测插件（在 IE 中无效）
function hasPlugin(name){
name = name.toLowerCase();
for (var i=0; i < navigator.plugins.length; i++){
if (navigator. plugins [i].name.toLowerCase().indexOf(name) > -1){
return true;
}
}
return false;
}
```

检测 IE 中的插件比较麻烦，因为 IE 不支持 Netscape 式的插件。在 IE 中检测插件的唯一方式就是
使用专有的 ActiveXObject 类型，并尝试创建一个特定插件的实例。 IE 是以 COM 对象的方式实现插
件的，而 COM 对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其 COM 标识符。
例如， Flash 的标识符是 ShockwaveFlash.ShockwaveFlash。知道唯一标识符之后，就可以编写类似
下面的函数来检测 IE 中是否安装相应插件了。
```javascript
//检测 IE 中的插件
function hasIEPlugin(name){
try {
new ActiveXObject(name);
return true;
} catch (ex){
return false;
}
}
```

鉴于检测这两种插件的方法差别太大，因此典型的做法是针对每个插件分别创建检测函数，而不是
使用前面介绍的通用检测方法。
```javascript
//检测所有浏览器中的 Flash
function hasFlash(){
var result = hasPlugin("Flash");
if (!result){
result = hasIEPlugin("ShockwaveFlash.ShockwaveFlash");
}
return result;
}
//检测所有浏览器中的 QuickTime
function hasQuickTime(){
var result = hasPlugin("QuickTime");
if (!result){
result = hasIEPlugin("QuickTime.QuickTime");
}
return result;
}
```

### 注册处理程序
Firefox 2 为 navigator 对象新增了 registerContentHandler()和 registerProtocolHandler()方
法。这两个方法可以让一个站点指明它可以处理特定类型的信息。随着 RSS 阅读器和在线电子邮件程序的兴起，
注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。

其中， registerContentHandler()方法接收三个参数：要处理的 MIME 类型、可以处理该 MIME
类型的页面的 URL 以及应用程序的名称。
```javascript
navigator.registerContentHandler("application/rss+xml",
"http://www.somereader.com?feed=%s", "Some Reader");
```
第一个参数是 RSS 源的 MIME 类型。第二个参数是应该接收 RSS 源 URL 的 URL，其中的%s 表示
RSS 源 URL，由浏览器自动插入。当下一次请求 RSS 源时，浏览器就会打开指定的 URL，而相应的
Web 应用程序将以适当方式来处理该请求。

类似的调用方式也适用于 registerProtocolHandler()方法，它也接收三个参数：要处理的协
议（例如， mailto 或 ftp）、处理该协议的页面的 URL 和应用程序的名称。
```javascript
navigator.registerProtocolHandler("mailto",
"http://www.somemailclient.com?cmd=%s", "Some Mail Client");
```
## screen对象
JavaScript 中有几个对象在编程中用处不大，而 screen 对象就是其中之一。 screen 对象基本上只
用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。

属性 | 说明 | IE | Firefox | Safari/Chrome | Opera
--- | --- | --- | --- | --- | ---
availHeight | 屏幕的像素高度减系统部件高度之后的值（只读） | true  | true  | true  | true 
availLeft | 未被系统部件占用的最左侧的像素值（只读） | true  | true | 
availTop | 未被系统部件占用的最上方的像素值（只读） | true  | true |
availWidth | 屏幕的像素宽度减系统部件宽度之后的值（只读） | true  | true  | true  | true 
bufferDepth | 读、写用于呈现屏外位图的位数 | true |
colorDepth | 用于表现颜色的位数；多数系统都是32（只读） | true  | true  | true  | true 
deviceXDPI | 屏幕实际的水平DPI（只读） | true |
deviceYDPI | 屏幕实际的垂直DPI（只读） | true |
fontSmoothingEnabled | 表示是否启用了字体平滑（只读） | true |
height | 屏幕的像素高度 | true  | true  | true  | true |
left | 当前屏幕距左边的像素距离 | true |
logicalXDPI | 屏幕逻辑的水平DPI（只读） | true |
logicalYDPI | 屏幕逻辑的垂直DPI（只读） | true |
pixelDepth | 屏幕的位深（只读） | true  | true  | true |
top | 当前屏幕距上边的像素距离 | true | 
updateInterval | 读、写以毫秒表示的屏幕刷新时间间隔 | true |
width | 屏幕的像素宽度 | true  | true  | true  | true |

## history对象
history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为 history 是 window
对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的 history 对象与特定的
window 对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的 URL。不过，借由用户访问
过的页面列表，同样可以在不知道实际 URL 的情况下实现后退和前进。
使用 go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，
表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），
正数表示向前跳转（类似于单击浏览器的“前进”按钮）。

也可以给 go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个
位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个
方法什么也不做。

另外，还可以使用两个简写方法 back()和 forward()来代替 go()。顾名思义，这两个方法可以
模仿浏览器的“后退”和“前进”按钮。
---
# 客户端检测
迄今为止，客户端检测仍然是 Web 开发领域中一个饱受争议的话题。一谈到这个话题，人们总会
不约而同地提到浏览器应该支持一组最常用的公共功能。在理想状态下，确实应该如此。但是，在现实
当中，浏览器之间的差异以及不同浏览器的“怪癖”（quirk），多得简直不胜枚举。因此，客户端检测除
了是一种补救措施之外，更是一种行之有效的开发策略。

检测 Web 客户端的手段很多，而且各有利弊。但最重要的还是要知道，不到万不得已，就不要使
用客户端检测。只要能找到更通用的方法，就应该优先采用更通用的方法。一言以蔽之，先设计最通用
的方案，然后再使用特定于浏览器的技术增强该方案。

## 能力检测
最常用也最为人们广泛接受的客户端检测形式是能力检测（又称特性检测）。能力检测的目标不是
识别特定的浏览器，而是识别浏览器的能力。采用这种方式不必顾及特定的浏览器如何如何，只要确定
浏览器支持特定的能力，就可以给出解决方案。

要理解能力检测，首先必须理解两个重要的概念。如前所述，第一个概念就是先检测达成目的的最常
用的特性。第二个重要的概念就是必须测试实际要用到的特性。一个特性存在，不一定意味着另一个特性也存在。

### 更可靠的能力检测
能力检测对于想知道某个特性是否会按照适当方式行事（而不仅仅是某个特性存在）非常有用。

在可能的情况下，要尽量使用 typeof 进行能力检测。特别是，宿主对象没有义务让 typeof 返回
合理的值。

### 能力检测，不是浏览器检测
检测某个或某几个特性并不能够确定浏览器。

## 怪癖检测
与能力检测类似， 怪癖检测（quirks detection）的目标是识别浏览器的特殊行为。但与能力检测确
认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（“怪癖”也就是 bug）。这通常
需要运行一小段代码，以确定某一特性不能正常工作。

## 用户代理检测
第三种，也是争议最大的一种客户端检测技术叫做用户代理检测。用户代理检测通过检测用户代理
字符串来确定实际使用的浏览器。在每一次 HTTP 请求过程中，用户代理字符串是作为响应首部发送的，
而且该字符串可以通过 JavaScript 的 navigator.userAgent 属性访问。在服务器端，通过检测用户代
理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法。而在客户端，用户代理检测一般被
当作一种万不得已才用的做法，其优先级排在能力检测和（或）怪癖检测之后。

### 用户代理字符串的历史
### 用户代理字符串检测技术
### 完整的代码
```javascript
var client = function(){
//呈现引擎
var engine = {
ie: 0,
gecko: 0,
webkit: 0,
khtml: 0,
opera: 0,
//完整的版本号
ver: null
};
//浏览器
var browser = {
//主要浏览器
ie: 0,
firefox: 0,
safari: 0,
konq: 0,
opera: 0,
chrome: 0,
//具体的版本号
ver: null
};
//平台、设备和操作系统
var system = {
win: false,
mac: false,
x11: false,
//移动设备
iphone: false,
ipod: false,
ipad: false,
ios: false,
android: false,
nokiaN: false,
winMobile: false,
//游戏系统
wii: false,
ps: false
};
//检测呈现引擎和浏览器
var ua = navigator.userAgent;
if (window.opera){
engine.ver = browser.ver = window.opera.version();
engine.opera = browser.opera = parseFloat(engine.ver);
} else if (/AppleWebKit\/(\S+)/.test(ua)){
engine.ver = RegExp["$1"];
engine.webkit = parseFloat(engine.ver);
//确定是 Chrome 还是 Safari
if (/Chrome\/(\S+)/.test(ua)){
browser.ver = RegExp["$1"];
browser.chrome = parseFloat(browser.ver);
} else if (/Version\/(\S+)/.test(ua)){
browser.ver = RegExp["$1"];
browser.safari = parseFloat(browser.ver);
} else {
//近似地确定版本号
var safariVersion = 1;
if (engine.webkit < 100){
safariVersion = 1;
} else if (engine.webkit < 312){
safariVersion = 1.2;
} else if (engine.webkit < 412){
safariVersion = 1.3;
} else {
safariVersion = 2;
}
browser.safari = browser.ver = safariVersion;
}
} else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)){
engine.ver = browser.ver = RegExp["$1"];
engine.khtml = browser.konq = parseFloat(engine.ver);
} else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)){
engine.ver = RegExp["$1"];
engine.gecko = parseFloat(engine.ver);
//确定是不是 Firefox
if (/Firefox\/(\S+)/.test(ua)){
browser.ver = RegExp["$1"];
browser.firefox = parseFloat(browser.ver);
}
} else if (/MSIE ([^;]+)/.test(ua)){
engine.ver = browser.ver = RegExp["$1"];
engine.ie = browser.ie = parseFloat(engine.ver);
}
//检测浏览器
browser.ie = engine.ie;
browser.opera = engine.opera;
//检测平台
var p = navigator.platform;
system.win = p.indexOf("Win") == 0;
system.mac = p.indexOf("Mac") == 0;
system.x11 = (p == "X11") || (p.indexOf("Linux") == 0);
//检测 Windows 操作系统
if (system.win){
if (/Win(?:dows )?([^do]{2})\s?(\d+\.\d+)?/.test(ua)){
if (RegExp["$1"] == "NT"){
switch(RegExp["$2"]){
case "5.0":
system.win = "2000";
break;
case "5.1":
system.win = "XP";
break;
case "6.0":
system.win = "Vista";
break;
case "6.1":
system.win = "7";
break;
default:
system.win = "NT";
break;
}
} else if (RegExp["$1"] == "9x"){
system.win = "ME";
} else {
system.win = RegExp["$1"];
}
}
}

//移动设备
system.iphone = ua.indexOf("iPhone") > -1;
system.ipod = ua.indexOf("iPod") > -1;
system.ipad = ua.indexOf("iPad") > -1;
system.nokiaN = ua.indexOf("NokiaN") > -1;
//windows mobile
if (system.win == "CE"){
system.winMobile = system.win;
} else if (system.win == "Ph"){
if(/Windows Phone OS (\d+.\d+)/.test(ua)){;
system.win = "Phone";
system.winMobile = parseFloat(RegExp["$1"]);
}
}
//检测 iOS 版本
if (system.mac && ua.indexOf("Mobile") > -1){
if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)){
system.ios = parseFloat(RegExp.$1.replace("_", "."));
} else {
system.ios = 2; //不能真正检测出来，所以只能猜测
}
}
//检测 Android 版本
if (/Android (\d+\.\d+)/.test(ua)){
system.android = parseFloat(RegExp.$1);
}
//游戏系统
system.wii = ua.indexOf("Wii") > -1;
system.ps = /playstation/i.test(ua);
//返回这些对象
return {
engine: engine,
browser: browser,
system: system
};
}();
```
### 使用方法


---
# DOM
DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API（应用程序编程接口）。 DOM 描
绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。 DOM 脱胎于
Netscape 及微软公司创始的 DHTML（动态 HTML），但现在它已经成为表现和操作页面标记的真正的跨
平台、语言中立的方式。

## 节点层次
DOM 可以将任何 HTML 或 XML 文档描绘成一个由多层节点构成的结构。节点分为几种不同的类
型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另
外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点
为根节点的树形结构。

文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即<html>元素，我们
称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文
档只能有一个文档元素。在 HTML 页面中，文档元素始终都是<html>元素。在 XML 中，没有预定义
的元素，因此任何元素都可能成为文档元素。

每一段标记都可以通过树中的一个节点来表示： HTML 元素通过元素节点表示，特性（attribute）
通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点
类型，这些类型都继承自一个基类型。

### Node类型
DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现。这个 Node 接口在
JavaScript 中是作为 Node 类型实现的；除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。
JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。
每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的下列
12 个数值常量来表示，任何节点类型必居其一：
- Node.ELEMENT_NODE(1)；
- Node.ATTRIBUTE_NODE(2)；
- Node.TEXT_NODE(3)；
- Node.CDATA_SECTION_NODE(4)；
- Node.ENTITY_REFERENCE_NODE(5)；
- Node.ENTITY_NODE(6)；
- Node.PROCESSING_INSTRUCTION_NODE(7)；
- Node.COMMENT_NODE(8)；
- Node.DOCUMENT_NODE(9)；
- Node.DOCUMENT_TYPE_NODE(10)；
- Node.DOCUMENT_FRAGMENT_NODE(11)；
- Node.NOTATION_NODE(12)。

1. nodeName 和 nodeValue 属性
要了解节点的具体信息，可以使用 nodeName 和 nodeValue 这两个属性。这两个属性的值完全取
决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。
```javascript
if (someNode.nodeType == 1){
value = someNode.nodeName; //nodeName 的值是元素的标签名
}
```

2. 节点关系
文档中所有的节点之间都存在这样或那样的关系。节点间的各种关系可以用传统的家族关系来描
述，相当于把文档树比喻成家谱。在 HTML 中，可以将<body>元素看成是<html>元素的子元素；相应
地，也就可以将<html>元素看成是<body>元素的父元素。而<head>元素，则可以看成是<body>元素
的同胞元素，因为它们都是同一个父元素<html>的直接子元素。

每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。 NodeList 是一种类数组
对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号语法来
访问 NodeList 的值，而且这个对象也有 length 属性，但它并不是 Array 的实例。 NodeList 对象的
独特之处在于，它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映
在 NodeList 对象中。我们常说， NodeList 是有生命、有呼吸的对象，而不是在我们第一次访问它们
的某个瞬间拍摄下来的一张快照。

每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点。包含在 childNodes 列表中
的所有节点都具有相同的父节点，因此它们的 parentNode 属性都指向同一个节点。此外，包含在
childNodes 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的 previousSibling
和 nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的 previousSibling 属性
值为 null，而列表中最后一个节点的 nextSibling 属性的值同样也为 null。

3. 操作节点
因为关系指针都是只读的，所以 DOM 提供了一些操作节点的方法。其中，最常用的方法是
appendChild()，用于向 childNodes 列表的末尾添加一个节点。添加节点后， childNodes 的新增
节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后， appendChild()
返回新增的节点。

如果传入到 appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置
转移到新位置。即使可以将 DOM 树看成是由一系列指针连接起来的，但任何 DOM 节点也不能同时出
现在文档中的多个位置上。因此，如果在调用 appendChild()时传入了父节点的第一个子节点，那么
该节点就会成为父节点的最后一个子节点。

如果需要把节点放在 childNodes 列表中某个特定的位置上，而不是放在末尾，那么可以使用
insertBefore()方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插
入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。

replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个
方法返回并从文档树中被移除，同时由要插入的节点占据其位置。

如果只想移除而非替换节点，可以使用 removeChild()方法。这个方法接受一个参数，即要移除
的节点。被移除的节点将成为方法的返回值。

4. 其他方法
有两个方法是所有类型的节点都有的。第一个就是 cloneNode()，用于创建调用这个方法的节点
的一个完全相同的副本。 cloneNode()方法接受一个布尔值参数，表示是否执行深复制。在参数为 true
的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为 false 的情况下，执行浅复制，
即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点
副本就成为了一个“孤儿”，除非通过 appendChild()、 insertBefore()或 replaceChild()将它
添加到文档中。

 normalize()，这个方法唯一的作用就是处理文档树中的文本节点。
由于解析器的实现或 DOM 操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点
的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了
空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。

### Document类型
JavaScript 通过 Document 类型表示文档。在浏览器中， document 对象是 HTMLDocument（继承
自 Document 类型）的一个实例，表示整个 HTML 页面。而且， document 对象是 window 对象的一个
属性，因此可以将其作为全局对象来访问。 
- nodeType 的值为 9；
- nodeName 的值为"#document"；
- nodeValue 的值为 null；
- parentNode 的值为 null；
- ownerDocument 的值为 null；
- 其子节点可能是一个 DocumentType（最多一个）、 Element（最多一个）、 ProcessingInstruction
或 Comment。

1. 文档的子节点
虽然 DOM 标准规定 Document 节点的子节点可以是 DocumentType、 Element、 ProcessingInstruction 或 Comment，但还有两个内置的访问其子节点的快捷方式。 第一个就是 documentElement
属性，该属性始终指向 HTML 页面中的<html>元素。另一个就是通过 childNodes 列表访问文档元素，
但通过 documentElement 属性则能更快捷、更直接地访问该元素。
```javascript
var html = document.documentElement; //取得对<html>的引用
```
作为 HTMLDocument 的实例， document 对象还有一个 body 属性，直接指向<body>元素。因为开
发人员经常要使用这个元素，所以 document.body 在 JavaScript 代码中出现的频率非常高，其用法如下。
```
var body = document.body; //取得对<body>的引用
```
Document 另一个可能的子节点是 DocumentType。通常将<!DOCTYPE>标签看成一个与文档其他
部分不同的实体，可以通过 doctype 属性（在浏览器中是 document.doctype）来访问它的信息。
```javascript
var doctype = document.doctype; //取得对<!DOCTYPE>的引用
```

2. 文档信息
作为 HTMLDocument 的一个实例， document 对象还有一些标准的 Document 对象所没有的属性。
这些属性提供了 document 对象所表现的网页的一些信息。其中第一个属性就是 title，包含着
`<title>`元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的
标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改 title 属性的值不会改变`<title>`
元素。

```javascript
//取得文档标题
var originalTitle = document.title;
//设置文档标题
document.title = "New page title";
```
接下来要介绍的 3 个属性都与对网页的请求有关，它们是 URL、 domain 和 referrer。 URL 属性
中包含页面完整的 URL（即地址栏中显示的 URL）， domain 属性中只包含页面的域名，而 referrer
属性中则保存着链接到当前页面的那个页面的 URL。在没有来源页面的情况下， referrer 属性中可能
会包含空字符串。所有这些信息都存在于请求的 HTTP 头部，只不过是通过这些属性让我们能够在
JavaScrip 中访问它们而已。
```javascript
//取得完整的 URL
var url = document.URL;
//取得域名
var domain = document.domain;
//取得来源页面的 URL
var referrer = document.referrer;
```
在这 3 个属性中，只有 domain 是可以设置的。
当页面中包含来自其他子域的框架或内嵌框架时，能够设置 document.domain 就非常方便了。由
于 跨 域 安 全 限 制 ， 来 自 不 同 子 域 的 页 面 无 法 通 过 JavaScript 通 信 。 而 通 过 将 每 个 页 面 的
document.domain 设置为相同的值，这些页面就可以互相访问对方包含的 JavaScript 对象了。

3. 查找元素
取得元素的操作可以使用 document 对象的几个方法来完成。其中， Document 类型为此提供了两个方
法： getElementById()和 getElementsByTagName()。

第一个方法， getElementById()，接收一个参数：要取得的元素的 ID。如果找到相应的元素则
返回该元素，如果不存在带有相应 ID 的元素，则返回 null。注意，这里的 ID 必须与页面中元素的 id
特性（attribute）严格匹配，包括大小写。

另一个常用于取得元素引用的方法是 getElementsByTagName()。这个方法接受一个参数，即要
取得元素的标签名，而返回的是包含零或多个元素的 NodeList。在 HTML 文档中，这个方法会返回一
个 HTMLCollection 对象，作为一个“动态”集合，该对象与 NodeList 非常类似。
```javascript
var images = document.getElementsByTagName("img");
```
这行代码会将一个 HTMLCollection 对象保存在 images 变量中。与 NodeList 对象类似，可以
使用方括号语法或 item()方法来访问 HTMLCollection 对象中的项。而这个对象中元素的数量则可以
通过其 length 属性取得。
```javascript
alert(images.length); //输出图像的数量
alert(images[0].src); //输出第一个图像元素的 src 特性
alert(images.item(0).src); //输出第一个图像元素的 src 特性
```
HTMLCollection 对象还有一个方法，叫做 namedItem()，使用这个方法可以通过元素的 name
特性取得集合中的项。
例如，假设上面提到的页面中包含如下<img>元素：
```html
<img src="myimage.gif" name="myImage">
```
那么就可以通过如下方式从 images 变量中取得这个<img>元素：
```javascript
var myImage = images.namedItem("myImage");
```
在提供按索引访问项的基础上， HTMLCollection 还支持按名称访问项，这就为我们取得实际想要
的元素提供了便利。而且，对命名的项也可以使用方括号语法来访问，如下所示：
```javascript
var myImage = images["myImage"];
```
对 HTMLCollection 而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数
值索引就会调用 item()，而对字符串索引就会调用 namedItem()。
要想取得文档中的所有元素，可以向 getElementsByTagName()中传入"*"。在 JavaScript 及 CSS
中，星号（*）通常表示“全部”。

第三个方法，也是只有 HTMLDocument 类型才有的方法，是 getElementsByName()。顾名思义，
这个方法会返回带有给定 name 特性的所有元素。最常使用 getElementsByName()方法的情况是取得
单选按钮；为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的 name 特性。

4. 特殊集合
除了属性和方法， document 对象还有一些特殊的集合。这些集合都是 HTMLCollection 对象，
为访问文档常用的部分提供了快捷方式，包括：
- document.anchors，包含文档中所有带 name 特性的`<a>`元素；
- document.applets，包含文档中所有的`<applet>`元素，因为不再推荐使用`<applet>`元素，
所以这个集合已经不建议使用了；
- document.forms，包含文档中所有的`<form>`元素，与 document.getElementsByTagName("form")
得到的结果相同；
- document.images，包含文档中所有的`<img>`元素，与 document.getElementsByTagName
("img")得到的结果相同；
- document.links，包含文档中所有带 href 特性的`<a>`元素。

5. DOM一致性检测
由于 DOM 分为多个级别，也包含多个部分，因此检测浏览器实现了 DOM 的哪些部分就十分必要
了。 document.implementation 属性就是为此提供相应信息和功能的对象，与浏览器对 DOM 的实现
直接对应。 DOM1 级只为 document.implementation 规定了一个方法，即 hasFeature()。这个方
法接受两个参数：要检测的 DOM 功能的名称及版本号。如果浏览器支持给定名称和版本的功能，则该
方法返回 true。
```javascript
var hasXmlDom = document.implementation.hasFeature("XML", "1.0");
```
下表列出了可以检测的不同的值及版本号。

功能 | 版本号 | 说明
--- | --- | ---
Core | 1.0、 2.0、 3.0 | 基本的DOM，用于描述表现文档的节点树
XML | 1.0、 2.0、 3.0 | Core的XML扩展，添加了对CDATA、处理指令及实体的支持
HTML | 1.0、 2.0 | XML的HTML扩展，添加了对HTML特有元素及实体的支持
Views | 2.0 | 基于某些样式完成文档的格式化
StyleSheets | 2.0 | 将样式表关联到文档
CSS | 2.0 | 对层叠样式表1级的支持
CSS2 | 2.0 | 对层叠样式表2级的支持
Events | 2.0， 3.0 | 常规的DOM事件
UIEvents | 2.0， 3.0 | 用户界面事件
MouseEvents | 2.0， 3.0 | 由鼠标引发的事件（click、 mouseover等）
MutationEvents | 2.0， 3.0 | DOM树变化时引发的事件
HTMLEvents | 2.0 | HTML4.01事件
Range | 2.0 | 用于操作DOM树中某个范围的对象和方法
Traversal | 2.0 | 遍历DOM树的方法
LS | 3.0 | 文件与DOM树之间的同步加载和保存
LS-Async | 3.0 | 文件与DOM树之间的异步加载和保存
Validation | 3.0 | 在确保有效的前提下修改DOM树的方法

6. 文档写入
有一个 document 对象的功能已经存在很多年了，那就是将输出流写入到网页中的能力。这个能力
体现在下列 4 个方法中： write()、 writeln()、 open()和 close()。其中， write()和 writeln()
方法都接受一个字符串参数，即要写入到输出流中的文本。 write()会原样写入，而 writeln()则会
在字符串的末尾添加一个换行符（\n）。在页面被加载的过程中，可以使用这两个方法向页面中动态地
加入内容。

方法 open()和 close()分别用于打开和关闭网页的输出流。如果是在页面加载期间使用 write()
或 writeln()方法，则不需要用到这两个方法。

### Element类型
除了 Document 类型之外， Element 类型就要算是 Web 编程中最常用的类型了。 Element 类型用
于表现 XML 或 HTML 元素，提供了对元素标签名、子节点及特性的访问。 Element 节点具有以下特征：
- nodeType 的值为 1；
- nodeName 的值为元素的标签名；
- nodeValue 的值为 null；
- parentNode 可能是 Document 或 Element；
- 其子节点可能是 Element、 Text、 Comment、 ProcessingInstruction、 CDATASection 或
EntityReference。
要访问元素的标签名，可以使用 nodeName 属性，也可以使用 tagName 属性；这两个属性会返回
相同的值（使用后者主要是为了清晰起见）。

1. HTML元素
所有 HTML 元素都由 HTMLElement 类型表示，不是直接通过这个类型，也是通过它的子类型来表
示。HTMLElement 类型直接继承自 Element 并添加了一些属性。添加的这些属性分别对应于每个 HTML
元素中都存在的下列标准特性。
- id，元素在文档中的唯一标识符。
- title，有关元素的附加说明信息，一般通过工具提示条显示出来。
- lang，元素内容的语言代码，很少使用。
- dir，语言的方向，值为"ltr"（left-to-right，从左至右）或"rtl"（right-to-left，从右至左），
也很少使用。
- className，与元素的 class 特性对应，即为元素指定的 CSS 类。没有将这个属性命名为 class，
是因为 class 是 ECMAScript 的保留字。

元素 | 类型 | 元素 | 类型
--- | --- | --- | ---
A | HTMLAnchorElement | EM | HTMLElement
ABBR | HTMLElement | FIELDSET | HTMLFieldSetElement
ACRONYM | HTMLElement | FONT | HTMLFontElement
ADDRESS | HTMLElement | FORM | HTMLFormElement
APPLET | HTMLAppletElement | FRAME | HTMLFrameElement
AREA | HTMLAreaElement | FRAMESET | HTMLFrameSetElement
B | HTMLElement | H1 | HTMLHeadingElement
BASE | HTMLBaseElement | H2 | HTMLHeadingElement
BASEFONT | HTMLBaseFontElement | H3 | HTMLHeadingElement
BDO | HTMLElement | H4 | HTMLHeadingElement
BIG | HTMLElement | H5 | HTMLHeadingElement
BLOCKQUOTE | HTMLQuoteElement | H6 | HTMLHeadingElement
BODY | HTMLBodyElement | HEAD | HTMLHeadElement
BR | HTMLBRElement | HR | HTMLHRElement
BUTTON | HTMLButtonElement | HTML | HTMLHtmlElement
CAPTION | HTMLTableCaptionElement | I | HTMLElement
CENTER | HTMLElement | IFRAME | HTMLIFrameElement
CITE | HTMLElement | IMG | HTMLImageElement
CODE | HTMLElement | INPUT | HTMLInputElement
COL | HTMLTableColElement | INS | HTMLModElement
COLGROUP | HTMLTableColElement | ISINDEX | HTMLIsIndexElement
DD | HTMLElement | KBD | HTMLElement
DEL | HTMLModElement | LABEL | HTMLLabelElement
DFN | HTMLElement | LEGEND | HTMLLegendElement
DIR | HTMLDirectoryElement | LI | HTMLLIElement
DIV | HTMLDivElement | LINK | HTMLLinkElement
DL | HTMLDListElement | MAP | HTMLMapElement
DT | HTMLElement | MENU | HTMLMenuElement
META | HTMLMetaElement | STRONG | HTMLElement
NOFRAMES | HTMLElement | STYLE | HTMLStyleElement
NOSCRIPT | HTMLElement | SUB | HTMLElement
OBJECT | HTMLObjectElement | SUP | HTMLElement
OL | HTMLOListElement | TABLE | HTMLTableElement
OPTGROUP | HTMLOptGroupElement | TBODY | HTMLTableSectionElement
OPTION | HTMLOptionElement | TD | HTMLTableCellElement
P | HTMLParagraphElement | TEXTAREA | HTMLTextAreaElement
PARAM | HTMLParamElement | TFOOT | HTMLTableSectionElement
PRE | HTMLPreElement | TH | HTMLTableCellElement
Q | HTMLQuoteElement | THEAD | HTMLTableSectionElement
S | HTMLElement | TITLE | HTMLTitleElement
SAMP | HTMLElement | TR | HTMLTableRowElement
SCRIPT | HTMLScriptElement | TT | HTMLElement
SELECT | HTMLSelectElement | U | HTMLElement
SMALL | HTMLElement | UL | HTMLUListElement
SPAN | HTMLElement | VAR | HTMLElement
STRIKE | HTMLElement

2. 取得特性
每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息。操作特性的
DOM 方法主要有三个，分别是 getAttribute()、 setAttribute()和 removeAttribute()。这三
个方法可以针对任何特性使用，包括那些以 HTMLElement 类型属性的形式定义的特性。

有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过 getAttribute()返回的值并不
相同。第一类特性就是 style，用于通过 CSS 为元素指定样式。在通过 getAttribute()访问时，返
回的 style 特性值中包含的是 CSS 文本，而通过属性来访问它则会返回一个对象。由于 style 属性是
用于以编程方式访问元素样式的（本章后面讨论），因此并没有直接映射到 style 特性。
第二类与众不同的特性是 onclick 这样的事件处理程序。当在元素上使用时， onclick 特性中包
含的是 JavaScript 代码，如果通过 getAttribute()访问，则会返回相应代码的字符串。而在访问
onclick 属性时，则会返回一个 JavaScript 函数（如果未在元素中指定相应特性，则返回 null）。这是
因为 onclick 及其他事件处理程序属性本身就应该被赋予函数值。

3. 设置特性
与 getAttribute()对应的方法是 setAttribute()，这个方法接受两个参数：要设置的特性名和
值。如果特性已经存在，setAttribute()会以指定的值替换现有的值；如果特性不存在，setAttribute()
则创建该属性并设置相应的值。

removeAttribute()，这个方法用于彻底删除元素的特性。调用这个方
法不仅会清除特性的值，而且也会从元素中完全删除特性，

4. attribute属性
Element 类型是使用 attributes 属性的唯一一个 DOM 节点类型。attributes 属性中包含一个
NamedNodeMap，与 NodeList 类似，也是一个“动态”的集合。元素的每一个特性都由一个 Attr 节
点表示，每个节点都保存在 NamedNodeMap 对象中。
- getNamedItem(name)：返回 nodeName 属性等于 name 的节点；
- removeNamedItem(name)：从列表中移除 nodeName 属性等于 name 的节点；
- setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引；
- item(pos)：返回位于数字 pos 位置处的节点

5. 创建元素
使用 document.createElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元
素的标签名。这个标签名在 HTML 文档中不区分大小写，而在 XML（包括 XHTML）文档中，则是区
分大小写的。

6. 元素的子节点
元 素 可 以 有 任 意 数 目 的 子 节 点 和 后 代 节 点 ， 因 为 元 素 可 以 是 其 他 元 素 的 子 节 点 。 元 素 的
childNodes 属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点、注释或处理指令。


### Text类型
文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的
HTML 字符，但不能包含 HTML 代码。 Text 节点具有以下特征：
- nodeType 的值为 3；
- nodeName 的值为"#text"；
- nodeValue 的值为节点所包含的文本；
- parentNode 是一个 Element；
- 不支持（没有）子节点。

可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本，这两个属性中包含的值相
同。对 nodeValue 的修改也会通过 data 反映出来，反之亦然。使用下列方法可以操作节点中的文本。
- appendData(text)：将 text 添加到节点的末尾。
- deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。
- insertData(offset, text)：在 offset 指定的位置插入 text。
- replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset+
count 为止处的文本。
- splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。
- substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止
处的字符串。

1. 创建文本节点
可以使用 document.createTextNode()创建新文本节点，这个方法接受一个参数——要插入节点
中的文本。与设置已有文本节点的值一样，作为参数的文本也将按照 HTML 或 XML 的格式进行编码。

2. 规范化文本节点
DOM 文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。
另外， DOM 文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并
的方法。这个方法是由 Node 类型定义的（因而在所有节点类型中都存在），名叫 normalize()。如果
在一个包含两个或多个文本节点的父元素上调用 normalize()方法，则会将所有文本节点合并成一个
节点，结果节点的 nodeValue 等于将合并前每个文本节点的 nodeValue 值拼接起来的值。

3. 分隔文本节点
Text 类型提供了一个作用与 normalize()相反的方法： splitText()。这个方法会将一个文本节
点分成两个文本节点，即按照指定的位置分割 nodeValue 值。原来的文本节点将包含从开始到指定位
置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的
parentNode 相同。

### Comment类型
注释在 DOM 中是通过 Comment 类型来表示的。 Comment 节点具有下列特征：
- nodeType 的值为 8；
- nodeName 的值为"#comment"；
- nodeValue 的值是注释的内容；
- parentNode 可能是 Document 或 Element；
- 不支持（没有）子节点。

### CDATASection类型
CDATASection 类型只针对基于 XML 的文档，表示的是 CDATA 区域。与 Comment 类似，
CDATASection 类型继承自 Text 类型，因此拥有除 splitText()之外的所有字符串操作方法。
CDATASection 节点具有下列特征：
- nodeType 的值为 4；
- nodeName 的值为"#cdata-section"；
- nodeValue 的值是 CDATA 区域中的内容；
- parentNode 可能是 Document 或 Element；
- 不支持（没有）子节点。

### DocumentType类型
DocumentType 类型在 Web 浏览器中并不常用，仅有 Firefox、 Safari 和 Opera 支持它。
Document-Type 包含着与文档的 doctype 有关的所有信息，它具有下列特征：
- nodeType 的值为 10；
- nodeName 的值为 doctype 的名称；
- nodeValue 的值为 null；
- parentNode 是 Document；
- 不支持（没有）子节点。

在 DOM1 级中， DocumentType 对象不能动态创建，而只能通过解析文档代码的方式来创建。支
持 它 的 浏 览 器 会 把 DocumentType 对 象 保 存 在 document.doctype 中 。 DOM1 级 描 述 了
DocumentType 对象的 3 个属性： name、 entities 和 notations。其中， name 表示文档类型的名称；
entities 是由文档类型描述的实体的 NamedNodeMap 对象； notations 是由文档类型描述的符号的
NamedNodeMap 对象。

### DocumentFragment类型
在所有节点类型中，只有 DocumentFragment 在文档中没有对应的标记。 DOM 规定文档片段
（document fragment）是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用
额外的资源。 DocumentFragment 节点具有下列特征：
- nodeType 的值为 11；
- nodeName 的值为"#document-fragment"；
- nodeValue 的值为 null；
- parentNode 的值为 null；
- 子节点可以是 Element、 ProcessingInstruction、 Comment、 Text、 CDATASection 或
EntityReference。
虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将
来可能会添加到文档中的节点。要创建文档片段，可以使用 document.createDocumentFragment()方
法。
### Attr类型
元素的特性在 DOM 中以 Attr 类型来表示。在所有浏览器中（包括 IE8），都可以访问 Attr 类型
的构造函数和原型。从技术角度讲，特性就是存在于元素的 attributes 属性中的节点。特性节点具有
下列特征：
- nodeType 的值为 2；
- nodeName 的值是特性的名称；
- nodeValue 的值是特性的值；
- parentNode 的值为 null；
- 在 HTML 中不支持（没有）子节点；
- 在 XML 中子节点可以是 Text 或 EntityReference。

Attr 对象有 3 个属性： name、 value 和 specified。其中， name 是特性名称（与 nodeName 的
值相同）， value 是特性的值（与 nodeValue 的值相同），而 specified 是一个布尔值，用以区别特
性是在代码中指定的，还是默认的。

## DOM操作技术
### 动态脚本
使用<script>元素可以向页面中插入 JavaScript 代码，一种方式是通过其 src 特性包含外部文件，
另一种方式就是用这个元素本身来包含代码。而这一节要讨论的动态脚本，指的是在页面加载时不存在，
但将来的某一时刻通过修改 DOM 动态添加的脚本。跟操作 HTML 元素一样，创建动态脚本也有两种方
式：插入外部文件和直接插入 JavaScript 代码。
```javascript
function loadScript(url){
var script = document.createElement("script");
script.type = "text/javascript";
script.src = url;
document.body.appendChild(script);
}
```
### 动态样式
能够把 CSS 样式包含到 HTML 页面中的元素有两个。其中， <link>元素用于包含来自外部的文件，
而<style>元素用于指定嵌入的样式。与动态脚本类似，所谓动态样式是指在页面刚加载时不存在的样
式；动态样式是在页面加载完成后动态添加到页面中的。
```javascript
function loadStyles(url){
var link = document.createElement("link");
link.rel = "stylesheet";
link.type = "text/css";
link.href = url;
var head = document.getElementsByTagName("head")[0];
head.appendChild(link);
}
```

### 操作表格
<table>元素是 HTML 中最复杂的结构之一。要想创建表格，一般都必须涉及表示表格行、 单元格、
表头等方面的标签。由于涉及的标签多，因而使用核心 DOM 方法创建和修改表格往往都免不了要编写
大量的代码。假设我们要使用 DOM 来创建下面的 HTML 表格。

显然， DOM 代码很长，还有点不太好懂。为了方便构建表格， HTML DOM 还为<table>、 <tbody>
和<tr>元素添加了一些属性和方法。

为<table>元素添加的属性和方法如下。
- caption：保存着对<caption>元素（如果有）的指针。
- tBodies：是一个<tbody>元素的 HTMLCollection。
- tFoot：保存着对<tfoot>元素（如果有）的指针。
- tHead：保存着对<thead>元素（如果有）的指针。
- rows：是一个表格中所有行的 HTMLCollection。
- createTHead()：创建<thead>元素，将其放到表格中，返回引用。
- createTFoot()：创建<tfoot>元素，将其放到表格中，返回引用。
- createCaption()：创建<caption>元素，将其放到表格中，返回引用。
- deleteTHead()：删除<thead>元素。
- deleteTFoot()：删除<tfoot>元素。
- deleteCaption()：删除<caption>元素。
- deleteRow(pos)：删除指定位置的行。
- insertRow(pos)：向 rows 集合中的指定位置插入一行。

为<tbody>元素添加的属性和方法如下。
- rows：保存着<tbody>元素中行的 HTMLCollection。
- deleteRow(pos)：删除指定位置的行。
- insertRow(pos)：向 rows 集合中的指定位置插入一行，返回对新插入行的引用。

为<tr>元素添加的属性和方法如下。
- cells：保存着<tr>元素中单元格的 HTMLCollection。
- deleteCell(pos)：删除指定位置的单元格。
- insertCell(pos)：向 cells 集合中的指定位置插入一个单元格，返回对新插入单元格的引用。
使用这些属性和方法，可以极大地减少创建表格所需的代码数量。例如，使用这些属性和方法可以
将前面的代码重写如下（加阴影的部分是重写后的代码）。

### 使用NodeList
理解 NodeList 及其“近亲” NamedNodeMap 和 HTMLCollection，是从整体上透彻理解 DOM 的
关键所在。这三个集合都是“动态的”；换句话说，每当文档结构发生变化时，它们都会得到更新。因
此，它们始终都会保存着最新、最准确的信息。从本质上说，所有 NodeList 对象都是在访问 DOM 文
档时实时运行的查询。

---
# DOM扩展
## 选择符API
众多 JavaScript 库中最常用的一项功能，就是根据 CSS 选择符选择与某个模式匹配的 DOM 元素。
实际上， jQuery（www.jquery.com）的核心就是通过 CSS 选择符查询 DOM 文档取得元素的引用，从而
抛开了 getElementById()和 getElementsByTagName()。
Selectors API（www.w3.org/TR/selectors-api/）是由 W3C 发起制定的一个标准，致力于让浏览器原
生支持 CSS 查询。所有实现这一功能的 JavaScript 库都会写一个基础的 CSS 解析器，然后再使用已有的
DOM 方法查询文档并找到匹配的节点。尽管库开发人员在不知疲倦地改进这一过程的性能，但到头来
都只能通过运行 JavaScript 代码来完成查询操作。而把这个功能变成原生 API 之后，解析和树查询操作
可以在浏览器内部通过编译后的代码来完成，极大地改善了性能。
Selectors API Level 1 的核心是两个方法： querySelector()和 querySelectorAll()。

### querySelector()方法
querySelector()方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹
配的元素，返回 null。

### querySelectorAll()方法
querySelectorAll()方法接收的参数与 querySelector()方法一样，都是一个 CSS 选择符，但
返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个 NodeList 的实例。

### matchesSelector()方法
Selectors API Level 2 规范为 Element 类型新增了一个方法 matchesSelector()。这个方法接收
一个参数，即 CSS 选择符，如果调用元素与该选择符匹配，返回 true；否则，返回 false。

## 元素遍历
对于元素间的空格， IE9 及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，
就导致了在使用 childNodes 和 firstChild 等属性时的行为不一致。为了弥补这一差异，而同时又保
持 DOM 规范不变， Element Traversal 规范（www.w3.org/TR/ElementTraversal/）新定义了一组属性。
Element Traversal API 为 DOM 元素添加了以下 5 个属性。
- childElementCount：返回子元素（不包括文本节点和注释）的个数。
- firstElementChild：指向第一个子元素； firstChild 的元素版。
- lastElementChild：指向最后一个子元素； lastChild 的元素版。
- previousElementSibling：指向前一个同辈元素； previousSibling 的元素版。
- nextElementSibling：指向后一个同辈元素； nextSibling 的元素版。

## HTML5
### 与类相关的扩充
1. getElementsByClassName()方法
HTML5 添加的 getElementsByClassName()方法是最受人欢迎的一个方法，可以通过 document
对象及所有 HTML 元素调用该方法。这个方法最早出现在 JavaScript 库中，是通过既有的 DOM 功能实
现的，而原生的实现具有极大的性能优势。
getElementsByClassName()方法接收一个参数，即一个包含一或多个类名的字符串，返回带有
指定类的所有元素的 NodeList。传入多个类名时，类名的先后顺序不重要。

2. classList 属性
在操作类名时，需要通过 className 属性添加、删除和替换类名。因为 className 中是一个字
符串，所以即使只修改字符串一部分，也必须每次都设置整个字符串的值。

HTML5 新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加
classList 属性。这个 classList 属性是新集合类型 DOMTokenList 的实例。

DOMTokenList 有一个表示自己包含多少元素的 length 属性，而要取得每个元素可以使用 item()方
法，也可以使用方括号语法。此外，这个新类型还定义如下方法。
- add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。
- contains(value)：表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。
- remove(value)：从列表中删除给定的字符串。
- toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。

### 焦点管理
HTML5 也添加了辅助管理 DOM 焦点的功能。首先就是 document.activeElement 属性，这个
属性始终会引用 DOM 中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是
通过按 Tab 键）和在代码中调用 focus()方法。

默认情况下，文档刚刚加载完成时， document.activeElement 中保存的是 document.body 元
素的引用。文档加载期间， document.activeElement 的值为 null。
另外就是新增了 document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。

### HTMLDocument的变化

1. readyState 属性
IE4 最早为 document 对象引入了 readyState 属性。然后，其他浏览器也都陆续添加这个属性，
最终 HTML5 把这个属性纳入了标准当中。 Document 的 readyState 属性有两个可能的值：
- loading，正在加载文档；
- complete，已经加载完文档。

2. 兼容模式
自从 IE6 开始区分渲染页面的模式是标准的还是混杂的，检测页面的兼容模式就成为浏览器的必要
功能。 IE 为此给 document 添加了一个名为 compatMode 的属性，这个属性就是为了告诉开发人员浏
览器采用了哪种渲染模式。就像下面例子中所展示的那样，在标准模式下， document.compatMode 的
值等于"CSS1Compat"，而在混杂模式下， document.compatMode 的值等于"BackCompat"。

3. head 属性
作为对 document.body 引用文档的<body>元素的补充， HTML5 新增了 document.head 属性，
引用文档的<head>元素。要引用文档的<head>元素，可以结合使用这个属性和另一种后备方法。

### 字符集属性
HTML5 新增了几个与文档字符集有关的属性。其中， charset 属性表示文档中实际使用的字符集，
也可以用来指定新字符集。默认情况下，这个属性的值为"UTF-16"，但可以通过<meta>元素、响应头
部或直接设置 charset 属性修改这个值。

另一个属性是 defaultCharset，表示根据默认浏览器及操作系统的设置，当前文档默认的字符集
应该是什么。如果文档没有使用默认的字符集，那 charset 和 defaultCharset 属性的值可能会不一
样，

### 自定义数据属性
HTML5 规定可以为元素添加非标准的属性，但要添加前缀 data-，目的是为元素提供与渲染无关的
信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以 data-开头即可。
添加了自定义属性之后，可以通过元素的 dataset 属性来访问自定义属性的值。 dataset 属性的
值是 DOMStringMap 的一个实例，也就是一个名值对儿的映射。在这个映射中，每个 data-name 形式
的属性都会有一个对应的属性，只不过属性名没有 data-前缀（比如，自定义属性是 data-myname，
那映射中对应的属性就是 myname）

### 插入标记
1. innerHTML 属性
在读模式下， innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应
的 HTML 标记。在写模式下， innerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DOM 树完全
替换调用元素原先的所有子节点。

2. outerHTML 属性
在读模式下， outerHTML 返回调用它的元素及所有子节点的 HTML 标签。在写模式下， outerHTML
会根据指定的 HTML 字符串创建新的 DOM 子树，然后用这个 DOM 子树完全替换调用元素。

3. insertAdjacentHTML()方法
插入标记的最后一个新增方式是 insertAdjacentHTML()方法。这个方法最早也是在 IE中出现的，
它接收两个参数：插入位置和要插入的 HTML 文本。第一个参数必须是下列值之一：
- "beforebegin"，在当前元素之前插入一个紧邻的同辈元素；
- "afterbegin"，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；
- "beforeend"，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；
- "afterend"，在当前元素之后插入一个紧邻的同辈元素。

注意，这些值都必须是小写形式。第二个参数是一个 HTML 字符串（与 innerHTML 和 outerHTML
的值相同），如果浏览器无法解析该字符串，就会抛出错误

4. 内存与性能问题

### scrollIntoView()方法
如何滚动页面也是 DOM 规范没有解决的一个问题。为了解决这个问题，浏览器实现了一些方法，
以方便开发人员更好地控制页面滚动。在各种专有方法中， HTML5 最终选择了 scrollIntoView()作
为标准方法。
scrollIntoView()可以在所有 HTML 元素上调用，通过滚动浏览器窗口或某个容器元素，调用
元素就可以出现在视口中。如果给这个方法传入 true 作为参数，或者不传入任何参数，那么窗口滚动
之后会让调用元素的顶部与视口顶部尽可能平齐。如果传入 false 作为参数，调用元素会尽可能全部
出现在视口中，（可能的话，调用元素的底部会与视口顶部平齐。）不过顶部不一定平齐，


## 专有扩展
### 文档模式
E8 引入了一个新的概念叫“文档模式”（document mode）。页面的文档模式决定了可以使用什么功
能。换句话说，文档模式决定了你可以使用哪个级别的 CSS，可以在 JavaScript 中使用哪些 API，以及
如何对待文档类型（doctype）。到了 IE9，总共有以下 4 种文档模式。
- IE5：以混杂模式渲染页面（IE5 的默认模式就是混杂模式）。 IE8 及更高版本中的新功能都无法
使用。
- IE7：以 IE7 标准模式渲染页面。 IE8 及更高版本中的新功能都无法使用。
- IE8：以 IE8 标准模式渲染页面。 IE8 中的新功能都可以使用，因此可以使用 Selectors API、更多
CSS2 级选择符和某些 CSS3 功能，还有一些 HTML5 的功能。不过 IE9 中的新功能无法使用。
- IE9：以 IE9 标准模式渲染页面。 IE9 中的新功能都可以使用，比如 ECMAScript 5、完整的 CSS3
以及更多 HTML5 功能。这个文档模式是最高级的模式。

### children属性
由于 IE9 之前的版本与其他浏览器在处理文本节点中的空白符时有差异，因此就出现了 children
属性。这个属性是 HTMLCollection 的实例，只包含元素中同样还是元素的子节点。除此之外，
children 属性与 childNodes 没有什么区别，即在元素只包含元素子节点时，这两个属性的值相同。

### contains()方法
在实际开发中，经常需要知道某个节点是不是另一个节点的后代。 IE 为此率先引入了 contains()
方法，以便不通过在 DOM 文档树中查找即可获得这个信息。调用 contains()方法的应该是祖先节点，
也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，
该方法返回 true；否则，返回 false。

### 插入文本
1. innerText 属性
通过 innertText 属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。在通过
innerText 读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。在通过
innerText 写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点。

2. outerText 属性
除了作用范围扩大到了包含调用它的节点之外， outerText 与 innerText 基本上没有多大区别。
在读取文本值时， outerText 与 innerText 的结果完全一样。但在写模式下， outerText 就完全不
同了： outerText 不只是替换调用它的元素的子节点，而是会替换整个元素（包括子节点）。

### 滚动
如前所述， HTML5 之前的规范并没有就与页面滚动相关的 API 做出任何规定。但 HTML5 在将
scrollIntoView()纳入规范之后，仍然还有其他几个专有方法可以在不同的浏览器中使用。下面列出
的几个方法都是对 HTMLElement 类型的扩展，因此在所有元素中都可以调用。
- scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚
动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。
如果将可选的 alignCenter 参数设置为 true，则表示尽量将元素显示在视口中部（垂直方向）。
Safari 和 Chrome 实现了这个方法。
- scrollByLines(lineCount)：将元素的内容滚动指定的行高， lineCount 值可以是正值，
也可以是负值。 Safari 和 Chrome 实现了这个方法。
- scrollByPages(pageCount)：将元素的内容滚动指定的页面高度，具体高度由元素的高度决
定。 Safari 和 Chrome 实现了这个方法。
希望大家要注意的是， scrollIntoView()和 scrollIntoViewIfNeeded()的作用对象是元素的
容器，而 scrollByLines()和 scrollByPages()影响的则是元素自身。


---
# DOM2和DOM3
DOM1 级主要定义的是 HTML 和 XML 文档的底层结构。 DOM2 和 DOM3 级则在这个结构
的基础上引入了更多的交互能力，也支持了更高级的 XML 特性。为此， DOM2 和 DOM3
级分为许多模块（模块之间具有某种关联），分别描述了 DOM 的某个非常具体的子集。这些模块
如下。
- DOM2 级核心（DOM Level 2 Core）：在 1 级核心基础上构建，为节点添加了更多方法和属性。
- DOM2 级视图（DOM Level 2 Views）：为文档定义了基于样式信息的不同视图。
- DOM2 级事件（DOM Level 2 Events）：说明了如何使用事件与 DOM 文档交互。
- DOM2 级样式（DOM Level 2 Style）：定义了如何以编程方式来访问和改变 CSS 样式信息。
- DOM2 级遍历和范围（DOM Level 2 Traversal and Range）：引入了遍历 DOM 文档和选择其特定
部分的新接口。
- DOM2 级 HTML（DOM Level 2 HTML）：在 1 级 HTML 基础上构建，添加了更多属性、方法和
新接口。

## DOM变化
DOM2 级和 3 级的目的在于扩展 DOM API，以满足操作 XML 的所有需求，同时提供更好的错误处
理及特性检测能力。从某种意义上讲，实现这一目的很大程度意味着对命名空间的支持。“DOM2 级核
心”没有引入新类型，它只是在 DOM1 级的基础上通过增加新方法和新属性来增强了既有类型。“DOM3
级核心”同样增强了既有类型，但也引入了一些新类型。
类似地，“DOM2 级视图”和“DOM2 级 HTML”模块也增强了 DOM 接口，提供了新的属性和方
法。由于这两个模块很小，因此我们将把它们与“DOM2 级核心”放在一起，讨论基本 JavaScript 对象
的变化。可以通过下列代码来确定浏览器是否支持这些 DOM 模块。
```javascript
var supportsDOM2Core = document.implementation.hasFeature("Core", "2.0");
var supportsDOM3Core = document.implementation.hasFeature("Core", "3.0");
var supportsDOM2HTML = document.implementation.hasFeature("HTML", "2.0");
var supportsDOM2Views = document.implementation.hasFeature("Views", "2.0");
var supportsDOM2XML = document.implementation.hasFeature("XML", "2.0");
```

### 针对XML命名空间的变化
有了 XML 命名空间，不同 XML 文档的元素就可以混合在一起，共同构成格式良好的文档，而不
必担心发生命名冲突。从技术上说， HTML 不支持 XML 命名空间，但 XHTML 支持 XML 命名空间。

命名空间要使用 xmlns 特性来指定。 XHTML 的命名空间是 http://www.w3.org/1999/xhtml，在任何
格式良好 XHTML 页面中，都应该将其包含在<html>元素中。

1. Node类型的变化
在 DOM2 级中， Node 类型包含下列特定于命名空间的属性。
- localName：不带命名空间前缀的节点名称。
- namespaceURI：命名空间 URI 或者（在未指定的情况下是） null。
- prefix：命名空间前缀或者（在未指定的情况下是） null。

2. Document类型的变化
DOM2 级中的 Document 类型也发生了变化，包含了下列与命名空间有关的方法。
- createElementNS(namespaceURI, tagName)：使用给定的 tagName 创建一个属于命名空
间 namespaceURI 的新元素。
- createAttributeNS(namespaceURI, attributeName)：使用给定的 attributeName 创
建一个属于命名空间 namespaceURI 的新特性。
- getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间 namespaceURI
的 tagName 元素的 NodeList。

3. Element类型的变化
“DOM2 级核心”中有关 Element 的变化，主要涉及操作特性。新增的方法如下。
- getAttributeNS(namespaceURI,localName)：取得属于命名空间 namespaceURI 且名为
localName 的特性。
- getAttributeNodeNS(namespaceURI,localName)：取得属于命名空间 namespaceURI 且
名为 localName 的特性节点。
- getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间 namespaceURI
的 tagName 元素的 NodeList。
- hasAttributeNS(namespaceURI,localName)：确定当前元素是否有一个名为 localName
的特性，而且该特性的命名空间是 namespaceURI。注意，“DOM2 级核心”也增加了一个
hasAttribute()方法，用于不考虑命名空间的情况。
- removeAttriubteNS(namespaceURI,localName)：删除属于命名空间 namespaceURI 且名
为 localName 的特性。
- setAttributeNS(namespaceURI,qualifiedName,value)：设置属于命名空间 namespaceURI 且名为 qualifiedName 的特性的值为 value。
- setAttributeNodeNS(attNode)：设置属于命名空间 namespaceURI 的特性节点。

4. NamedNodeMap类型的变化
NamedNodeMap 类型也新增了下列与命名空间有关的方法。由于特性是通过 NamedNodeMap 表示
的，因此这些方法多数情况下只针对特性使用。
- getNamedItemNS(namespaceURI,localName)：取得属于命名空间 namespaceURI 且名为
localName 的项。
- removeNamedItemNS(namespaceURI,localName)：移除属于命名空间 namespaceURI 且名
为 localName 的项。
- setNamedItemNS(node)：添加 node，这个节点已经事先指定了命名空间信息。

### 其他方面的变化
1. DocumentType类型的变化
DocumentType 类型新增了 3 个属性： publicId、 systemId 和 internalSubset。其中，前两
个属性表示的是文档类型声明中的两个信息段，这两个信息段在 DOM1 级中是没有办法访问到的。

2. Document类型的变化
Document 类型的变化中唯一与命名空间无关的方法是 importNode()。这个方法的用途是从一个
文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分。需要注意的是，
每个节点都有一个 ownerDocument 属性，表示所属的文档。如果调用 appendChild()时传入的节点
属于不同的文档（ownerDocument 属性的值不一样），则会导致错误。但在调用 importNode()时传入
不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。

3. Node类型的变化
Node 类型中唯一与命名空间无关的变化，就是添加了 isSupported()方法。与 DOM1 级为 document.implementation 引入的 hasFeature()方法类似， isSupported()方法用于确定当前节点具有
什么能力。这个方法也接受相同的两个参数：特性名和特性版本号。如果浏览器实现了相应特性，而且
能够基于给定节点执行该特性， isSupported()就返回 true。

4. 框架的变化
框架和内嵌框架分别用 HTMLFrameElement 和 HTMLIFrameElement 表示，它们在 DOM2 级中都有
了一个新属性，名叫 contentDocument。这个属性包含一个指针，指向表示框架内容的文档对象。在此
之前，无法直接通过元素取得这个文档对象（只能使用 frames 集合）。

## 样式
在 HTML 中定义样式的方式有 3 种：通过<link/>元素包含外部样式表文件、使用<style/>元素
定义嵌入式样式，以及使用 style 特性定义针对特定元素的样式。“DOM2 级样式”模块围绕这 3 种应用
样式的机制提供了一套 API。

### 访问元素的样式
任何支持 style 特性的 HTML 元素在 JavaScript 中都有一个对应的 style 属性。 这个 style 对象
是 CSSStyleDeclaration 的实例，包含着通过 HTML 的 style 特性指定的所有样式信息，但不包含
与外部样式表或嵌入样式表经层叠而来的样式。在 style 特性中指定的任何 CSS 属性都将表现为这个
style 对象的相应属性。对于使用短划线（分隔不同的词汇，例如 background-image）的 CSS 属性
名，必须将其转换成驼峰大小写形式，才能通过 JavaScript 来访问。

CSS属性 | JavaScript属性
--- | ---
background-image | style.backgroundImage
color | style.color
display | style.display
font-family | style.fontFamily

1. DOM样式属性和方法
“DOM2 级样式”规范还为 style 对象定义了一些属性和方法。这些属性和方法在提供元素的 style
特性值的同时，也可以修改样式。下面列出了这些属性和方法。
- cssText：如前所述，通过它能够访问到 style 特性中的 CSS 代码。
- length：应用给元素的 CSS 属性的数量。
- parentRule：表示 CSS 信息的 CSSRule 对象。本节后面将讨论 CSSRule 类型。
- getPropertyCSSValue(propertyName)：返回包含给定属性值的 CSSValue 对象。
- getPropertyPriority(propertyName)：如果给定的属性使用了!important 设置，则返回
"important"；否则，返回空字符串。
- getPropertyValue(propertyName)：返回给定属性的字符串值。
- item(index)：返回给定位置的 CSS 属性的名称。
- removeProperty(propertyName)：从样式中删除给定属性。
- setProperty(propertyName,value,priority)：将给定属性设置为相应的值，并加上优先
权标志（"important"或者一个空字符串）。

2. 计算的样式
虽然 style 对象能够提供支持 style 特性的任何元素的样式信息，但它不包含那些从其他样式表
层叠而来并影响到当前元素的样式信息。“DOM2 级样式”增强了 document.defaultView，提供了
getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例
如":after"）。如果不需要伪元素信息，第二个参数可以是 null。 getComputedStyle()方法返回一
个 CSSStyleDeclaration 对象（与 style 属性的类型相同），其中包含当前元素的所有计算的样式。

### 操作样式表
CSSStyleSheet 类型表示的是样式表，包括通过<link>元素包含的样式表和在<style>元素中定义
的样式表。有读者可能记得，这两个元素本身分别是由 HTMLLinkElement 和 HTMLStyleElement 类型
表示的。但是， CSSStyleSheet 类型相对更加通用一些，它只表示样式表，而不管这些样式表在 HTML
中是如何定义的。
CSSStyleSheet 继承自 StyleSheet，后者可以作为一个基础接口来定义非 CSS 样式表。从
StyleSheet 接口继承而来的属性如下。
- disabled：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为 true 可
以禁用样式表。
- href：如果样式表是通过<link>包含的，则是样式表的 URL；否则，是 null。
- media：当前样式表支持的所有媒体类型的集合。与所有 DOM 集合一样，这个集合也有一个
length 属性和一个 item()方法。也可以使用方括号语法取得集合中特定的项。如果集合是空
列表，表示样式表适用于所有媒体。在 IE 中， media 是一个反映<link>和<style>元素 media
特性值的字符串。
- ownerNode：指向拥有当前样式表的节点的指针，样式表可能是在 HTML 中通过<link>或
<style/>引入的（在 XML 中可能是通过处理指令引入的）。如果当前样式表是其他样式表通过
@import 导入的，则这个属性值为 null。 IE 不支持这个属性。
- parentStyleSheet：在当前样式表是通过@import 导入的情况下，这个属性是一个指向导入
它的样式表的指针。
- title： ownerNode 中 title 属性的值。
- type：表示样式表类型的字符串。对 CSS 样式表而言，这个字符串是"type/css"。
除 了 disabled 属 性 之 外 ， 其 他 属 性都 是 只 读 的 。 在 支 持 以上 所 有 这 些属 性 的 基 础上 ，
CSSStyleSheet 类型还支持下列属性和方法：
- cssRules：样式表中包含的样式规则的集合。 IE 不支持这个属性，但有一个类似的 rules 属性。
- ownerRule：如果样式表是通过@import 导入的，这个属性就是一个指针，指向表示导入的规
则；否则，值为 null。 IE 不支持这个属性。
- deleteRule(index)：删除 cssRules 集合中指定位置的规则。 IE 不支持这个方法，但支持
一个类似的 removeRule()方法。
- insertRule(rule,index)：向 cssRules 集合中指定的位置插入 rule 字符串。 IE 不支持这
个方法，但支持一个类似的 addRule()方法。

1. CSS规则
CSSRule 对象表示样式表中的每一条规则。实际上， CSSRule 是一个供其他多种类型继承的基类
型，其中最常见的就是 CSSStyleRule 类型，表示样式信息（其他规则还有@import、 @font-face、
@page 和@charset，但这些规则很少有必要通过脚本来访问）。 CSSStyleRule 对象包含下列属性。
- cssText：返回整条规则对应的文本。由于浏览器对样式表的内部处理方式不同，返回的文本
可能会与样式表中实际的文本不一样； Safari 始终都会将文本转换成全部小写。 IE 不支持这个
属性。
- parentRule：如果当前规则是导入的规则，这个属性引用的就是导入规则；否则，这个值为
null。 IE 不支持这个属性。
- parentStyleSheet：当前规则所属的样式表。 IE 不支持这个属性。
- selectorText：返回当前规则的选择符文本。由于浏览器对样式表的内部处理方式不同，返回
的文本可能会与样式表中实际的文本不一样（例如， Safari 3 之前的版本始终会将文本转换成全
部小写）。在 Firefox、 Safari、 Chrome 和 IE 中这个属性是只读的。 Opera 允许修改 selectorText。
- style：一个 CSSStyleDeclaration 对象，可以通过它设置和取得规则中特定的样式值。
- type：表示规则类型的常量值。对于样式规则，这个值是 1。 IE 不支持这个属性。
其中三个最常用的属性是 cssText、 selectorText 和 style。 cssText 属性与 style.cssText
属性类似，但并不相同。前者包含选择符文本和围绕样式信息的花括号，后者只包含样式信息（类似于
元素的 style.cssText）。此外， cssText 是只读的，而 style.cssText 也可以被重写。

2. 创建规则
DOM 规定，要向现有样式表中添加新规则，需要使用 insertRule()方法。这个方法接受两个参
数：规则文本和表示在哪里插入规则的索引。

3. 删除规则
从样式表中删除规则的方法是 deleteRule()，这个方法接受一个参数：要删除的规则的位置。

### 元素大小
1. 偏移量
首先要介绍的属性涉及偏移量（offset dimension），包括元素在屏幕上占用的所有可见的空间。元素
的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。通过
下列 4 个属性可以取得元素的偏移量。
- offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）
水平滚动条的高度、上边框高度和下边框高度。
- offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂
直滚动条的宽度、左边框宽度和右边框宽度。
- offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。
- offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。
其中， offsetLeft 和 offsetTop 属性与包含元素有关，包含元素的引用保存在 offsetParent
属性中。 offsetParent 属性不一定与 parentNode 的值相等。

2. 客户区大小
元素的客户区大小（client dimension），指的是元素内容及其内边距所占据的空间大小。有关客户区
大小的属性有两个： clientWidth 和 clientHeight。其中， clientWidth 属性是元素内容区宽度加
上左右内边距宽度； clientHeight 属性是元素内容区高度加上上下内边距高度。

3. 滚动大小
最后要介绍的是滚动大小（scroll dimension），指的是包含滚动内容的元素的大小。有些元素（例如
<html>元素），即使没有执行任何代码也能自动地添加滚动条；但另外一些元素，则需要通过 CSS 的
overflow 属性进行设置才能滚动。以下是 4 个与滚动大小相关的属性。
- scrollHeight：在没有滚动条的情况下，元素内容的总高度。
- scrollWidth：在没有滚动条的情况下，元素内容的总宽度。
- scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。
- scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。

4. 确定元素大小
为每个元素都提供了一个 getBoundingClientRect()方
法。这个方法返回会一个矩形对象，包含 4 个属性： left、 top、 right 和 bottom。

## 遍历
“DOM2 级遍历和范围”模块定义了两个用于辅助完成顺序遍历 DOM 结构的类型： NodeIterator
和 TreeWalker。这两个类型能够基于给定的起点对 DOM 结构执行深度优先（depth-first）的遍历操作。

### NodeIterator
NodeIterator 类型是两者中比较简单的一个，可以使用 document.createNodeIterator()方
法创建它的新实例。这个方法接受下列 4 个参数。
- root：想要作为搜索起点的树中的节点。
- whatToShow：表示要访问哪些节点的数字代码。
- filter：是一个 NodeFilter 对象，或者一个表示应该接受还是拒绝某种特定节点的函数。
- entityReferenceExpansion：布尔值，表示是否要扩展实体引用。这个参数在 HTML 页面
中没有用，因为其中的实体引用不能扩展。

whatToShow 参数是一个位掩码，通过应用一或多个过滤器（filter）来确定要访问哪些节点。这个
参数的值以常量形式在 NodeFilter 类型中定义，如下所示。
- NodeFilter.SHOW_ALL：显示所有类型的节点。
- NodeFilter.SHOW_ELEMENT：显示元素节点。
- NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于 DOM 结构原因，实际上不能使用这个值。
- NodeFilter.SHOW_TEXT：显示文本节点。
- NodeFilter.SHOW_CDATA_SECTION：显示 CDATA 节点。对 HTML 页面没有用。
- NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对 HTML 页面没有用。
- NodeFilter.SHOW_ENTITYE：显示实体节点。对 HTML 页面没有用。
- NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对 HTML 页面没有用。
- NodeFilter.SHOW_COMMENT：显示注释节点。
- NodeFilter.SHOW_DOCUMENT：显示文档节点。
- NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点。
- NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对 HTML 页面没有用。
- NodeFilter.SHOW_NOTATION：显示符号节点。对 HTML 页面没有用。

### TreeWalker
TreeWalker 是 NodeIterator 的一个更高级的版本。除了包括 nextNode()和 previousNode()
在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历 DOM 结构的方法。
- parentNode()：遍历到当前节点的父节点；
- firstChild()：遍历到当前节点的第一个子节点；
- lastChild()：遍历到当前节点的最后一个子节点；
- nextSibling()：遍历到当前节点的下一个同辈节点；
- previousSibling()：遍历到当前节点的上一个同辈节点。

创建 TreeWalker 对象要使用 document.createTreeWalker()方法，这个方法接受的 4 个参数
与 document.createNodeIterator()方法相同：作为遍历起点的根节点、要显示的节点类型、过滤
器和一个表示是否扩展实体引用的布尔值。

## 范围
为了让开发人员更方便地控制页面，“DOM2 级遍历和范围”模块定义了“范围”（range）接口。通
过范围可以选择文档中的一个区域，而不必考虑节点的界限（选择在后台完成，对用户是不可见的）。

### DOM中的范围
DOM2 级在 Document 类型中定义了 createRange()方法。在兼容 DOM 的浏览器中，这个方法
属于 document 对象。使用 hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围。

每个范围由一个 Range 类型的实例表示，这个实例拥有很多属性和方法。下列属性提供了当前范
围在文档中的位置信息。
- startContainer：包含范围起点的节点（即选区中第一个节点的父节点）。
- startOffset：范围在 startContainer 中起点的偏移量。如果 startContainer 是文本节
点、注释节点或 CDATA 节点，那么 startOffset 就是范围起点之前跳过的字符数量。否则，
startOffset 就是范围中第一个子节点的索引。
- endContainer：包含范围终点的节点（即选区中最后一个节点的父节点）。
- endOffset：范围在 endContainer 中终点的偏移量（与 startOffset 遵循相同的取值规则）。
- commonAncestorContainer： startContainer 和 endContainer 共同的祖先节点在文档树
中位置最深的那个。

1. 用DOM范围实现简单选择
要使用范围来选择文档中的一部分，最简的方式就是使用 selectNode()或 selectNodeContents()。
这两个方法都接受一个参数，即一个 DOM 节点，然后使用该节点中的信息来填充范围。

2. 用DOM范围实现复杂选择
要创建复杂的范围就得使用 setStart()和 setEnd()方法。这两个方法都接受两个参数：一个参
照节点和一个偏移量值。对 setStart()来说，参照节点会变成 startContainer，而偏移量值会变成
startOffset。对于 setEnd()来说，参照节点会变成 endContainer，而偏移量值会变成 endOffset。

3. 操作DOM范围中的内容
在创建范围时 ，内部会为这个范围创建一个文档片段，范围所属的全部节点都被添加到了这个文档
片段中。为了创建这个文档片段，范围内容的格式必须正确有效。在前面的例子中，我们创建的选区分
别开始和结束于两个文本节点的内部，因此不能算是格式良好的 DOM 结构，也就无法通过 DOM 来表
示。但是，范围知道自身缺少哪些开标签和闭标签，它能够重新构建有效的 DOM 结构以便我们对其进
行操作。

4. 插入DOM范围中的内容
利用范围，可以删除或复制内容，还可以像前面介绍的那样操作范围中的内容。使用 insertNode()
方法可以向范围选区的开始处插入一个节点。

5. 折叠DOM范围
所谓折叠范围，就是指范围中未选择文档的任何部分。可以用文本框来描述折叠范围的过程。假设
文本框中有一行文本，你用鼠标选择了其中一个完整的单词。然后，你单击鼠标左键，选区消失，而光
标则落在了其中两个字母之间。同样，在折叠范围时，其位置会落在文档中的两个部分之间，可能是范
围选区的开始位置，也可能是结束位置。

6. 比较DOM范围
在有多个范围的情况下，可以使用 compareBoundaryPoints()方法来确定这些范围是否有公共
的边界（起点或终点）。这个方法接受两个参数：表示比较方式的常量值和要比较的范围。表示比较方
式的常量值如下所示。
- Range.START_TO_START(0)：比较第一个范围和第二个范围的起点；
- Range.START_TO_END(1)：比较第一个范围的起点和第二个范围的终点；
- Range.END_TO_END(2)：比较第一个范围和第二个范围的终点；
- Range.END_TO_START(3)：比较第一个范围的终点和第一个范围的起点。
compareBoundaryPoints()方法可能的返回值如下：如果第一个范围中的点位于第二个范围中的
点之前，返回-1；如果两个点相等，返回 0；如果第一个范围中的点位于第二个范围中的点之后，返回
1。

7. 复制DOM范围
可以使用 cloneRange()方法复制范围。这个方法会创建调用它的范围的一个副本。

8. 清理DOM范围
在使用完范围之后，最好是调用 detach()方法，以便从创建范围的文档中分离出该范围。调用
detach()之后，就可以放心地解除对范围的引用，从而让垃圾回收机制回收其内存了。

### IE8及更早版本中的范围

---
# 事件
JavaScript 与 HTML 之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些
 特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代
 码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript 代码）与页
 面的外观（HTML 和 CSS 代码）之间的松散耦合。
 
## 事件流
当浏览器发展到第四代时（IE4 及 Netscape Communicator 4），浏览器开发团队遇到了一个很有意思
的问题：页面的哪一部分会拥有某个特定的事件？要明白这个问题问的是什么，可以想象画在一张纸上
的一组同心圆。如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆。两家
公司的浏览器开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，他们都认为单击事
件不仅仅发生在按钮上。换句话说，在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整
个页面。
事件流描述的是从页面中接收事件的顺序。但有意思的是， IE 和 Netscape 开发团队居然提出了差
不多是完全相反的事件流的概念。 IE 的事件流是事件冒泡流，而 Netscape Communicator 的事件流是事
件捕获流。

### 事件冒泡
IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深
的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。

### 事件捕获
Netscape Communicator 团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想
是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在
事件到达预定目标之前捕获它。

### DOM事件流
“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首
先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶
段，可以在这个阶段对事件做出响应。

## 事件处理程序
事件就是用户或浏览器自身执行的某种动作。诸如 click、 load 和 mouseover，都是事件的名字。
而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以"on"开头，因此
click 事件的事件处理程序就是 onclick， load 事件的事件处理程序就是 onload。为事件指定处理
程序的方式有好几种。

### HTML事件处理程序
某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的 HTML 特性来指定。这个
特性的值应该是能够执行的 JavaScript 代码。
```html
<input type="button" value="Click Me" onclick="showMessage()" />
```
不过，在 HTML 中指定事件处理程序有两个缺点。首先，存在一个时差问题。因为用户可能会在
HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。

通过 HTML 指定事件处理程序的最后一个缺点是 HTML 与 JavaScript 代码紧密耦合。如果要更换事
件处理程序，就要改动两个地方： HTML 代码和 JavaScript 代码。而这正是许多开发人员摒弃 HTML 事
件处理程序，转而使用 JavaScript 指定事件处理程序的原因所在。

### DOM0级事件处理程序
通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。这
种为事件处理程序赋值的方法是在第四代 Web 浏览器中出现的，而且至今仍然为所有现代浏览器所支
持。原因一是简单，二是具有跨浏览器的优势。要使用 JavaScript 指定事件处理程序，首先必须取得一
个要操作的对象的引用。
```javascript
var btn = document.getElementById("myBtn");
btn.onclick = function(){
alert(this.id); //"myBtn"
};
```
使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在
元素的作用域中运行；换句话说，程序中的 this 引用当前元素。

### DOM2级事件处理程序
“DOM2 级事件” 定义了两个方法，用于处理指定和删除事件处理程序的操作： addEventListener()
和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处
理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获
阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。
```javascript
var btn = document.getElementById("myBtn");
btn.addEventListener("click", function(){
alert(this.id);
}, false);
```
通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除；移
除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过 addEventListener()添加的匿
名函数将无法移除。

### IE事件处理程序
IE 实现了与 DOM 中类似的两个方法： attachEvent()和 detachEvent()。这两个方法接受相同
的两个参数：事件处理程序名称与事件处理程序函数。由于 IE8 及更早版本只支持事件冒泡，所以通过
attachEvent()添加的事件处理程序都会被添加到冒泡阶段。

### 跨浏览器的事件处理程序
为了以跨浏览器的方式处理事件，不少开发人员会使用能够隔离浏览器差异的 JavaScript 库，还有
一些开发人员会自己开发最合适的事件处理的方法。自己编写代码其实也不难，只要恰当地使用能力检
测即可（能力检测在第 9 章介绍过）。要保证处理事件的代码能在大多数浏览器下一致地运行，只需关
注冒泡阶段。

第一个要创建的方法是 addHandler()，它的职责是视情况分别使用 DOM0 级方法、 DOM2 级方
法或 IE 方法来添加事件。这个方法属于一个名叫 EventUtil 的对象，本书将使用这个对象来处理浏览
器间的差异。 addHandler()方法接受 3 个参数：要操作的元素、事件名称和事件处理程序函数。
与 addHandler()对应的方法是 removeHandler()，它也接受相同的参数。这个方法的职责是移
除之前添加的事件处理程序——无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无
效，默认采用 DOM0 级方法。
```javascript
var EventUtil = {
addHandler: function(element, type, handler){
if (element.addEventListener){
element.addEventListener(type, handler, false);
} else if (element.attachEvent){
element.attachEvent("on" + type, handler);
} else {
element["on" + type] = handler;
}
},
removeHandler: function(element, type, handler){
if (element.removeEventListener){
element.removeEventListener(type, handler, false);
} else if (element.detachEvent){
element.detachEvent("on" + type, handler);
} else {
element["on" + type] = null;
}
}
};
```

## 事件对象
在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的
信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。

### DOM中的事件对象
兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中。无论指定事件处理程序时使用什
么方法（DOM0 级或 DOM2 级），都会传入 event 对象。

属性/方法 | 类型 | 读/写 | 说明
--- | --- | --- | ---
bubbles | Boolean  | 只读  |表明事件是否冒泡
cancelable | Boolean | 只读 | 表明是否可以取消事件的默认行为
currentTarget | Element | 只读 |  其事件处理程序当前正在处理事件的那个元素
defaultPrevented | Boolean | 只读 |为true表示已经调用了preventDefault()（DOM3级事件中新增）
detail | Integer | 只读 | 与事件相关的细节信息
eventPhase | Integer | 只读 | 调用事件处理程序的阶段： 1表示捕获阶段， 2表示“处于目标”， 3表示冒泡阶段
preventDefault() | Function | 只读 | 取消事件的默认行为。如果cancelable是true，则可以使用这个方法
stopImmediatePropagation() | Function | 只读 | 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增）
stopPropagation() | Function | 只读 | 取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法
target | Element | 只读 | 事件的目标
trusted | Boolean | 只读 | 为true表示事件是浏览器生成的。为false表示事件是由开发人员通过JavaScript创建的（DOM3级事件中新增）
type | String | 只读 | 被触发的事件的类型
view | AbstractView | 只读 | 与事件关联的抽象视图。等同于发生事件的window对象

在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实
际目标。如果直接将事件处理程序指定给了目标元素，则 this、 currentTarget 和 target 包含相同
的值。

阻止特定事件的默认行为，可以使用 preventDefault()方法。

另外， stopPropagation()方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件
捕获或冒泡。

### IE中的事件对象
与访问 DOM 中的 event 对象不同，要访问 IE 中的 event 对象有几种不同的方式，取决于指定事
件处理程序的方法。在使用 DOM0 级方法添加事件处理程序时， event 对象作为 window 对象的一个
属性存在。
### 跨浏览器的事件对象
虽然 DOM 和 IE 中的 event 对象不同，但基于它们之间的相似性依旧可以拿出跨浏览器的方案来。
IE 中 event 对象的全部信息和方法 DOM 对象中都有，只不过实现方式不一样。不过，这种对应关系
让实现两种事件模型之间的映射非常容易。

## 事件类型
Web 浏览器中可能发生的事件有很多类型。如前所述，不同的事件类型具有不同的信息，而“DOM3
级事件”规定了以下几类事件。
- UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发；
- 焦点事件，当元素获得或失去焦点时触发；
- 鼠标事件，当用户通过鼠标在页面上执行操作时触发；
- 滚轮事件，当使用鼠标滚轮（或类似设备）时触发；
- 文本事件，当在文档中输入文本时触发；
- 键盘事件，当用户通过键盘在页面上执行操作时触发；
- 合成事件，当为 IME（Input Method Editor，输入法编辑器）输入字符时触发；
- 变动（mutation）事件，当底层 DOM 结构发生变化时触发。
- 变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现它们，
因此本章不做介绍。

### UI事件
UI 事件指的是那些不一定与用户操作有关的事件。这些事件在 DOM 规范出现之前，都是以这种或
那种形式存在的，而在 DOM 规范中保留是为了向后兼容。现有的 UI 事件如下。
- DOMActivate：表示元素已经被用户操作（通过鼠标或键盘）激活。这个事件在 DOM3 级事
件中被废弃，但 Firefox 2+和 Chrome 支持它。考虑到不同浏览器实现的差异，不建议使用这个
事件。
- load：当页面完全加载后在 window 上面触发，当所有框架都加载完毕时在框架集上面触发，
当图像加载完毕时在<img>元素上面触发，或者当嵌入的内容加载完毕时在<object>元素上面
触发。
- unload：当页面完全卸载后在 window 上面触发，当所有框架都卸载后在框架集上面触发，或
者当嵌入的内容卸载完毕后在<object>元素上面触发。
- abort：在用户停止下载过程时，如果嵌入的内容没有加载完，则在<object>元素上面触发。
- error：当发生 JavaScript 错误时在 window 上面触发，当无法加载图像时在<img>元素上面触
发，当无法加载嵌入内容时在<object>元素上面触发，或者当有一或多个框架无法加载时在框
架集上面触发。第 17 章将继续讨论这个事件。
- select：当用户选择文本框（<input>或<texterea>）中的一或多个字符时触发。第 14 章将
继续讨论这个事件。
- resize：当窗口或框架的大小变化时在 window 或框架上面触发。
- scroll：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。 <body>元素中包含所加
载页面的滚动条。

1. load事件
JavaScript 中最常用的一个事件就是 load。当页面完全加载后（包括所有图像、 JavaScript 文件、
CSS 文件等外部资源），就会触发 window 上面的 load 事件。有两种定义 onload 事件处理程序的方式。
```javascript
// 第一种方式
EventUtil.addHandler(window, "load", function(event){
alert("Loaded!");
});
```
```HTML
// 第二种方式
<!DOCTYPE html>
<html>
<head>
<title>Load Event Example</title>
</head>
<body onload="alert('Loaded!')">
</body>
</html>
```

2. unload事件
与 load 事件对应的是 unload 事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切
换到另一个页面，就会发生 unload 事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。
与 load 事件类似，也有两种指定 onunload 事件处理程序的方式。

第一种方式是使用 JavaScript。
```javascript
EventUtil.addHandler(window, "unload", function(event){
alert("Unloaded");
});
```
指定事件处理程序的第二种方式，也是为<body>元素添加一个特性（与 load 事件相似）。
```html
<!DOCTYPE html>
<html>
<head>
<title>Unload Event Example</title>
</head>
<body onunload="alert('Unloaded!')">
</body>
</html>
```

3. resize事件
当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件。这个事件在 window（窗
口）上面触发，因此可以通过 JavaScript 或者<body>元素中的 onresize 特性来指定事件处理程序。

4.scroll事件
虽然 scroll 事件是在 window 对象上发生的，但它实际表示的则是页面中相应元素的变化。在混
杂模式下，可以通过<body>元素的 scrollLeft 和 scrollTop 来监控到这一变化；而在标准模式下，
除 Safari 之外的所有浏览器都会通过<html>元素来反映这一变化（Safari 仍然基于<body>跟踪滚动位
置）。

### 焦点事件
焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFocus()方法及
document.activeElement 属性配合，可以知晓用户在页面上的行踪。有以下 6 个焦点事件。
- blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。
- DOMFocusIn：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡。只有
Opera 支持这个事件。 DOM3 级事件废弃了 DOMFocusIn，选择了 focusin。
- DOMFocusOut：在元素失去焦点时触发。这个事件是 HTML 事件 blur 的通用版本。只有 Opera
支持这个事件。 DOM3 级事件废弃了 DOMFocusOut，选择了 focusout。
- focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。
- focusin：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡。支持这个
事件的浏览器有 IE5.5+、 Safari 5.1+、 Opera 11.5+和 Chrome。
- focusout：在元素失去焦点时触发。这个事件是 HTML 事件 blur 的通用版本。支持这个事件
的浏览器有 IE5.5+、 Safari 5.1+、 Opera 11.5+和 Chrome。

这一类事件中最主要的两个是 focus 和 blur，它们都是 JavaScript 早期就得到所有浏览器支持的
事件。这些事件的最大问题是它们不冒泡。因此， IE 的 focusin 和 focusout 与 Opera 的 DOMFocusIn
和 DOMFocusOut 才会发生重叠。 IE 的方式最后被 DOM3 级事件采纳为标准方式。
当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：
(1) focusout 在失去焦点的元素上触发；
(2) focusin 在获得焦点的元素上触发；
(3) blur 在失去焦点的元素上触发；
(4) DOMFocusOut 在失去焦点的元素上触发；
(5) focus 在获得焦点的元素上触发；
(6) DOMFocusIn 在获得焦点的元素上触发。
其中， blur、 DOMFocusOut 和 focusout 的事件目标是失去焦点的元素；而 focus、 DOMFocusIn
和 focusin 的事件目标是获得焦点的元素。

### 鼠标与滚轮事件
鼠标事件是 Web 开发中最常用的一类事件，毕竟鼠标还是最主要的定位设备。 DOM3 级事件中定
义了 9 个鼠标事件，简介如下。
- click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保
易访问性很重要，意味着 onclick 事件处理程序既可以通过键盘也可以通过鼠标执行。
- dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。从技术上说，这个事件并不
是 DOM2 级事件规范中规定的，但鉴于它得到了广泛支持，所以 DOM3 级事件将其纳入了标准。
- mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。
- mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且
在光标移动到后代元素上不会触发。 DOM2 级事件并没有定义这个事件，但 DOM3 级事件将它
纳入了规范。 IE、 Firefox 9+和 Opera 支持这个事件。
- mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且
在光标移动到后代元素上不会触发。 DOM2 级事件并没有定义这个事件，但 DOM3 级事件将它
纳入了规范。 IE、 Firefox 9+和 Opera 支持这个事件。
- mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。
- mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另
一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。
- mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触
发。不能通过键盘触发这个事件。
- mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。

只有在同一个元素上相继触发 mousedown 和 mouseup 事件，才会触发 click 事件；如果
mousedown 或 mouseup 中的一个被取消，就不会触发 click 事件。类似地，只有触发两次 click 事
件，才会触发一次 dblclick 事件。如果有代码阻止了连续两次触发 click 事件（可能是直接取消 click
事件，也可能通过取消 mousedown 或 mouseup 间接实现），那么就不会触发 dblclick 事件了。这 4
个事件触发的顺序始终如下：
(1) mousedown
(2) mouseup
(3) click
(4) mousedown
(5) mouseup
(6) click
(7) dblclick

1. 客户区坐标位置
鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的 clientX 和
clientY 属性中。所有浏览器都支持这两个属性，它们的值表示事件发生时鼠标指针在视口中的水平
和垂直坐标。

2. 页面坐标位置
通过客户区坐标能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的 pageX 和
pageY 属性，能告诉你事件是在页面中的什么位置发生的。换句话说，这两个属性表示鼠标光标在页面
中的位置，因此坐标是从页面本身而非视口的左边和顶边计算的。

3. 屏幕坐标位置
鼠标事件发生时，不仅会有相对于浏览器窗口的位置，还有一个相对于整个电脑屏幕的位置。而通
过 screenX 和 screenY 属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。

4. 修改键
虽然鼠标事件主要是使用鼠标来触发的，但在按下鼠标时键盘上的某些键的状态也可以影响到所要
采取的操作。这些修改键就是 Shift、 Ctrl、 Alt 和 Meta（在 Windows 键盘中是 Windows 键，在苹果机中
是 Cmd 键），它们经常被用来修改鼠标事件的行为。 DOM 为此规定了 4 个属性，表示这些修改键的状
态： shiftKey、 ctrlKey、 altKey 和 metaKey。这些属性中包含的都是布尔值，如果相应的键被按
下了，则值为 true，否则值为 false。当某个鼠标事件发生时，通过检测这几个属性就可以确定用户
是否同时按下了其中的键。

5. 相关元素
在发生 mouseover 和 mouserout 事件时，还会涉及更多的元素。这两个事件都会涉及把鼠标指
针从一个元素的边界之内移动到另一个元素的边界之内。对 mouseover 事件而言，事件的主目标是获
得光标的元素，而相关元素就是那个失去光标的元素。类似地，对 mouseout 事件而言，事件的主目标
是失去光标的元素，而相关元素则是获得光标的元素。

6. 鼠标按钮
只有在主鼠标按钮被单击（或键盘回车键被按下）时才会触发 click 事件，因此检测按钮的信息
并不是必要的。但对于 mousedown 和 mouseup 事件来说，则在其 event 对象存在一个 button 属性，
表示按下或释放的按钮。 DOM 的 button 属性可能有如下 3 个值： 0 表示主鼠标按钮， 1 表示中间的鼠
标按钮（鼠标滚轮按钮）， 2 表示次鼠标按钮。在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标
按钮就是鼠标右键。
IE8 及之前版本也提供了 button 属性，但这个属性的值与 DOM 的 button 属性有很大差异。
- 0：表示没有按下按钮。
- 1：表示按下了主鼠标按钮。
- 2：表示按下了次鼠标按钮。
- 3：表示同时按下了主、次鼠标按钮。
- 4：表示按下了中间的鼠标按钮。
- 5：表示同时按下了主鼠标按钮和中间的鼠标按钮。
- 6：表示同时按下了次鼠标按钮和中间的鼠标按钮。
- 7：表示同时按下了三个鼠标按钮。

7. 更多的事件信息
“DOM2 级事件”规范在 event 对象中还提供了 detail 属性，用于给出有关事件的更多信息。对
于鼠标事件来说， detail 中包含了一个数值，表示在给定位置上发生了多少次单击。在同一个元素上
相继地发生一次 mousedown 和一次 mouseup 事件算作一次单击。 detail 属性从 1 开始计数，每次单
击发生后都会递增。如果鼠标在 mousedown 和 mouseup 之间移动了位置，则 detail 会被重置为 0。
IE 也通过下列属性为鼠标事件提供了更多信息。
- altLeft：布尔值，表示是否按下了 Alt 键。如果 altLeft 的值为 true，则 altKey 的值也为 true。
- ctrlLeft：布尔值，表示是否按下了 Ctrl 键。如果 ctrlLeft 的值为 true，则 ctrlKey 的值
也为 true。
- offsetX：光标相对于目标元素边界的 x 坐标。
- offsetY：光标相对于目标元素边界的 y 坐标。
- shiftLeft：布尔值，表示是否按下了 Shift 键。如果 shiftLeft 的值为 true，则 shiftKey
的值也为 true。

8. 鼠标滚轮事件
IE 6.0 首先实现了 mousewheel 事件。此后， Opera、 Chrome 和 Safari 也都实现了这个事件。当用
户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发 mousewheel
事件。这个事件可以在任何元素上面触发，最终会冒泡到 document（IE8）或 window（IE9、 Opera、
Chrome 及 Safari）对象。与 mousewheel 事件对应的 event 对象除包含鼠标事件的所有标准信息外，
还包含一个特殊的 wheelDelta 属性。当用户向前滚动鼠标滚轮时， wheelDelta 是 120 的倍数；当用
户向后滚动鼠标滚轮时， wheelDelta 是-120 的倍数。

9. 触摸设备
iOS 和 Android 设备的实现非常特别，因为这些设备没有鼠标。在面向 iPhone 和 iPod 中的 Safari
开发时，要记住以下几点。
- 不支持 dblclick 事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。
- 轻击可单击元素会触发 mousemove 事件。如果此操作会导致内容变化，将不再有其他事件发生；
如果屏幕没有因此变化，那么会依次发生 mousedown、 mouseup 和 click 事件。轻击不可单
击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或
者那些已经被指定了 onclick 事件处理程序的元素。
- mousemove 事件也会触发 mouseover 和 mouseout 事件。
- 两个手指放在屏幕上且页面随手指移动而滚动时会触发 mousewheel 和 scroll 事件。

10. 无障碍性问题
如果你的 Web 应用程序或网站要确保残疾人特别是那些使用屏幕阅读器的人都能访问，那么在使
用鼠标事件时就要格外小心。前面提到过，可以通过键盘上的回车键来触发 click 事件，但其他鼠标
事件却无法通过键盘来触发。为此，我们不建议使用 click 之外的其他鼠标事件来展示功能或引发代
码执行。因为这样会给盲人或视障用户造成极大不便。以下是在使用鼠标事件时应当注意的几个易访问
性问题。
- 使用 click 事件执行代码。有人指出通过 onmousedown 执行代码会让人觉得速度更快，对视
力正常的人来说这是没错的。但是，在屏幕阅读器中，由于无法触发 mousedown 事件，结果就
会造成代码无法执行。
- 不要使用 onmouseover 向用户显示新的选项。原因同上，屏幕阅读器无法触发这个事件。如果
确实非要通过这种方式来显示新选项，可以考虑添加显示相同信息的键盘快捷方式。
- 不要使用 dblclick 执行重要的操作。键盘无法触发这个事件。

### 键盘与文本事件
用户在使用键盘时会触发键盘事件。“DOM2 级事件”最初规定了键盘事件，但在最终定稿之前又
删除了相应的内容。结果，对键盘事件的支持主要遵循的是 DOM0 级。
“DOM3 级事件”为键盘事件制定了规范， IE9 率先完全实现了该规范。其他浏览器也在着手实现这
一标准，但仍然有很多遗留的问题。
有 3 个键盘事件，简述如下。
- keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。
- keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。
按下 Esc 键也会触发这个事件。Safari 3.1 之前的版本也会在用户按下非字符键时触发 keypress
事件。
- keyup：当用户释放键盘上的键时触发。

只有一个文本事件： textInput。这个事件是对 keypress 的补充，用意是在将文本显示给用户之
前更容易拦截文本。在文本插入文本框之前会触发 textInput 事件。
在用户按了一下键盘上的字符键时，首先会触发 keydown 事件，然后紧跟着是 keypress 事件，
最后会触发 keyup 事件。 其中， keydown 和 keypress 都是在文本框发生变化之前被触发的；而 keyup
事件则是在文本框已经发生变化之后被触发的。如果用户按下了一个字符键不放，就会重复触发
keydown 和 keypress 事件，直到用户松开该键为止。

1. 键码
在发生 keydown 和 keyup 事件时， event 对象的 keyCode 属性中会包含一个代码，与键盘上一
个特定的键对应。对数字字母字符键， keyCode 属性的值与 ASCII 码中对应小写字母或数字的编码相
同。因此，数字键 7 的 keyCode 值为 55，而字母 A 键的 keyCode 值为 65——与 Shift 键的状态无关。
DOM 和 IE 的 event 对象都支持 keyCode 属性。

键 | 键码 | 键 | 键码
--- | --- | --- | ---
退格（Backspace） |  8 | 数字小键盘1 |  97
制表（Tab） |  9 | 数字小键盘2 |  98
回车（Enter） | 13 | 数字小键盘3 |  99
上档（Shift） |  16 | 数字小键盘4 | 100
控制（Ctrl） |  17 | 数字小键盘5 |  101
Alt |  18 | 数字小键盘6 |  102
暂停/中断（Pause/Break） |  19 | 数字小键盘7 |  103
大写锁定（Caps Lock） | 20 | 数字小键盘8 | 104
退出（Esc） | 27 | 数字小键盘9 | 105
上翻页（Page Up） | 33 | 数字小键盘+ | 107
下翻页（Page Down） | 34 | 数字小键盘及大键盘上的- | 109
结尾（End） | 35 | 数字小键盘 . | 110
开头（Home） | 36 | 数字小键盘 / | 111
左箭头（Left Arrow） | 37 | F1 | 112
上箭头（Up Arrow） | 38 | F2 | 113
右箭头（Right Arrow） | 39 | F3 | 114
下箭头（Down Arrow） | 40 | F4 | 115
插入（Ins） | 45 | F5 | 116
删除（Del） | 46 | F6 | 117
左Windows键 | 91 | F7 | 118
右Windows键 | 92 | F8 | 119
上下文菜单键 | 93 | F9 | 120
数字小键盘0 | 96 | F10 | 12
F11 | 122 | 正斜杠 | 191
F12 | 123 | 沉音符（`） | 192
数字锁（Num Lock） | 144 | 等于 | 61
滚动锁（Scroll Lock） | 145 | 左方括号 | 219
分号（IE/Safari/Chrome中） | 186 | 反斜杠（\） | 220
分号（Opera/FF中） | 59 | 右方括号 | 221
小于 | 188 | 单引号 | 222
大于 | 190

2. 字符编码
发生 keypress 事件意味着按下的键会影响到屏幕中文本的显示。在所有浏览器中，按下能够插入
或删除字符的键都会触发 keypress 事件；按下其他键能否触发此事件因浏览器而异。

3. DOM3级变化
尽管所有浏览器都实现了某种形式的键盘事件， DOM3 级事件还是做出了一些改变。
其中， key 属性是为了取代 keyCode 而新增的，它的值是一个字符串。在按下某个字符键时， key
的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时， key 的值是相应键的名（如“Shift”
或“Down”）。而 char 属性在按下字符键时的行为与 key 相同，但在按下非字符键时值为 null。
由于存在跨浏览器问题，因此本书不推荐使用 key、 keyIdentifier 或 char。

4. textInput事件
DOM3 级事件”规范中引入了一个新事件，名叫 textInput。根据规范，当用户在可编辑区域中
输入字符时，就会触发这个事件。这个用于替代 keypress 的 textInput 事件的行为稍有不同。区别
之一就是任何可以获得焦点的元素都可以触发 keypress 事件，但只有可编辑区域才能触发 textInput
事件。区别之二是 textInput 事件只会在用户按下能够输入实际字符的键时才会被触发，而 keypress
事件则在按下那些能够影响文本显示的键时也会触发（例如退格键）。

另外， event 对象上还有一个属性，叫 inputMethod，表示把文本输入到文本框中的方式。
- 0，表示浏览器不确定是怎么输入的。
- 1，表示是使用键盘输入的。
- 2，表示文本是粘贴进来的。
- 3，表示文本是拖放进来的。
- 4，表示文本是使用 IME 输入的。
- 5，表示文本是通过在表单中选择某一项输入的。
- 6，表示文本是通过手写输入的（比如使用手写笔）。
- 7，表示文本是通过语音输入的。
- 8，表示文本是通过几种方法组合输入的。
- 9，表示文本是通过脚本输入的。

5. 设备中的键盘事件
任天堂 Wii 会在用户按下 Wii 遥控器上的按键时触发键盘事件。尽管没有办法访问 Wii 遥控器中的
所有按键，但还是有一些键可以触发键盘事件。

当用户按下十字键盘（键码为 175～178）、减号（170）、加号（174）、 1（172）或 2（173）键时就
会触发键盘事件。但没有办法得知用户是否按下了电源开关、 A、 B 或主页键。

### 复合事件
复合事件（composition event）是 DOM3 级事件中新添加的一类事件，用于处理 IME 的输入序列。
IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。例如，使用拉
丁文键盘的用户通过 IME 照样能输入日文字符。 IME 通常需要同时按住多个键，但最终只输入一个字
符。复合事件就是针对检测和处理这种输入而设计的。有以下三种复合事件。
- compositionstart：在 IME 的文本复合系统打开时触发，表示要开始输入了
- compositionupdate：在向输入字段中插入新字符时触发。
- compositionend：在 IME 的文本复合系统关闭时触发，表示返回正常键盘输入状态。
复合事件与文本事件在很多方面都很相似。在触发复合事件时，目标是接收文本的输入字段。但它
比文本事件的事件对象多一个属性 data，其中包含以下几个值中的一个：
- 如果在 compositionstart 事件发生时访问，包含正在编辑的文本（例如，已经选中的需要马
上替换的文本）；
- 如果在 compositionupdate 事件发生时访问，包含正插入的新字符；
- 如果在 compositionend 事件发生时访问，包含此次输入会话中插入的所有字符。

### 变动事件
DOM2 级的变动（mutation）事件能在 DOM 中的某一部分发生变化时给出提示。变动事件是为 XML
或 HTML DOM 设计的，并不特定于某种语言。 DOM2 级定义了如下变动事件。
- DOMSubtreeModified：在 DOM 结构中发生任何变化时触发。这个事件在其他任何事件触发
后都会触发。
- DOMNodeInserted：在一个节点作为子节点被插入到另一个节点中时触发。
- DOMNodeRemoved：在节点从其父节点中被移除时触发。
- DOMNodeInsertedIntoDocument：在一个节点被直接插入文档或通过子树间接插入文档之后
触发。这个事件在 DOMNodeInserted 之后触发。
- DOMNodeRemovedFromDocument：在一个节点被直接从文档中移除或通过子树间接从文档中移
除之前触发。这个事件在 DOMNodeRemoved 之后触发。
- DOMAttrModified：在特性被修改之后触发。
- DOMCharacterDataModified：在文本节点的值发生变化时触发。
使用下列代码可以检测出浏览器是否支持变动事件：
```html
var isSupported = document.implementation.hasFeature("MutationEvents", "2.0");
```

1. 删除节点
在使用removeChild()或replaceChild()从 DOM中删除节点时，首先会触发DOMNodeRemoved
事件。这个事件的目标（event.target）是被删除的节点，而 event.relatedNode 属性中包含着对
目标节点父节点的引用。在这个事件触发时，节点尚未从其父节点删除，因此其 parentNode 属性仍然
指向父节点（与 event.relatedNode 相同）。这个事件会冒泡，因而可以在 DOM 的任何层次上面处
理它。
如果被移除的节点包含子节点，那么在其所有子节点以及这个被移除的节点上会相继触发
DOMNodeRemovedFromDocument 事件。但这个事件不会冒泡，所以只有直接指定给其中一个子节点的
事件处理程序才会被调用。这个事件的目标是相应的子节点或者那个被移除的节点，除此之外 event
对象中不包含其他信息。
紧随其后触发的是 DOMSubtreeModified 事件。这个事件的目标是被移除节点的父节点；此时的
event 对象也不会提供与事件相关的其他信息。

2. 插入节点
在使用 appendChild()、 replaceChild()或 insertBefore()向 DOM 中插入节点时，首先会
触发 DOMNodeInserted 事件。这个事件的目标是被插入的节点，而 event.relatedNode 属性中包含
一个对父节点的引用。在这个事件触发时，节点已经被插入到了新的父节点中。这个事件是冒泡的，因
此可以在 DOM 的各个层次上处理它。
紧接着，会在新插入的节点上面触发 DOMNodeInsertedIntoDocument 事件。这个事件不冒泡，
因此必须在插入节点之前为它添加这个事件处理程序。这个事件的目标是被插入的节点，除此之外
event 对象中不包含其他信息。
最后一个触发的事件是 DOMSubtreeModified，触发于新插入节点的父节点。


### HTML5事件
1. contextmenu事件
由于 contextmenu 事件是冒泡的，因此可以为 document 指定一个事件处理程序，用以处理页面
中发生的所有此类事件。这个事件的目标是发生用户操作的元素。在所有浏览器中都可以取消这个事件：
在兼容 DOM 的浏览器中，使用 event.preventDefalut()；在 IE 中，将 event.returnValue 的值
设置为 false。因为 contextmenu 事件属于鼠标事件，所以其事件对象中包含与光标位置有关的所有
属性。通常使用 contextmenu 事件来显示自定义的上下文菜单，而使用 onclick 事件处理程序来隐
藏该菜单。

2. beforeunload事件
之所以有发生在 window 对象上的 beforeunload 事件，是为了让开发人员有可能在页面卸载前
阻止这一操作。这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。
但是，不能彻底取消这个事件，因为那就相当于让用户无法离开当前页面了。为此，这个事件的意图是
将控制权交给用户。显示的消息会告知用户页面行将被卸载（正因为如此才会显示这个消息），询问用
户是否真的要关闭页面，还是希望继续留下来。
为了显示这个弹出对话框，必须将 event.returnValue 的值设置为要显示给用户的字符串（对
IE 及 Fiefox 而言），同时作为函数的值返回（对 Safari 和 Chrome 而言）。

3. DOMContentLoaded事件
window 的 load 事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要
加载的外部资源过多而颇费周折。而 DOMContentLoaded 事件则在形成完整的 DOM 树之后就会触发，
不理会图像、 JavaScript 文件、 CSS 文件或其他资源是否已经下载完毕。与 load 事件不同，
DOMContentLoaded 支持在页面下载的早期添加事件处理程序，这也就意味着用户能够尽早地与页面
进行交互。

要处理 DOMContentLoaded 事件，可以为 document 或 window 添加相应的事件处理程序（尽管
这个事件会冒泡到 window，但它的目标实际上是 document）。

4. readystatechange事件
IE 为 DOM 文档中的某些部分提供了 readystatechange 事件。这个事件的目的是提供与文档或
元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。支持 readystatechange 事件的
每个对象都有一个 readyState 属性，可能包含下列 5 个值中的一个。
- uninitialized（未初始化）：对象存在但尚未初始化。
- loading（正在加载）：对象正在加载数据。
- loaded（加载完毕）：对象加载数据完成。
- interactive（交互）：可以操作对象了，但还没有完全加载。
- complete（完成）：对象已经加载完毕。

5. pageshow和pagehide事件
Firefox 和 Opera 有一个特性，名叫“往返缓存”（back-forward cache，或 bfcache），可以在用户使
用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存中不仅保存着页面数据，还保存
了 DOM 和 JavaScript 的状态；实际上是将整个页面都保存在了内存里。如果页面位于 bfcache 中，那么
再次打开该页面时就不会触发 load 事件。尽管由于内存中保存了整个页面的状态，不触发 load 事件
也不应该会导致什么问题，但为了更形象地说明 bfcache 的行为， Firefox 还是提供了一些新事件。
第一个事件就是 pageshow，这个事件在页面显示时触发，无论该页面是否来自 bfcache。在重新加
载的页面中， pageshow 会在 load 事件触发后触发；而对于 bfcache 中的页面， pageshow 会在页面状
态完全恢复的那一刻触发。另外要注意的是，虽然这个事件的目标是 document，但必须将其事件处理
程序添加到 window。

6. hashchange事件
HTML5 新增了 hashchange 事件，以便在 URL 的参数列表（及 URL 中“#”号后面的所有字符串）
发生变化时通知开发人员。之所以新增这个事件，是因为在 Ajax 应用中，开发人员经常要利用 URL 参
数列表来保存状态或导航信息。
必须要把 hashchange 事件处理程序添加给 window 对象，然后 URL 参数列表只要变化就会调用
它。此时的 event 对象应该额外包含两个属性： oldURL 和 newURL。这两个属性分别保存着参数列表
变化前后的完整 URL。

### 设备事件
1. orientationchange事件
苹果公司为移动 Safari 中添加了 orientationchange 事件，以便开发人员能够确定用户何时将设
备由横向查看模式切换为纵向查看模式。移动 Safari 的 window.orientation 属性中可能包含 3 个值：
0 表示肖像模式， 90 表示向左旋转的横向模式（“主屏幕”按钮在右侧）， -90 表示向右旋转的横向模
式（“主屏幕”按钮在左侧）。

2. MozOrientation事件
Firefox 3.6 为检测设备的方向引入了一个名为 MozOrientation 的新事件。（前缀 Moz 表示这是特
定于浏览器开发商的事件，不是标准事件。）当设备的加速计检测到设备方向改变时，就会触发这个事
件。但这个事件与 iOS 中的 orientationchange 事件不同，该事件只能提供一个平面的方向变化。由
于 MozOrientation 事件是在 window 对象上触发的，所以可以使用以下代码来处理。

3. deviceorientation事件
本质上，DeviceOrientation Event 规范定义的 deviceorientation 事件与 MozOrientation 事件类
似。它也是在加速计检测到设备方向变化时在 window 对象上触发，而且具有与 MozOrientation 事件
相同的支持限制。不过， deviceorientation 事件的意图是告诉开发人员设备在空间中朝向哪儿，而
不是如何移动。
触发 deviceorientation 事件时，事件对象中包含着每个轴相对于设备静止状态下发生变化的信
息。事件对象包含以下 5 个属性。
- alpha：在围绕 z 轴旋转时（即左右旋转时）， y 轴的度数差；是一个介于 0 到 360 之间的浮点数。
- beta：在围绕 x 轴旋转时（即前后旋转时）， z 轴的度数差；是一个介于180 到 180 之间的浮点数。
- gamma：在围绕 y 轴旋转时（即扭转设备时）， z 轴的度数差；是一个介于90 到 90 之间的浮点数。
- absolute：布尔值，表示设备是否返回一个绝对值。
- compassCalibrated：布尔值，表示设备的指南针是否校准过。

4. devicemotion事件
DeviceOrientation Event 规范还定义了一个 devicemotion 事件。
触发 devicemotion 事件时，事件对象包含以下属性。
- acceleration：一个包含 x、 y 和 z 属性的对象，在不考虑重力的情况下，告诉你在每个方向
上的加速度。
- accelerationIncludingGravity：一个包含 x、 y 和 z 属性的对象，在考虑 z 轴自然重力加
速度的情况下，告诉你在每个方向上的加速度。
- interval：以毫秒表示的时间值，必须在另一个 devicemotion 事件触发前传入。这个值在每
个事件中应该是一个常量。
- rotationRate：一个包含表示方向的 alpha、 beta 和 gamma 属性的对象。

### 触摸与手势事件
1. 触摸事件
包含 iOS 2.0 软件的 iPhone 3G 发布时，也包含了一个新版本的 Safari 浏览器。这款新的移动 Safari
提供了一些与触摸（touch）操作相关的新事件。后来， Android 上的浏览器也实现了相同的事件。触摸
事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。具体来说，有以下几个触
摸事件。
- touchstart：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。
- touchmove：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用 preventDefault()
可以阻止滚动。
- touchend：当手指从屏幕上移开时触发。
- touchcancel：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。
上面这几个事件都会冒泡，也都可以取消。虽然这些触摸事件没有在 DOM 规范中定义，但它们却
是以兼容 DOM 的方式实现的。因此，每个触摸事件的 event 对象都提供了在鼠标事件中常见的属性：
bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、
ctrlKey 和 metaKey。
除了常见的 DOM 属性外，触摸事件还包含下列三个用于跟踪触摸的属性。
- touches：表示当前跟踪的触摸操作的 Touch 对象的数组。
- targetTouchs：特定于事件目标的 Touch 对象的数组。
- changeTouches：表示自上次触摸以来发生了什么改变的 Touch 对象的数组。
每个 Touch 对象包含下列属性。
- clientX：触摸目标在视口中的 x 坐标。
- clientY：触摸目标在视口中的 y 坐标。
- identifier：标识触摸的唯一 ID。
- pageX：触摸目标在页面中的 x 坐标。
- pageY：触摸目标在页面中的 y 坐标。
- screenX：触摸目标在屏幕中的 x 坐标。
- screenY：触摸目标在屏幕中的 y 坐标。
- target：触摸的 DOM 节点目标。

2. 手势事件
iOS 2.0 中的 Safari 还引入了一组手势事件。当两个手指触摸屏幕时就会产生手势，手势通常会改变
显示项的大小，或者旋转显示项。有三个手势事件，分别介绍如下。
- gesturestart：当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发。
- gesturechange：当触摸屏幕的任何一个手指的位置发生变化时触发。
- gestureend：当任何一个手指从屏幕上面移开时触发。

只有两个手指都触摸到事件的接收容器时才会触发这些事件。在一个元素上设置事件处理程序，意
味着两个手指必须同时位于该元素的范围之内，才能触发手势事件（这个元素就是目标）。由于这些事
件冒泡，所以将事件处理程序放在文档上也可以处理所有手势事件。此时，事件的目标就是两个手指都
位于其范围内的那个元素。

触摸事件和手势事件之间存在某种关系。当一个手指放在屏幕上时，会触发 touchstart 事件。如
果另一个手指又放在了屏幕上，则会先触发 gesturestart 事件，随后触发基于该手指的 touchstart
事件。如果一个或两个手指在屏幕上滑动，将会触发 gesturechange 事件。但只要有一个手指移开，
就会触发 gestureend 事件，紧接着又会触发基于该手指的 touchend 事件。

与触摸事件一样，每个手势事件的 event 对象都包含着标准的鼠标事件属性： bubbles、
cancelable、 view、 clientX、 clientY、 screenX、 screenY、 detail、 altKey、 shiftKey、
ctrlKey 和 metaKey。此外，还包含两个额外的属性： rotation 和 scale。其中， rotation 属性表
示手指变化引起的旋转角度，负值表示逆时针旋转，正值表示顺时针旋转（该值从 0 开始）。而 scale
属性表示两个手指间距离的变化情况（例如向内收缩会缩短距离）；这个值从 1 开始，并随距离拉大而
增长，随距离缩短而减小。

## 内存和性能

### 事件委托
对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事
件处理程序，就可以管理某一类型的所有事件。

如果可行的话，也可以考虑为 document 对象添加一个事件处理程序，用以处理页面上发生的某种
特定类型的事件。这样做与采取传统的做法相比具有如下优点。
- document 对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序
（无需等待 DOMContentLoaded 或 load 事件）。换句话说，只要可单击的元素呈现在页面上，
就可以立即具备适当的功能。
- 在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的 DOM 引用更少，
所花的时间也更少。
- 整个页面占用的内存空间更少，能够提升整体性能。
最适合采用事件委托技术的事件包括 click、mousedown、mouseup、keydown、keyup 和 keypress。
虽然 mouseover 和 mouseout 事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。
（因为当鼠标从一个元素移到其子节点时，或者当鼠标移出该元素时，都会触发 mouseout 事件。）

### 移除事件处理程序
每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就
会建立一个连接。这种连接越多，页面执行起来就越慢。如前所述，可以采用事件委托技术，限制建立
的连接数量。另外，在不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那
些过时不用的“空事件处理程序”（dangling event handler），也是造成 Web 应用程序内存与性能问题的
主要原因。

在两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有事件处理程序的元素时。
这可能是通过纯粹的 DOM 操作，例如使用 removeChild()和 replaceChild()方法，但更多地是发
生在使用 innerHTML 替换页面中某一部分的时候。如果带有事件处理程序的元素被 innerHTML 删除
了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。


## 模拟事件
### DOM中的事件模拟
可以在 document 对象上使用 createEvent()方法创建 event 对象。这个方法接收一个参数，即
表示要创建的事件类型的字符串。在 DOM2 级中，所有这些字符串都使用英文复数形式，而在 DOM3
级中都变成了单数。这个字符串可以是下列几字符串之一。
- UIEvents：一般化的 UI 事件。 鼠标事件和键盘事件都继承自 UI 事件。 DOM3 级中是 UIEvent。
- MouseEvents：一般化的鼠标事件。 DOM3 级中是 MouseEvent。
- MutationEvents：一般化的 DOM 变动事件。 DOM3 级中是 MutationEvent。
- HTMLEvents：一般化的 HTML 事件。没有对应的 DOM3 级事件（HTML 事件被分散到其他类
别中）。

1. 模拟鼠标事件
创建新的鼠标事件对象并为其指定必要的信息，就可以模拟鼠标事件。创建鼠标事件对象的方法是
为 createEvent()传入字符串"MouseEvents"。返回的对象有一个名为 initMouseEvent()方法，
用于指定与该鼠标事件有关的信息。这个方法接收 15 个参数，分别与鼠标事件中每个典型的属性一一
对应；这些参数的含义如下。
- type（字符串）：表示要触发的事件类型，例如"click"。
- bubbles（布尔值）：表示事件是否应该冒泡。为精确地模拟鼠标事件，应该把这个参数设置为
true。
- cancelable（布尔值）：表示事件是否可以取消。为精确地模拟鼠标事件，应该把这个参数设
置为 true。
- view（AbstractView）：与事件关联的视图。这个参数几乎总是要设置为 document.defaultView。
- detail（整数）： 与事件有关的详细信息。这个值一般只有事件处理程序使用，但通常都设置为 0。
- screenX（整数）：事件相对于屏幕的 X 坐标。
- screenY（整数）：事件相对于屏幕的 Y 坐标。
- clientX（整数）：事件相对于视口的 X 坐标。
- clientY（整数）：事件想对于视口的 Y 坐标。
- ctrlKey（布尔值）：表示是否按下了 Ctrl 键。默认值为 false。
- altKey（布尔值）：表示是否按下了 Alt 键。默认值为 false。
- shiftKey（布尔值）：表示是否按下了 Shift 键。默认值为 false。
- metaKey（布尔值）：表示是否按下了 Meta 键。默认值为 false。
- button（整数）：表示按下了哪一个鼠标键。默认值为 0。
- relatedTarget（对象）： 表示与事件相关的对象。这个参数只在模拟 mouseover 或 mouseout
时使用。

2. 模拟键盘事件
前面曾经提到过，“DOM2 级事件”中没有就键盘事件作出规定，因此模拟键盘事件并没有现成的
思路可循。“DOM2 级事件”的草案中本来包含了键盘事件，但在定稿之前又被删除了； Firefox 根据其
草案实现了键盘事件。需要提请大家注意的是，“DOM3 级事件”中的键盘事件与曾包含在“DOM2 级
事件”草案中的键盘事件有很大区别。
DOM3 级规定，调用 createEvent()并传入"KeyboardEvent"就可以创建一个键盘事件。返回的
事件对象会包含一个 initKeyEvent()方法，这个方法接收下列参数。
- type（字符串）：表示要触发的事件类型，如"keydown"。
- bubbles（布尔值）：表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为 true。
- cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为 true。
- view （AbstractView ）：与事件关联的视图。这个参数几乎总是要设置为 document.
defaultView。
- key（布尔值）：表示按下的键的键码。
- location（整数）：表示按下了哪里的键。 0 表示默认的主键盘， 1 表示左， 2 表示右， 3 表示
数字键盘， 4 表示移动设备（即虚拟键盘）， 5 表示手柄。
- modifiers（字符串）：空格分隔的修改键列表，如"Shift"。
- repeat（整数）：在一行中按了这个键多少次。

在 Firefox 中，调用 createEvent()并传入"KeyEvents"就可以创建一个键盘事件。返回的事件
对象会包含一个 initKeyEvent()方法，这个方法接受下列 10 个参数。
- type（字符串）：表示要触发的事件类型，如"keydown"。
- bubbles（布尔值）：表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为 true。
- cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为 true。
- view（AbstractView）：与事件关联的视图。这个参数几乎总是要设置为 document.defaultView。
- ctrlKey（布尔值）：表示是否按下了 Ctrl 键。默认值为 false。
- altKey（布尔值）：表示是否按下了 Alt 键。默认值为 false。
- shiftKey（布尔值）：表示是否按下了 Shift 键。默认值为 false。
- metaKey（布尔值）：表示是否按下了 Meta 键。默认值为 false。
- keyCode（整数）：被按下或释放的键的键码。这个参数对 keydown 和 keyup 事件有用，默认
值为 0。
- charCode（整数）：通过按键生成的字符的 ASCII 编码。这个参数对 keypress 事件有用，默
认值为 0。

3. 模拟其他事件
虽然鼠标事件和键盘事件是在浏览器中最经常模拟的事件，但有时候同样需要模拟变动事件和
HTML 事 件 。 要 模 拟 变 动 事 件 ， 可 以 使 用 createEvent("MutationEvents") 创 建 一 个 包 含
initMutationEvent() 方 法 的 变 动 事 件 对 象 。 这 个 方 法 接 受 的 参 数 包 括 ： type 、 bubbles 、
cancelable、 relatedNode、 preValue、 newValue、 attrName 和 attrChange。

4. 自定义DOM事件
DOM3 级还定义了“自定义事件”。自定义事件不是由 DOM 原生触发的，它的目的是让开发人员
创建自己的事件。要创建新的自定义事件，可以调用 createEvent("CustomEvent")。返回的对象有
一个名为 initCustomEvent()的方法，接收如下 4 个参数。
- type（字符串）：触发的事件类型，例如"keydown"。
- bubbles（布尔值）：表示事件是否应该冒泡。
- cancelable（布尔值）：表示事件是否可以取消。
- detail（对象）：任意值，保存在 event 对象的 detail 属性中。

### IE中的事件模拟
调用 document.createEventObject()方法可以在 IE 中创建 event 对象。但与 DOM 方式不同
的是，这个方法不接受参数，结果会返回一个通用的 event 对象。然后，你必须手工为这个对象添加
所有必要的信息（没有方法来辅助完成这一步骤）。最后一步就是在目标上调用 fireEvent()方法，这
个方法接受两个参数：事件处理程序的名称和 event 对象。在调用 fireEvent()方法时，会自动为
event 对象添加 srcElement 和 type 属性；其他属性则都是必须通过手工添加的。换句话说，模拟任
何 IE 支持的事件都采用相同的模式。

---
# 表单脚本
JavaScript 最初的一个应用，就是分担服务器处理表单的责任，打破处处依赖服务器的局面。尽
管目前的 Web 和 JavaScript 已经有了长足的发展，但 Web 表单的变化并不明显。由于 Web 表单
没有为许多常见任务提供现成的解决手段，很多开发人员不仅会在验证表单时使用 JavaScirpt，而且还
增强了一些标准表单控件的默认行为。
 
## 表单的基础知识
在 HTML 中，表单是由<form>元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。 HTMLFormElement 继承了 HTMLElement，因而与其他 HTML 元素具有相同的默认属
性。不过， HTMLFormElement 也有它自己下列独有的属性和方法。
- acceptCharset：服务器能够处理的字符集；等价于 HTML 中的 accept-charset 特性。
- action：接受请求的 URL；等价于 HTML 中的 action 特性。
- elements：表单中所有控件的集合（HTMLCollection）。
- enctype：请求的编码类型；等价于 HTML 中的 enctype 特性。
- length：表单中控件的数量。
- method：要发送的 HTTP 请求类型，通常是"get"或"post"；等价于 HTML 的 method 特性。
- name：表单的名称；等价于 HTML 的 name 特性。
- reset()：将所有表单域重置为默认值。
- submit()：提交表单。
- target：用于发送请求和接收响应的窗口名称；等价于 HTML 的 target 特性。

### 提交表单
用户单击提交按钮或图像按钮时，就会提交表单。使用<input>或<button>都可以定义提交按钮，
只要将其 type 特性的值设置为"submit"即可，而图像按钮则是通过将<input>的 type 特性值设置为
"image"来定义的。因此，只要我们单击以下代码生成的按钮，就可以提交表单。

### 重置表单
在用户单击重置按钮时，表单会被重置。使用 type 特性值为"reset"的<input>或<button>都
可以创建重置按钮。
```html
<!-- 通用重置按钮 -->
<input type="reset" value="Reset Form">
<!-- 自定义重置按钮 -->
<button type="reset">Reset Form</button>
```
### 表单字段
可以像访问页面中的其他元素一样，使用原生 DOM 方法访问表单元素。此外，每个表单都有
elements 属性，该属性是表单中所有表单元素（字段）的集合。这个 elements 集合是一个有序列表，
其中包含着表单中的所有字段，例如<input>、 <textarea>、 <button>和<fieldset>。每个表单字
段在 elements 集合中的顺序，与它们出现在标记中的顺序相同，可以按照位置和 name 特性来访问它
们。

1. 共有的表单字段属性
除了<fieldset>元素之外，所有表单字段都拥有相同的一组属性。由于<input>类型可以表示多
种表单字段，因此有些属性只适用于某些字段，但还有一些属性是所有字段所共有的。表单字段共有的
属性如下。
- disabled：布尔值，表示当前字段是否被禁用。
- form：指向当前字段所属表单的指针；只读。
- name：当前字段的名称。
- readOnly：布尔值，表示当前字段是否只读。
- tabIndex：表示当前字段的切换（tab）序号。
- type：当前字段的类型，如"checkbox"、 "radio"，等等。
- value：当前字段将被提交给服务器的值。对文件字段来说，这个属性是只读的，包含着文件
在计算机中的路径。

2. 共有的表单字段方法
每个表单字段都有两个方法： focus()和 blur()。其中， focus()方法用于将浏览器的焦点设置
到表单字段，即激活表单字段，使其可以响应键盘事件。

3. 共有的表单字段事件
除了支持鼠标、键盘、更改和 HTML 事件之外，所有表单字段都支持下列 3 个事件。
- blur：当前字段失去焦点时触发。
- change：对于<input>和<textarea>元素，在它们失去焦点且 value 值改变时触发；对于
<select>元素，在其选项改变时触发。
- focus：当前字段获得焦点时触发。

当用户改变了当前字段的焦点，或者我们调用了 blur()或 focus()方法时，都可以触发 blur 和
focus 事件。这两个事件在所有表单字段中都是相同的。但是， change 事件在不同表单控件中触发的
次数会有所不同。对于<input>和<textarea>元素，当它们从获得焦点到失去焦点且 value 值改变时，
才会触发 change 事件。对于<select>元素，只要用户选择了不同的选项，就会触发 change 事件；
换句话说，不失去焦点也会触发 change 事件。


## 文本框脚本
在 HTML 中，有两种方式来表现文本框：一种是使用<input>元素的单行文本框，另一种是使用
<textarea>的多行文本框。这两个控件非常相似，而且多数时候的行为也差不多。不过，它们之间仍
然存在一些重要的区别。
要表现文本框，必须将<input>元素的 type 特性设置为"text"。而通过设置 size 特性，可以指
定文本框中能够显示的字符数。通过 value 特性，可以设置文本框的初始值，而 maxlength 特性则用
于指定文本框可以接受的最大字符数。如果要创建一个文本框，让它能够显示 25 个字符，但输入不能
超过 50 个字符。
```html
<input type="text" size="25" maxlength="50" value="initial value">
<textarea rows="25" cols="5">initial value</textarea>
```

### 选择文本
上述两种文本框都支持 select()方法，这个方法用于选择文本框中的所有文本。在调用 select()
方法时，大多数浏览器（Opera 除外）都会将焦点设置到文本框中。这个方法不接受参数，可以在任何
时候被调用。
```javascript
var textbox = document.forms[0].elements["textbox1"];
textbox.select();
```
在文本框获得焦点时选择其所有文本，这是一种非常常见的做法，特别是在文本框包含默认值的时
候。因为这样做可以让用户不必一个一个地删除文本。

1. 选择（select）事件
与 select()方法对应的，是一个 select 事件。在选择了文本框中的文本时，就会触发 select
事件。不过，到底什么时候触发 select 事件，还会因浏览器而异。在 IE9+、 Opera、 Firefox、 Chrome
和 Safari 中，只有用户选择了文本（而且要释放鼠标），才会触发 select 事件。而在 IE8 及更早版本中，
只要用户选择了一个字母（不必释放鼠标），就会触发 select 事件。另外，在调用 select()方法时也
会触发 select 事件。

2. 取得选择的文本
虽然通过 select 事件我们可以知道用户什么时候选择了文本，但仍然不知道用户选择了什么文本。
HTML5 通过一些扩展方案解决了这个问题，以便更顺利地取得选择的文本。该规范采取的办法是添加
两个属性： selectionStart 和 selectionEnd。这两个属性中保存的是基于 0 的数值，表示所选择
文本的范围（即文本选区开头和结尾的偏移量）。因此，要取得用户在文本框中选择的文本，可以使用
如下代码。
```javascript
function getSelectedText(textbox){
return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd);
}
```

3. 选择部分文本
HTML5 也 为 选 择 文 本 框 中 的 部 分 文 本 提 供 了 解 决 方 案 ， 即 最 早 由 Firefox 引 入 的
setSelectionRange()方法。现在除select()方法之外，所有文本框都有一个setSelectionRange()
方法。这个方法接收两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引
（类似于 substring()方法的两个参数）。

### 过滤输入
我们经常会要求用户在文本框中输入特定的数据，或者输入特定格式的数据。例如，必须包含某些
字符，或者必须匹配某种模式。由于文本框在默认情况下没有提供多少验证数据的手段，因此必须使用
JavaScript 来完成此类过滤输入的操作。而综合运用事件和 DOM 手段，就可以将普通的文本框转换成能
够理解用户输入数据的功能型控件。

1. 屏蔽字符
有时候，我们需要用户输入的文本中包含或不包含某些字符。例如，电话号码中不能包含非数值字
符。如前所述，响应向文本框中插入字符操作的是 keypress 事件。因此，可以通过阻止这个事件的默
认行为来屏蔽此类字符。在极端的情况下，可以通过下列代码屏蔽所有按键操作。
```javascript
EventUtil.addHandler(textbox, "keypress", function(event){
event = EventUtil.getEvent(event);
EventUtil.preventDefault(event);
});
```
虽然理论上只应该在用户按下字符键时才触发 keypress 事件，但有些浏览器也会对其他键触发此
事件。 Firefox 和 Safari（3.1 版本以前）会对向上键、向下键、退格键和删除键触发 keypress 事件；
Safari 3.1 及更新版本则不会对这些键触发 keypress 事件。这意味着，仅考虑到屏蔽不是数值的字符还
不够，还要避免屏蔽这些极为常用和必要的键。所幸的是，要检测这些键并不困难。在 Firefox 中，所
有由非字符键触发的 keypress 事件对应的字符编码为 0，而在 Safari 3 以前的版本中，对应的字符编
码全部为 8。为了让代码更通用，只要不屏蔽那些字符编码小于 10 的键即可。
除此之外，还有一个问题需要处理：复制、粘贴及其他操作还要用到 Ctrl 键。在除 IE 之外的所有
浏览器中，前面的代码也会屏蔽 Ctrl+C、 Ctrl+V，以及其他使用 Ctrl 的组合键。因此，最后还要添加一
个检测条件，以确保用户没有按下 Ctrl 键。
```javascript
EventUtil.addHandler(textbox, "keypress", function(event){
event = EventUtil.getEvent(event);
var target = EventUtil.getTarget(event);
var charCode = EventUtil.getCharCode(event);
if (!/\d/.test(String.fromCharCode(charCode)) && charCode > 9 &&
!event.ctrlKey){
EventUtil.preventDefault(event);
}
});
```
2. 操作剪贴板
- beforecopy：在发生复制操作前触发。
- copy：在发生复制操作时触发。
- beforecut：在发生剪切操作前触发。
- cut：在发生剪切操作时触发。
- beforepaste：在发生粘贴操作前触发。
- paste：在发生粘贴操作时触发。

由于没有针对剪贴板操作的标准，这些事件及相关对象会因浏览器而异。在 Safari、Chrome 和 Firefox
中， beforecopy、 beforecut 和 beforepaste 事件只会在显示针对文本框的上下文菜单（预期将发
生剪贴板事件）的情况下触发。但是， IE 则会在触发 copy、 cut 和 paste 事件之前先行触发这些事件。
至于 copy、 cut 和 paste 事件，只要是在上下文菜单中选择了相应选项，或者使用了相应的键盘组合
键，所有浏览器都会触发它们。
在实际的事件发生之前，通过 beforecopy、 beforecut 和 beforepaste 事件可以在向剪贴板发
送数据，或者从剪贴板取得数据之前修改数据。不过，取消这些事件并不会取消对剪贴板的操作——只
有取消 copy、 cut 和 paste 事件，才能阻止相应操作发生。
要访问剪贴板中的数据，可以使用 clipboardData 对象：在 IE 中，这个对象是 window 对象的
属性；而在 Firefox 4+、 Safari 和 Chrome 中，这个对象是相应 event 对象的属性。但是，在 Firefox、
Safari 和 Chorme 中，只有在处理剪贴板事件期间 clipboardData 对象才有效，这是为了防止对剪贴板
的未授权访问；在 IE 中，则可以随时访问 clipboardData 对象。为了确保跨浏览器兼容性，最好只
在发生剪贴板事件期间使用这个对象。
这个 clipboardData 对象有三个方法：getData()、setData()和 clearData()。其中，getData()
用于从剪贴板中取得数据，它接受一个参数，即要取得的数据的格式。在 IE 中，有两种数据格式： "text"
和"URL"。在 Firefox、 Safari 和 Chrome 中，这个参数是一种 MIME 类型；不过，可以用"text"代表
"text/plain"。
类似地， setData()方法的第一个参数也是数据类型，第二个参数是要放在剪贴板中的文本。对于
第一个参数， IE 照样支持"text"和"URL"，而 Safari 和 Chrome 仍然只支持 MIME 类型。但是，与
getData()方法不同的是， Safari 和 Chrome 的 setData()方法不能识别"text"类型。这两个浏览器在
成功将文本放到剪贴板中后，都会返回 true；否则，返回 false。

### 自动切换焦点
使用 JavaScript 可以从多个方面增强表单字段的易用性。其中，最常见的一种方式就是在用户填写
完当前字段时，自动将焦点切换到下一个字段。通常，在自动切换焦点之前，必须知道用户已经输入了
既定长度的数据（例如电话号码）。
```html
<input type="text" name="tel1" id="txtTel1" maxlength="3">
<input type="text" name="tel2" id="txtTel2" maxlength="3">
<input type="text" name="tel3" id="txtTel3" maxlength="4">
```
```javascript
(function(){
function tabForward(event){
event = EventUtil.getEvent(event);
var target = EventUtil.getTarget(event);
if (target.value.length == target.maxLength){
var form = target.form;
for (var i=0, len=form.elements.length; i < len; i++) {
if (form.elements[i] == target) {
if (form.elements[i+1]){
form.elements[i+1].focus();
}
return;
}
}
}
}
var textbox1 = document.getElementById("txtTel1");
var textbox2 = document.getElementById("txtTel2");
var textbox3 = document.getElementById("txtTel3");
EventUtil.addHandler(textbox1, "keyup", tabForward);
EventUtil.addHandler(textbox2, "keyup", tabForward);
EventUtil.addHandler(textbox3, "keyup", tabForward);
})();
```

### HTML5约束验证API
1. 必填字段
第一种情况是在表单字段中指定了 required 属性。
```html
<input type="text" name="username" required>
```
任何标注有 required 的字段，在提交表单时都不能空着。这个属性适用于<input>、 <textarea>
和<select>字段（Opera 11 及之前版本还不支持<select>的 required 属性）。在 JavaScript 中，通过
对应的 required 属性，可以检查某个表单字段是否为必填字段。

2. 其他输入类型
HTML5 为<input>元素的 type 属性又增加了几个值。这些新的类型不仅能反映数据类型的信息，
而且还能提供一些默认的验证功能。其中， "email"和"url"是两个得到支持最多的类型，各浏览器也
都为它们增加了定制的验证机制。

3. 数值范围
除了"email"和"url"， HTML5 还定义了另外几个输入元素。这几个元素都要求填写某种基于数
字的值： "number"、 "range"、 "datetime"、 "datetime-local"、 "date"、 "month"、 "week"，
还有"time"。浏览器对这几个类型的支持情况并不好，因此如果真想选用的话，要特别小心。目前，
浏览器开发商主要关注更好的跨平台兼容性以及更多的逻辑功能。因此，本节介绍的内容某种程度上有
些超前，不一定马上就能在实际开发中使用。

对所有这些数值类型的输入元素，可以指定 min 属性（最小的可能值）、 max 属性（最大的可能值）
和 step 属性（从 min 到 max 的两个刻度间的差值）

4. 输入模式
HTML5 为文本字段新增了 pattern 属性。这个属性的值是一个正则表达式，用于匹配文本框中的
值。

5. 检测有效性
使用 checkValidity()方法可以检测表单中的某个字段是否有效。所有表单字段都有个方法，如
果字段的值有效，这个方法返回 true，否则返回 false。字段的值是否有效的判断依据是本节前面介
绍过的那些约束。换句话说，必填字段中如果没有值就是无效的，而字段中的值与 pattern 属性不匹
配也是无效的。
与 checkValidity()方法简单地告诉你字段是否有效相比， validity 属性则会告诉你为什么字
段有效或无效。这个对象中包含一系列属性，每个属性会返回一个布尔值。
- customError ：如果设置了 setCustomValidity()，则为 true，否则返回 false。
- patternMismatch：如果值与指定的 pattern 属性不匹配，返回 true。
- rangeOverflow：如果值比 max 值大，返回 true。
- rangeUnderflow：如果值比 min 值小，返回 true。
- stepMisMatch：如果 min 和 max 之间的步长值不合理，返回 true。
- tooLong：如果值的长度超过了 maxlength 属性指定的长度，返回 true。有的浏览器（如 Firefox 4）
会自动约束字符数量，因此这个值可能永远都返回 false。
- typeMismatch：如果值不是"mail"或"url"要求的格式，返回 true。
- valid：如果这里的其他属性都是 false，返回 true。 checkValidity()也要求相同的值。
- valueMissing：如果标注为 required 的字段中没有值，返回 true。

6. 禁用验证
通过设置 novalidate 属性，可以告诉表单不进行验证。


## 选择框脚本
选择框是通过<select>和<option>元素创建的。为了方便与这个控件交互，除了所有表单字段共
有的属性和方法外， HTMLSelectElement 类型还提供了下列属性和方法。
- add(newOption, relOption)：向控件中插入新<option>元素，其位置在相关项（relOption）
之前。
- multiple：布尔值，表示是否允许多项选择；等价于 HTML 中的 multiple 特性。
- options：控件中所有<option>元素的 HTMLCollection。
- remove(index)：移除给定位置的选项。
- selectedIndex：基于 0 的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件，
只保存选中项中第一项的索引。
- size：选择框中可见的行数；等价于 HTML 中的 size 特性。

选择框的 type 属性不是"select-one"，就是"select-multiple"，这取决于 HTML 代码中有
没有 multiple 特性。选择框的 value 属性由当前选中项决定，相应规则如下。
- 如果没有选中的项，则选择框的 value 属性保存空字符串。
- 如果有一个选中项，而且该项的 value 特性已经在 HTML 中指定，则选择框的 value 属性等
于选中项的 value 特性。即使 value 特性的值是空字符串，也同样遵循此条规则。
- 如果有一个选中项，但该项的 value 特性在 HTML 中未指定，则选择框的 value 属性等于该
项的文本。
- 如果有多个选中项，则选择框的 value 属性将依据前两条规则取得第一个选中项的值。

在 DOM 中，每个<option>元素都有一个 HTMLOptionElement 对象表示。为便于访问数据，
HTMLOptionElement 对象添加了下列属性：
- index：当前选项在 options 集合中的索引。
- label：当前选项的标签；等价于 HTML 中的 label 特性。
- selected：布尔值，表示当前选项是否被选中。将这个属性设置为 true 可以选中当前选项。
- text：选项的文本。
- value：选项的值（等价于 HTML 中的 value 特性）。

### 选择选项
对于只允许选择一项的选择框，访问选中项的最简单方式，就是使用选择框的 selectedIndex 属
性，
```javascript
var selectedOption = selectbox.options[selectbox.selectedIndex];
```
另一种选择选项的方式，就是取得对某一项的引用，然后将其 selected 属性设置为 true。
```javascript
selectbox.options[0].selected = true;
```

### 添加选项
可以使用 JavaScript 动态创建选项，并将它们添加到选择框中。添加选项的方式有很多，第一种方
式就是使用如下所示的 DOM 方法。
```javascript
var newOption = document.createElement("option");
newOption.appendChild(document.createTextNode("Option text"));
newOption.setAttribute("value", "Option value");
selectbox.appendChild(newOption);
```

第二种方式是使用 Option 构造函数来创建新选项，这个构造函数是 DOM 出现之前就有的，一
直遗留到现在。 Option 构造函数接受两个参数：文本（text）和值（value）；第二个参数可选。
虽然这个构造函数会创建一个 Object 的实例，但兼容 DOM 的浏览器会返回一个<option>元素。
换句话说，在这种情况下，我们仍然可以使用 appendChild()将新选项添加到选择框中。
```javascript
var newOption = new Option("Option text", "Option value");
selectbox.appendChild(newOption); //在 IE8 及之前版本中有问题
```

第三种添加新选项的方式是使用选择框的 add()方法。 DOM 规定这个方法接受两个参数：要添加
的新选项和将位于新选项之后的选项。如果想在列表的最后添加一个选项，应该将第二个参数设置为
null。在 IE 对 add()方法的实现中，第二个参数是可选的，而且如果指定，该参数必须是新选项之后
选项的索引。兼容 DOM 的浏览器要求必须指定第二个参数，因此要想编写跨浏览器的代码，就不能只
传入一个参数。这时候，为第二个参数传入 undefined，就可以在所有浏览器中都将新选项插入到列
表最后了。
```javascript
var newOption = new Option("Option text", "Option value");
selectbox.add(newOption, undefined); //最佳方案
```
### 移除选项
与添加选项类似，移除选项的方式也有很多种。首先，可以使用 DOM 的 removeChild()方法，
为其传入要移除的选项。
```javascript
selectbox.removeChild(selectbox.options[0]); //移除第一个选项
```

其次，可以使用选择框的 remove()方法。这个方法接受一个参数，即要移除选项的索引。
```javascript
selectbox.remove(0); //移除第一个选项
```

最后一种方式，就是将相应选项设置为 null。这种方式也是 DOM 出现之前浏览器的遗留机制。
```javascript
selectbox.options[0] = null; //移除第一个选项
```

### 移动和重排选项
在 DOM 标准出现之前，将一个选择框中的选项移动到另一个选择框中是非常麻烦的。整个过程要
涉及从第一个选择框中移除选项，然后以相同的文本和值创建新选项，最后再将新选项添加到第二个选
择框中。而使用 DOM 的 appendChild()方法，就可以将第一个选择框中的选项直接移动到第二个选
择框中。我们知道，如果为 appendChild()方法传入一个文档中已有的元素，那么就会先从该元素的
父节点中移除它，再把它添加到指定的位置。

重排选项次序的过程也十分类似，最好的方式仍然是使用 DOM 方法。要将选择框中的某一项移动
到特定位置，最合适的 DOM 方法就是 insertBefore()； appendChild()方法只适用于将选项添加
到选择框的最后。

## 表单序列化
随着 Ajax 的出现，表单序列化已经成为一种常见需求（第 21 章将讨论 Ajax）。在 JavaScript 中，可
以利用表单字段的 type 属性，连同 name 和 value 属性一起实现对表单的序列化。在编写代码之前，
有必须先搞清楚在表单提交期间，浏览器是怎样将数据发送给服务器的。
- 对表单字段的名称和值进行 URL 编码，使用和号（&）分隔。
- 不发送禁用的表单字段。
- 只发送勾选的复选框和单选按钮。
- 不发送 type 为"reset"和"button"的按钮。
- 多选选择框中的每个选中的值单独一个条目。
- 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。也包括 type
为"image"的<input>元素。
- <select>元素的值，就是选中的<option>元素的 value 特性的值。如果<option>元素没有
value 特性，则是<option>元素的文本值。


## 富文本编辑
富文本编辑，又称为 WYSIWYG（What You See Is What You Get，所见即所得）。在网页中编辑富
文本内容，是人们对 Web 应用程序最大的期待之一。虽然也没有规范，但在 IE 最早引入的这一功能基
础上，已经出现了事实标准。而且， Opera、 Safari、 Chrome 和 Firefox 都已经支持这一功能。这一技术
的本质，就是在页面中嵌入一个包含空 HTML 页面的 iframe。通过设置 designMode 属性，这个空白
的 HTML 页面可以被编辑，而编辑对象则是该页面<body>元素的 HTML 代码。 designMode 属性有两
个可能的值： "off"（默认值）和"on"。在设置为"on"时，整个文档都会变得可以编辑（显示插入符
号），然后就可以像使用字处理软件一样，通过键盘将文本内容加粗、变成斜体，等等。

### 使用contenteditable属性
另一种编辑富文本内容的方式是使用名为 contenteditable 的特殊属性，这个属性也是由 IE 最
早实现的。可以把 contenteditable 属性应用给页面中的任何元素，然后用户立即就可以编辑该元素。
这种方法之所以受到欢迎，是因为它不需要 iframe、空白页和 JavaScript，只要为元素设置
contenteditable 属性即可。

### 操作富文本
与富文本编辑器交互的主要方式，就是使用 document.execCommand()。这个方法可以对文档执
行预定义的命令，而且可以应用大多数格式。可以为 document.execCommand()方法传递 3 个参数：
要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个
值（如果不需要值，则传递 null）。为了确保跨浏览器的兼容性，第二个参数应该始终设置为 false，
因为 Firefox 会在该参数为 true 时抛出错误。

命令 | 值（第三个参数） | 说明
--- | --- | ---
backcolor | 颜色字符串 | 设置文档的背景颜色
bold | null | 将选择的文本转换为粗体
copy | null | 将选择的文本复制到剪贴板
createlink | URL字符串 | 将选择的文本转换成一个链接，指向指定的URL
cut | null | 将选择的文本剪切到剪贴板
delete | null | 删除选择的文本
fontname | 字体名称 | 将选择的文本修改为指定字体
fontsize | 1～7 | 将选择的文本修改为指定字体大小
forecolor | 颜色字符串 | 将选择的文本修改为指定的颜色
formatblock | 要包围当前文本块的HTML标签；如<h1> | 使用指定的HTML标签来格式化选择的文本块
indent | null | 缩进文本
inserthorizontalrule | null | 在插入字符处插入一个<hr>元素
insertimage | 图像的URL | 在插入字符处插入一个图像
insertorderedlist | null | 在插入字符处插入一个<ol>元素
insertunorderedlist | null | 在插入字符处插入一个<ul>元素
insertparagraph | null | 在插入字符处插入一个<p>元素
italic | null | 将选择的文本转换成斜体
justifycenter | null | 将插入光标所在文本块居中对齐
justifyleft | null | 将插入光标所在文本块左对齐
outdent | null | 凸排文本（减少缩进）
paste | null | 将剪贴板中的文本粘贴到选择的文本
removeformat | null | 移除插入光标所在文本块的块级格式。这是撤销formatblock命令的操作
selectall | null | 选择文档中的所有文本
underline | null | 为选择的文本添加下划线
unlink | null | 移除文本的链接。这是撤销createlink命令的操作

其中，与剪贴板有关的命令在不同浏览器中的差异极大。 Opera 根本没有实现任何剪贴板命令，而
Firefox 在默认情况下会禁用它们（必须修改用户的首选项来启用它们）。 Safari 和 Chrome 实现了 cut 和
copy，但没有实现 paste。不过，即使不能通过 document.execCommand()来执行这些命令，但却可
以通过相应的快捷键来实现同样的操作。

### 富文本选区
在富文本编辑器中，使用框架（iframe）的 getSelection()方法，可以确定实际选择的文本。
这个方法是 window 对象和 document 对象的属性，调用它会返回一个表示当前选择文本的 Selection
对象。每个 Selection 对象都有下列属性。
- anchorNode：选区起点所在的节点。
- anchorOffset：在到达选区起点位置之前跳过的 anchorNode 中的字符数量。
- focusNode：选区终点所在的节点。
- focusOffset： focusNode 中包含在选区之内的字符数量。
- isCollapsed：布尔值，表示选区的起点和终点是否重合。
- rangeCount：选区中包含的 DOM 范围的数量。
Selection 对象的这些属性并没有包含多少有用的信息。好在，该对象的下列方法提供了更多信
息，并且支持对选区的操作。
- addRange(range)：将指定的 DOM 范围添加到选区中。
- collapse(node, offset)：将选区折叠到指定节点中的相应的文本偏移位置。
- collapseToEnd()：将选区折叠到终点位置。
- collapseToStart()：将选区折叠到起点位置。
- containsNode(node)：确定指定的节点是否包含在选区中。
- deleteFromDocument()：从文档中删除选区中的文本，与document.execCommand("delete",
false, null)命令的结果相同。
- extend(node, offset)：通过将 focusNode 和 focusOffset 移动到指定的值来扩展选区。
- getRangeAt(index)：返回索引对应的选区中的 DOM 范围。
- removeAllRanges()：从选区中移除所有 DOM 范围。实际上，这样会移除选区，因为选区中
至少要有一个范围。
- reomveRange(range)：从选区中移除指定的 DOM 范围。
- selectAllChildren(node)：清除选区并选择指定节点的所有子节点。
- toString()：返回选区所包含的文本内容。

### 表单与富文本
由于富文本编辑是使用 iframe 而非表单控件实现的，因此从技术上说，富文本编辑器并不属于表
单。换句话说，富文本编辑器中的 HTML 不会被自动提交给服务器，而需要我们手工来提取并提交
HTML。为此，通常可以添加一个隐藏的表单字段，让它的值等于从 iframe 中提取出的 HTML。具体
来说，就是在提交表单之前，从 iframe 中提取出 HTML，并将其插入到隐藏的字段中。


---
# 使用Canvas绘图
## 基本用法
要使用<canvas>元素，必须先设置其 width 和 height 属性，指定可以绘图的区域大小。出现在
开始和结束标签中的内容是后备信息，如果浏览器不支持<canvas>元素，就会显示这些信息。

与其他元素一样， <canvas>元素对应的 DOM 元素对象也有 width 和 height 属性，可以随意修
改。而且，也能通过 CSS 为该元素添加样式，如果不添加任何样式或者不绘制任何图形，在页面中是看
不到该元素的。
要在这块画布（canvas）上绘图，需要取得绘图上下文。而取得绘图上下文对象的引用，需要调用
getContext()方法并传入上下文的名字。传入"2d"，就可以取得 2D 上下文对象。

在使用<canvas>元素之前，首先要检测 getContext()方法是否存在，这一步非常重要。有些浏
览器会为 HTML 规范之外的元素创建默认的 HTML 元素对象。在这种情况下，即使 drawing 变量中
保存着一个有效的元素引用，也检测不到 getContext()方法。

## 2D上下文
使用 2D 绘图上下文提供的方法，可以绘制简单的 2D 图形，比如矩形、弧线和路径。 2D 上下文的
坐标开始于<canvas>元素的左上角，原点坐标是(0,0)。所有坐标值都基于这个原点计算， x 值越大表示
越靠右， y 值越大表示越靠下。默认情况下， width 和 height 表示水平和垂直两个方向上可用的像素
数目。

### 填充和描边
2D 上下文的两种基本绘图操作是填充和描边。填充，就是用指定的样式（颜色、渐变或图像）填
充图形；描边，就是只在图形的边缘画线。大多数 2D 上下文操作都会细分为填充和描边两个操作，而
操作的结果取决于两个属性： fillStyle 和 strokeStyle。
这两个属性的值可以是字符串、渐变对象或模式对象，而且它们的默认值都是"#000000"。如果为
它们指定表示颜色的字符串值，可以使用 CSS 中指定颜色值的任何格式，包括颜色名、十六进制码、
rgb、 rgba、 hsl 或 hsla。

### 绘制矩形
矩形是唯一一种可以直接在 2D 上下文中绘制的形状。与矩形有关的方法包括 fillRect()、
strokeRect()和 clearRect()。这三个方法都能接收 4 个参数：矩形的 x 坐标、矩形的 y 坐标、矩形
宽度和矩形高度。这些参数的单位都是像素。
首先， fillRect()方法在画布上绘制的矩形会填充指定的颜色。填充的颜色通过 fillStyle 属
性指定。
```
var drawing = document.getElementById("drawing");
//确定浏览器支持<canvas>元素
if (drawing.getContext){
var context = drawing.getContext("2d");
/*
* 根据 Mozilla 的文档
* http://developer.mozilla.org/en/docs/Canvas_tutorial:Basic_usage
*/
//绘制红色矩形
context.fillStyle = "#ff0000";
context.fillRect(10, 10, 50, 50);
//绘制半透明的蓝色矩形
context.fillStyle = "rgba(0,0,255,0.5)";
context.fillRect(30, 30, 50, 50);
}
```

### 绘制路径
2D 绘制上下文支持很多在画布上绘制路径的方法。通过路径可以创造出复
杂的形状和线条。要绘制路径，首先必须调用 beginPath()方法，表示要开始
绘制新路径。然后，再通过调用下列方法来实际地绘制路径。
- arc(x, y, radius, startAngle, endAngle, counterclockwise)：以(x,y)为圆心绘
制一条弧线，弧线半径为 radius，起始和结束角度（用弧度表示）分别为 startAngle 和
endAngle。最后一个参数表示 startAngle 和 endAngle 是否按逆时针方向计算，值为 false
表示按顺时针方向计算。
- arcTo(x1, y1, x2, y2, radius)：从上一点开始绘制一条弧线，到(x2,y2)为止，并且以
给定的半径 radius 穿过(x1,y1)。
- bezierCurveTo(c1x, c1y, c2x, c2y, x, y)：从上一点开始绘制一条曲线，到(x,y)为
止，并且以(c1x,c1y)和(c2x,c2y)为控制点。
- lineTo(x, y)：从上一点开始绘制一条直线，到(x,y)为止。
- moveTo(x, y)：将绘图游标移动到(x,y)，不画线。
- quadraticCurveTo(cx, cy, x, y)：从上一点开始绘制一条二次曲线，到(x,y)为止，并
且以(cx,cy)作为控制点。
- rect(x, y, width, height)：从点(x,y)开始绘制一个矩形，宽度和高度分别由 width 和
height 指定。这个方法绘制的是矩形路径，而不是 strokeRect()和 fillRect()所绘制的独
立的形状。
创建了路径后，接下来有几种可能的选择。如果想绘制一条连接到路径起点的线条，可以调用
closePath()。如果路径已经完成，你想用 fillStyle 填充它，可以调用 fill()方法。另外，还可
以调用 stroke()方法对路径描边，描边使用的是 strokeStyle。最后还可以调用 clip()，这个方法
可以在路径上创建一个剪切区域。

### 绘制文本
文本与图形总是如影随形。为此， 2D 绘图上下文也提供了绘制文本的方法。绘制文本主要有两个
方法： fillText()和 strokeText()。这两个方法都可以接收 4 个参数：要绘制的文本字符串、 x 坐
标、 y 坐标和可选的最大像素宽度。而且，这两个方法都以下列 3 个属性为基础。
- font：表示文本样式、大小及字体，用 CSS 中指定字体的格式来指定，例如"10px Arial"。
- textAlign：表示文本对齐方式。可能的值有"start"、"end"、"left"、"right"和"center"。
建议使用"start"和"end"，不要使用"left"和"right"，因为前两者的意思更稳妥，能同时
适合从左到右和从右到左显示（阅读）的语言。
- textBaseline：表示文本的基线。可能的值有"top"、"hanging"、"middle"、"alphabetic"、
"ideographic"和"bottom"。
这几个属性都有默认值，因此没有必要每次使用它们都重新设置一遍值。 fillText()方法使用
fillStyle 属性绘制文本，而 strokeText()方法使用 strokeStyle 属性为文本描边。相对来说，还
是使用 fillText()的时候更多，因为该方法模仿了在网页中正常显示文本。

### 变换
通过上下文的变换，可以把处理后的图像绘制到画布上。 2D 绘制上下文支持各种基本的绘制变换。
创建绘制上下文时，会以默认值初始化变换矩阵，在默认的变换矩阵下，所有处理都按描述直接绘制。
为绘制上下文应用变换，会导致使用不同的变换矩阵应用处理，从而产生不同的结果。
可以通过如下方法来修改变换矩阵。
- rotate(angle)：围绕原点旋转图像 angle 弧度。
- scale(scaleX, scaleY)：缩放图像，在 x 方向乘以 scaleX，在 y 方向乘以 scaleY。 scaleX
和 scaleY 的默认值都是 1.0。
- translate(x, y)：将坐标原点移动到(x,y)。执行这个变换之后， 坐标(0,0)会变成之前由(x,y)
表示的点。
- transform(m1_1, m1_2, m2_1, m2_2, dx, dy)：直接修改变换矩阵，方式是乘以如下
矩阵。
m1_1 m1_2 dx
m2_1 m2_2 dy
0 0 1
- setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)：将变换矩阵重置为默认状态，然后
再调用 transform()。

### 绘制图像
2D 绘图上下文内置了对图像的支持。如果你想把一幅图像绘制到画布上，可以使用 drawImage()
方法。根据期望的最终结果不同，调用这个方法时，可以使用三种不同的参数组合。最简单的调用方式
是传入一个 HTML <img>元素，以及绘制该图像的起点的 x 和 y 坐标。

除了上述两种方式，还可以选择把图像中的某个区域绘制到上下文中。 drawImage()方法的这种调
用方式总共需要传入 9 个参数：要绘制的图像、源图像的 x 坐标、源图像的 y 坐标、源图像的宽度、源
图像的高度、目标图像的 x 坐标、目标图像的 y 坐标、目标图像的宽度、目标图像的高度。这样调用
drawImage()方法可以获得最多的控制。
```javascript
context.drawImage(image, 0, 10, 50, 50, 0, 100, 40, 60);
```

### 阴影
2D 上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影。
- shadowColor：用 CSS 颜色格式表示的阴影颜色，默认为黑色。
- shadowOffsetX：形状或路径 x 轴方向的阴影偏移量，默认为 0。
- shadowOffsetY：形状或路径 y 轴方向的阴影偏移量，默认为 0。
- shadowBlur：模糊的像素数，默认 0，即不模糊。
这些属性都可以通过 context 对象来修改。只要在绘制前为它们设置适当的值，就能自动产生阴
影。

### 渐变
渐变由 CanvasGradient 实例表示，很容易通过 2D 上下文来创建和修改。要创建一个新的线性渐
变，可以调用 createLinearGradient()方法。这个方法接收 4 个参数：起点的 x 坐标、起点的 y 坐
标、终点的 x 坐标、终点的 y 坐标。调用这个方法后，它就会创建一个指定大小的渐变，并返回
CanvasGradient 对象的实例。
创建了渐变对象后，下一步就是使用 addColorStop()方法来指定色标。这个方法接收两个参数：
色标位置和 CSS 颜色值。色标位置是一个 0（开始的颜色）到 1（结束的颜色）之间的数字。

### 模式
模 式 其 实 就 是 重 复 的 图 像 ， 可 以 用 来 填 充 或 描 边 图 形 。 要 创 建 一 个 新 模 式 ， 可 以 调 用
createPattern()方法并传入两个参数：一个 HTML <img>元素和一个表示如何重复图像的字符串。
其中，第二个参数的值与 CSS 的 background-repeat 属性值相同，包括"repeat"、 "repeat-x"、
"repeat-y"和"no-repeat"。

### 使用图像数据
2D 上下文的一个明显的长处就是，可以通过 getImageData()取得原始图像数据。这个方法接收
4 个参数：要取得其数据的画面区域的 x 和 y 坐标以及该区域的像素宽度和高度。

### 合成
还有两个会应用到 2D 上下文中所有绘制操作的属性： globalAlpha 和 globalCompositionOperation。其中， globalAlpha 是一个介于 0 和 1 之间的值（包括 0 和 1），用于指定所有绘制的透
明度。默认值为 0。如果所有后续操作都要基于相同的透明度，就可以先把 globalAlpha 设置为适当
值，然后绘制，最后再把它设置回默认值 0。
```javascript
//绘制红色矩形
context.fillStyle = "#ff0000";
context.fillRect(10, 10, 50, 50);
//修改全局透明度
context.globalAlpha = 0.5;
//绘制蓝色矩形
context.fillStyle = "rgba(0,0,255,1)";
context.fillRect(30, 30, 50, 50);
//重置全局透明度
context.globalAlpha = 0;
```
在这个例子中，我们把蓝色矩形绘制到了红色矩形上面。因为在绘制蓝色矩形前， globalAlpha
已经被设置为 0.5，所以蓝色矩形会呈现半透明效果，透过它可以看到下面的红色矩形。
第二个属性 globalCompositionOperation 表示后绘制的图形怎样与先绘制的图形结合。这个
属性的值是字符串，可能的值如下。
- source-over（默认值）：后绘制的图形位于先绘制的图形上方。
- source-in：后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分完全透明。
- source-out：后绘制的图形与先绘制的图形不重叠的部分可见，先绘制的图形完全透明。
- source-atop：后绘制的图形与先绘制的图形重叠的部分可见，先绘制图形不受影响。
- destination-over： 后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见。
- destination-in：后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明。
- destination-out：后绘制的图形擦除与先绘制的图形重叠的部分。
- destination-atop：后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的
图形会变透明。
- lighter：后绘制的图形与先绘制的图形重叠部分的值相加，使该部分变亮。
- copy：后绘制的图形完全替代与之重叠的先绘制图形。
- xor：后绘制的图形与先绘制的图形重叠的部分执行“异或”操作。

## WebGL
WebGL 是针对 Canvas 的 3D 上下文。与其他 Web 技术不同， WebGL 并不是 W3C 制定的标准，而
是由 Khronos Group 制定的。其官方网站是这样介绍的：“Khronos Group 是一个非盈利的由会员资助的
协会，专注于为并行计算以及各种平台和设备上的图形及动态媒体制定无版税的开放标准。” Khronos
Group 也设计了其他图形处理 API，比如 OpenGL ES 2.0。浏览器中使用的 WebGL 就是基于 OpenGL ES
2.0 制定的。
OpenGL 等 3D 图形语言是非常复杂的，本书不可能介绍其中每一个概念。熟悉 OpenGL ES 2.0 的读
者可能会觉得 WebGL 更好理解一些，因为好多概念是相通的。

### 类型化数组
WebGL 涉及的复杂计算需要提前知道数值的精度，而标准的 JavaScript 数值无法满足需要。为此，
WebGL 引入了一个概念，叫类型化数组（typed arrays）。类型化数组也是数组，只不过其元素被设置为
特定类型的值。
类型化数组的核心就是一个名为 ArrayBuffer 的类型。每个 ArrayBuffer 对象表示的只是内存
中指定的字节数，但不会指定这些字节用于保存什么类型的数据。通过 ArrayBuffer 所能做的，就是
为了将来使用而分配一定数量的字节。

1. 视图
使用 ArrayBuffer（数组缓冲器类型）的一种特别的方式就是用它来创建数组缓冲器视图。其中，
最常见的视图是 DataView，通过它可以选择 ArrayBuffer 中一小段字节。为此，可以在创建 DataView
实例的时候传入一个 ArrayBuffer、一个可选的字节偏移量（从该字节开始选择）和一个可选的要选
择的字节数。

2. 类型化视图
类型化视图一般也被称为类型化数组，因为它们除了元素必须是某种特定的数据类型外，与常规的
数组无异。类型化视图也分几种，而且它们都继承了 DataView。
- Int8Array：表示 8 位二补整数。
- Uint8Array：表示 8 位无符号整数。
- Int16Array：表示 16 位二补整数。
- Uint16Array：表示 16 位无符号整数。
- Int32Array：表示 32 位二补整数。
- Uint32Array：表示 32 位无符号整数。
- Float32Array：表示 32 位 IEEE 浮点值。
- Float64Array：表示 64 位 IEEE 浮点值。
每种视图类型都以不同的方式表示数据，而同一数据视选择的类型不同有可能占用一或多字节。例
如， 20B 的 ArrayBuffer 可以保存 20 个 Int8Array 或 Uint8Array，或者 10 个 Int16Array 或
Uint16Array，或者 5 个 Int32Array、 Uint32Array 或 Float32Array，或者 2 个 Float64Array。

### WebGL上下文
目前，在支持的浏览器中， WebGL 的名字叫"experimental-webgl"，这是因为 WebGL 规范仍
然未制定完成。制定完成后，这个上下文的名字就会变成简单的"webgl"。如果浏览器不支持 WebGL，
那么取得该上下文时会返回 null。在使用 WebGL 上下文时，务必先检测一下返回值。
```javascript
var drawing = document.getElementById("drawing");
//确定浏览器支持<canvas>元素
if (drawing.getContext){
var gl = drawing.getContext("experimental-webgl");
if (gl){
//使用 WebGL
}
}
```
通过给 getContext()传递第二个参数，可以为 WebGL 上下文设置一些选项。这个参数本身是
个对象，可以包含下列属性。
- alpha：值为 true，表示为上下文创建一个 Alpha 通道缓冲区；默认值为 true。
- depth：值为 true，表示可以使用 16 位深缓冲区；默认值为 true。
- stencil：值为 true，表示可以使用 8 位模板缓冲区；默认值为 false。
- antialias：值为 true，表示将使用默认机制执行抗锯齿操作；默认值为 true。
- premultipliedAlpha：值为 true，表示绘图缓冲区有预乘 Alpha 值；默认值为 true。
- preserveDrawingBuffer：值为 true，表示在绘图完成后保留绘图缓冲区；默认值为 false。
建议确实有必要的情况下再开启这个值，因为可能影响性能。

1. 常量
如果你熟悉 OpenGL，那肯定会对各种操作中使用非常多的常量印象深刻。这些常量在 OpenGL 中
都 带 前 缀 GL_ 。 在 WebGL 中 ， 保 存 在 上 下 文 对 象 中 的 这 些 常 量 都 没 有 GL_ 前 缀 。 比 如 说 ，
GL_COLOR_BUFFER_BIT 常量在 WebGL 上下文中就是 gl.COLOR_BUFFER_BIT。 WebGL 以这种方式支
持大多数 OpenGL 常量（有一部分常量是不支持的）。

2. 方法命名
OpenGL（以及 WebGL）中的很多方法都试图通过名字传达有关数据类型的信息。如果某方法可以
接收不同类型及不同数量的参数，看方法名的后缀就可以知道。方法名的后缀会包含参数个数（1 到 4）
和接收的数据类型（f 表示浮点数， i 表示整数）。例如， gl.uniform4f()意味着要接收 4 个浮点数，
而 gl.uniform3i()则表示要接收 3 个整数。
也有很多方法接收数组参数而非一个个单独的参数。这样的方法其名字中会包含字母 v（即 vector，
矢量）。因此， gl.uniform3iv()可以接收一个包含 3 个值的整数数组。请大家记住以上命名约定，这
样对理解后面关于 WebGL 的讨论很有帮助

3. 准备绘图
在实际操作 WebGL 上下文之前，一般都要使用某种实色清除<canvas>，为绘图做好准备。为此，
首先必须使用 clearColor()方法来指定要使用的颜色值，该方法接收 4 个参数：红、绿、蓝和透明度。
每个参数必须是一个 0 到 1 之间的数值，表示每种分量在最终颜色中的强度。来看下面的例子。

4. 视口与坐标
开始绘图之前，通常要先定义 WebGL 的视口（viewport）。默认情况下，视口可以使用整个<canvas>
区域。要改变视口大小，可以调用 viewport()方法并传入 4 个参数：（视口相对于<canvas>元素的）
x 坐标、 y 坐标、宽度和高度。

5. 缓冲区
顶点信息保存在 JavaScript 的类型化数组中，使用之前必须转换到 WebGL 的缓冲区。要创建缓冲区，
可以调用 gl.createBuffer()，然后使用 gl.bindBuffer()绑定到 WebGL 上下文。这两步做完之
后，就可以用数据来填充缓冲区了。
调用 gl.bindBuffer()可以将 buffer 设置为上下文的当前缓冲区。此后，所有缓冲区操作都
直接在 buffer 中执行。因此，调用 gl.bufferData()时不需要明确传入 buffer 也没有问题。最后
一行代码使用 Float32Array 中的数据初始化了 buffer（一般都是用 Float32Array 来保存顶点信
息）。如果想使用 drawElements()输出缓冲区的内容，也可以传入 gl.ELEMENT_ARRAY_BUFFER。
gl.bufferData()的最后一个参数用于指定使用缓冲区的方式，取值范围是如下几个常量。
- gl.STATIC_DRAW：数据只加载一次，在多次绘图中使用。
- gl.STREAM_DRAW：数据只加载一次，在几次绘图中使用。
- gl.DYNAMIC_DRAW：数据动态改变，在多次绘图中使用。

6. 错误
JavaScript 与 WebGL 之间的一个最大的区别在于， WebGL 操作一般不会抛出错误。为了知道是否
有错误发生，必须在调用某个可能出错的方法后，手工调用 gl.getError()方法。这个方法返回一个
表示错误类型的常量。可能的错误常量如下。
- gl.NO_ERROR：上一次操作没有发生错误（值为 0）。
- gl.INVALID_ENUM：应该给方法传入 WebGL 常量，但却传错了参数。
- gl.INVALID_VALUE：在需要无符号数的地方传入了负值。
- gl.INVALID_OPERATION：在当前状态下不能完成操作。
- gl.OUT_OF_MEMORY：没有足够的内存完成操作。
- gl.CONTEXT_LOST_WEBGL：由于外部事件（如设备断电）干扰丢失了当前 WebGL 上下文。

7. 着色器
着色器（shader）是 OpenGL 中的另一个概念。 WebGL 中有两种着色器：顶点着色器和片段（或像
素）着色器。顶点着色器用于将 3D 顶点转换为需要渲染的 2D 点。片段着色器用于准确计算要绘制的
每个像素的颜色。 WebGL 着色器的独特之处也是其难点在于，它们并不是用 JavaScript 写的。这些着色
器是使用 GLSL（OpenGL Shading Language， OpenGL 着色语言）写的， GLSL 是一种与 C 和 JavaScript
完全不同的语言。

8. 编写着色器
GLSL 是一种类 C 语言，专门用于编写 OpenGL 着色器。因为 WebGL 是 OpenGL ES 2.0 的实现，所
以 OpenGL 中使用的着色器可以直接在 WebGL 中使用。这样就方便了将桌面图形应用移植到浏览器中。
每个着色器都有一个 main()方法，该方法在绘图期间会重复执行。为着色器传递数据的方式有两
种： Attribute 和 Uniform。通过 Attribute 可以向顶点着色器中传入顶点信息，通过 Uniform 可以向任何
着色器传入常量值。 Attribute 和 Uniform 在 main()方法外部定义，分别使用关键字 attribute 和
uniform。在这两个值类型关键字之后，是数据类型和变量名。

9. 编写着色器程序
浏览器不能理解 GLSL 程序，因此必须准备好字符串形式的 GLSL 程序，以便编译并链接到着色器
程序。为便于使用，通常是把着色器包含在页面的<script>标签内，并为该标签指定一个自定义的 type
属性。由于无法识别 type 属性值，浏览器不会解析<script>标签中的内容，但这不影响你读写其中
的代码。

10. 为着色器传入值
前面定义的着色器都必须接收一个值才能工作。为了给着色器传入这个值，必须先找到要接收这个
值的变量。对于 Uniform 变量，可以使用 gl.getUniformLocation()，这个方法返回一个对象，表示
Uniform 变量在内存中的位置。然后可以基于变量的位置来赋值。

11. 调试着色器和程序
与 WebGL 中的其他操作一样，着色器操作也可能会失败，而且也是静默失败。如果你想知道着色
器或程序执行中是否发生了错误，必须亲自询问 WebGL 上下文。

12. 绘图
WebGL 只能绘制三种形状：点、线和三角。其他所有形状都是由这三种基本形状合成之后，再绘
制到三维空间中的。执行绘图操作要调用 gl.drawArrays()或 gl.drawElements()方法，前者用于
数组缓冲区，后者用于元素数组缓冲区。
gl.drawArrays()或 gl.drawElements()的第一个参数都是一个常量，表示要绘制的形状。可
取值的常量范围包括以下这些。
- gl.POINTS：将每个顶点当成一个点来绘制。
- gl.LINES：将数组当成一系列顶点，在这些顶点间画线。每个顶点既是起点也是终点，因此数
组中必须包含偶数个顶点才能完成绘制。
- gl.LINE_LOOP：将数组当成一系列顶点，在这些顶点间画线。线条从第一个顶点到第二个顶点，
再从第二个顶点到第三个顶点，依此类推，直至最后一个顶点。然后再从最后一个顶点到第一
个顶点画一条线。结果就是一个形状的轮廓。
- gl.LINE_STRIP：除了不画最后一个顶点与第一个顶点之间的线之外，其他与 gl.LINE_LOOP
相同。
- gl.TRIANGLES：将数组当成一系列顶点，在这些顶点间绘制三角形。除非明确指定，每个三角
形都单独绘制，不与其他三角形共享顶点。
- gl.TRIANGLES_STRIP：除了将前三个顶点之后的顶点当作第三个顶点与前两个顶点共同构成
一个新三角形外，其他都与 gl.TRIANGLES 相同。例如，如果数组中包含 A、 B、 C、 D 四个顶
点，则第一个三角形连接 ABC，而第二个三角形连接 BCD。
- gl. TRIANGLES_FAN：除了将前三个顶点之后的顶点当作第三个顶点与前一个顶点及第一个顶
点共同构成一个新三角形外，其他都与 gl.TRIANGLES 相同。例如，如果数组中包含 A、 B、 C、
D 四个顶点，则第一个三角形连接 ABC，而第二个三角形连接 ACD。

13. 纹理
WebGL 的纹理可以使用 DOM 中的图像。要创建一个新纹理，可以调用 gl.createTexture()，
然后再将一幅图像绑定到该纹理。如果图像尚未加载到内存中，可能需要创建一个 Image 对象的实例，
以便动态加载图像。图像加载完成之前，纹理不会初始化，因此，必须在 load 事件触发后才能设置纹
理。

14. 读取像素
与 2D 上下文 类似，通过 WebGL 上下文也能读取像素值。读取像素值的方法 readPixels()与
OpenGL 中的同名方法只有一点不同，即最后一个参数必须是类型化数组。像素信息是从帧缓冲区读取
的，然后保存在类型化数组中。 readPixels()方法的参数有： x、 y、宽度、高度、图像格式、数据类
型和类型化数组。前 4 个参数指定读取哪个区域中的像素。图像格式参数几乎总是 gl.RGBA。数据类型
参数用于指定保存在类型化数组中的数据的类型，但有以下限制。
- 如果类型是 gl.UNSIGNED_BYTE，则类型化数组必须是 Uint8Array。
- 如果类型是 gl.UNSIGNED_SHORT_5_6_5、gl.UNSIGNED_SHORT_4_4_4_4 或 gl.UNSIGNED_
SHORT_5_5_5_1，则类型化数组必须是 Uint16Array。

### 支持
Firefox 4+和 Chrome 都实现了 WebGL API。 Safari 5.1 也实现了 WebGL，但默认是禁用的。 WebGL
比较特别的地方在于，某个浏览器的某个版本实现了它，并不一定意味着就真能使用它。某个浏览器支
持 WebGL，至少意味着两件事：首先，浏览器本身必须实现了 WebGL API；其次，计算机必须升级显
示驱动程序。运行 Windows XP 等操作系统的一些老机器，其驱动程序一般都不是最新的。因此，这些
计算机中的浏览器都会禁用 WebGL。从稳妥的角度考虑，在使用 WebGL 之前，最好检测其是否得到了
支持，而不是只检测特定的浏览器版本。
大家别忘了， WebGL 还是一个正在制定和发展中的规范。不管是函数名、函数签名，还是数据类
型，都有可能改变。可以说， WebGL 目前只适合实验性地学习，不适合真正开发和应用。

---
# HTML脚本编程

## 跨文档消息传递
跨文档消息传送（cross-document messaging），有时候简称为 XDM，指的是在来自不同域的页面间
传递消息。

XDM 的核心是 postMessage()方法。在 HTML5 规范中，除了 XDM 部分之外的其他部分也会提
到这个方法名，但都是为了同一个目的：向另一个地方传递数据。对于 XDM 而言， “另一个地方”指的
是包含在当前页面中的<iframe>元素，或者由当前页面弹出的窗口。
postMessage()方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二
个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。


## 原生拖放
### 拖放事件
通过拖放事件，可以控制拖放相关的各个方面。其中最关键的地方在于确定哪里发生了拖放事件，
有些事件是在被拖动的元素上触发的，而有些事件是在放置目标上触发的。拖动某元素时，将依次触发
下列事件：
(1) dragstart
(2) drag
(3) dragend
按下鼠标键并开始移动鼠标时，会在被拖放的元素上触发 dragstart 事件。此时光标变成“不能放”
符号（圆环中有一条反斜线），表示不能把元素放到自己上面。拖动开始时，可以通过 ondragstart
事件处理程序来运行 JavaScript 代码。
触发 dragstart 事件后，随即会触发 drag 事件，而且在元素被拖动期间会持续触发该事件。这
个事件与 mousemove 事件相似，在鼠标移动过程中， mousemove 事件也会持续发生。 当拖动停止时（无
论是把元素放到了有效的放置目标，还是放到了无效的放置目标上），会触发 dragend 事件。
上述三个事件的目标都是被拖动的元素。默认情况下，浏览器不会在拖动期间改变被拖动元素的外
观，但你可以自己修改。不过，大多数浏览器会为正被拖动的元素创建一个半透明的副本，这个副本始
终跟随着光标移动。
当某个元素被拖动到一个有效的放置目标上时，下列事件会依次发生：
(1) dragenter
(2) dragover
(3) dragleave 或 drop
只要有元素被拖动到放置目标上，就会触发 dragenter 事件（类似于 mouseover 事件）。紧随其
后的是 dragover 事件，而且在被拖动的元素还在放置目标的范围内移动时，就会持续触发该事件。如
果元素被拖出了放置目标， dragover 事件不再发生，但会触发 dragleave 事件（类似于 mouseout
事件）。如果元素被放到了放置目标中，则会触发 drop 事件而不是 dragleave 事件。上述三个事件的
目标都是作为放置目标的元素。

### 自定义放置目标
在拖动元素经过某些无效放置目标时，可以看到一种特殊的光标（圆环中有一条反斜线），表示不
能放置。虽然所有元素都支持放置目标事件，但这些元素默认是不允许放置的。如果拖动元素经过不允
许放置的元素，无论用户如何操作，都不会发生 drop 事件。不过，你可以把任何元素变成有效的放置
目标，方法是重写 dragenter 和 dragover 事件的默认行为。

### dataTransfer对象
只有简单的拖放而没有数据变化是没有什么用的。为了在拖放操作时实现数据交换， IE 5 引入了
dataTransfer 对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。
因为它是事件对象的属性，所以只能在拖放事件的事件处理程序中访问 dataTransfer 对象。在事件
处理程序中，可以使用这个对象的属性和方法来完善拖放功能。目前， HTML5 规范草案也收入了
dataTransfer 对象。
dataTransfer 对象有两个主要方法： getData()和 setData()。不难想象， getData()可以取
得由 setData()保存的值。 setData()方法的第一个参数，也是 getData()方法唯一的一个参数，是
一个字符串，表示保存的数据类型，取值为"text"或"URL"，

### dropEffect与effectAllowed
利用 dataTransfer 对象，可不光是能够传输数据，还能通过它来确定被拖动的元素以及作为放
置目标的元素能够接收什么操作。为此，需要访问 dataTransfer 对象的两个属性： dropEffect 和
effectAllowed。
其中，通过 dropEffect 属性可以知道被拖动的元素能够执行哪种放置行为。这个属性有下列 4
个可能的值。
- "none"：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。
- "move"：应该把拖动的元素移动到放置目标。
- "copy"：应该把拖动的元素复制到放置目标。
- "link"：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有 URL）。
在把元素拖动到放置目标上时，以上每一个值都会导致光标显示为不同的符号。然而，要怎样实现
光标所指示的动作完全取决于你。换句话说，如果你不介入，没有什么会自动地移动、复制，也不会打
开链接。总之，浏览器只能帮你改变光标的样式，而其他的都要靠你自己来实现。要使用 dropEffect
属性，必须在 ondragenter 事件处理程序中针对放置目标来设置它。
dropEffect 属性只有搭配 effectAllowed 属性才有用。 effectAllowed 属性表示允许拖动元
素的哪种 dropEffect， effectAllowed 属性可能的值如下。
- "uninitialized"：没有给被拖动的元素设置任何放置行为。
- "none"：被拖动的元素不能有任何行为。
- "copy"：只允许值为"copy"的 dropEffect。
- "link"：只允许值为"link"的 dropEffect。
- "move"：只允许值为"move"的 dropEffect。
- "copyLink"：允许值为"copy"和"link"的 dropEffect。
- "copyMove"：允许值为"copy"和"move"的 dropEffect。
- "linkMove"：允许值为"link"和"move"的 dropEffect。
- "all"：允许任意 dropEffect。
必须在 ondragstart 事件处理程序中设置 effectAllowed 属性。

假设你想允许用户把文本框中的文本拖放到一个<div>元素中。首先，必须将 dropEffect 和
effectAllowed 设置为"move"。但是，由于<div>元素的放置事件的默认行为是什么也不做，所以文
本不可能自动移动。重写这个默认行为，就能从文本框中移走文本。然后你就可以自己编写代码将文本
插入到<div>中，这样整个拖放操作就完成了。如果你将 dropEffect 和 effectAllowed 的值设置为
"copy"，那就不会自动移走文本框中的文本。

### 可拖动
默认情况下，图像、链接和文本是可以拖动的，也就是说，不用额外编写代码，用户就可以拖动它
们。文本只有在被选中的情况下才能拖动，而图像和链接在任何时候都可以拖动。
让其他元素可以拖动也是可能的。 HTML5 为所有 HTML 元素规定了一个 draggable 属性，表
示元素是否可以拖动。图像和链接的 draggable 属性自动被设置成了 true，而其他元素这个属性
的默认值都是 false。要想让其他元素可拖动，或者让图像或链接不能拖动，都可以设置这个属性。

### 其他成员
HTML5 规范规定 dataTransfer 对象还应该包含下列方法和属性。
- addElement(element)：为拖动操作添加一个元素。添加这个元素只影响数据（即增加作为拖
动源而响应回调的对象），不会影响拖动操作时页面元素的外观。在写作本书时，只有 Firefox 3.5+
实现了这个方法。
- clearData(format)：清除以特定格式保存的数据。实现这个方法的浏览器有 IE、Fireforx 3.5+、
Chrome 和 Safari 4+。
- setDragImage(element, x, y)：指定一幅图像，当拖动发生时，显示在光标下方。这个方
法接收的三个参数分别是要显示的 HTML 元素和光标在图像中的 x、 y 坐标。其中， HTML 元素
可以是一幅图像，也可以是其他元素。是图像则显示图像，是其他元素则显示渲染后的元素。
实现这个方法的浏览器有 Firefox 3.5+、 Safari 4+和 Chrome。
- types：当前保存的数据类型。这是一个类似数组的集合，以"text"这样的字符串形式保存着
数据类型。实现这个属性的浏览器有 IE10+、 Firefox 3.5+和 Chrome。

## 媒体元素
随着音频和视频在 Web 上的迅速流行，大多数提供富媒体内容的站点为了保证跨浏览器兼容性，
不得不选择使用 Flash。 HTML5 新增了两个与媒体相关的标签，让开发人员不必依赖任何插件就能在网
页中嵌入跨浏览器的音频和视频内容。这两个标签就是<audio>和<video>。
这两个标签除了能让开发人员方便地嵌入媒体文件之外，都提供了用于实现常用功能的 JavaScript
API，允许为媒体创建自定义的控件。这两个元素的用法如下。
```html
<!-- 嵌入视频 -->
<video src="conference.mpg" id="myVideo">Video player not available.</video>
<!-- 嵌入音频 -->
<audio src="song.mp3" id="myAudio">Audio player not available.</audio>
```
使用这两个元素时，至少要在标签中包含 src 属性，指向要加载的媒体文件。还可以设置 width
和 height 属性以指定视频播放器的大小，而为 poster 属性指定图像的 URI 可以在加载视频内容期间
显示一幅图像。另外，如果标签中有 controls 属性，则意味着浏览器应该显示 UI 控件，以便用户直
接操作媒体。位于开始和结束标签之间的任何内容都将作为后备内容，在浏览器不支持这两个媒体元素
的情况下显示。
因为并非所有浏览器都支持所有媒体格式，所以可以指定多个不同的媒体来源。为此，不用在标签
中指定 src 属性，而是要像下面这样使用一或多个<source>元素。

### 属性
<video>和<audio>元素都提供了完善的 JavaScript 接口。下表列出了这两个元素共有的属性，通
过这些属性可以知道媒体的当前状态。

属 性 | 数据类型 | 说 明
--- | --- | ---
autoplay | 布尔值 | 取得或设置autoplay标志
buffered | 时间范围 | 表示已下载的缓冲的时间范围的对象
bufferedBytes | 字节范围 | 表示已下载的缓冲的字节范围的对象
bufferingRate | 整数 | 下载过程中每秒钟平均接收到的位数
bufferingThrottled | 布尔值 | 表示浏览器是否对缓冲进行了节流
controls | 布尔值 | 取得或设置controls属性，用于显示或隐藏浏览器内置的控件
currentLoop | 整数 | 媒体文件已经循环的次数
currentSrc | 字符串 | 当前播放的媒体文件的URL
currentTime | 浮点数 | 已经播放的秒数
defaultPlaybackRate | 浮点数 | 取得或设置默认的播放速度。默认值为1.0秒
duration | 浮点数 | 媒体的总播放时间（秒数）
ended | 布尔值 | 表示媒体文件是否播放完成
loop | 布尔值 | 取得或设置媒体文件在播放完成后是否再从头开始播放
muted | 布尔值 | 取得或设置媒体文件是否静音
networkState | 整数 | 表示当前媒体的网络连接状态： 0表示空， 1表示正在加载， 2表示正在加载元数据， 3表示已经加载了第一帧， 4表示加载完成
paused | 布尔值 | 表示播放器是否暂停
playbackRate | 浮点数 | 取得或设置当前的播放速度。用户可以改变这个值，让媒体播放速度变快或变慢，这与defaultPlaybackRate只能由开发人员修改的defaultPlaybackRate不同
played | 时间范围 | 到目前为止已经播放的时间范围
readyState | 整数 | 表示媒体是否已经就绪（可以播放了）。 0表示数据不可用， 1表示可以显示当前帧， 2表示可以开始播放， 3表示媒体可以从头到尾播放
seekable | 时间范围 | 可以搜索的时间范围
seeking | 布尔值 | 表示播放器是否正移动到媒体文件中的新位置
src | 字符串 | 媒体文件的来源。任何时候都可以重写这个属性
start | 浮点数 | 取得或设置媒体文件中开始播放的位置，以秒表示
totalBytes | 整数 | 当前资源所需的总字节数
videoHeight | 整数 | 返回视频（不一定是元素）的高度。只适用于<video>
videoWidth | 整数 | 返回视频（不一定是元素）的宽度。只适用于<video>
volume | 浮点数 | 取得或设置当前音量，值为0.0到1.0

### 事件
除了大量属性之外，这两个媒体元素还可以触发很多事件。这些事件监控着不同的属性的变化，这
些变化可能是媒体播放的结果，也可能是用户操作播放器的结果。下表列出了媒体元素相关的事件。

事 件 | 触发时机
--- | ---
abort | 下载中断
canplay | 可以播放时； readyState值为2
canplaythrough | 播放可继续，而且应该不会中断； readyState值为3
canshowcurrentframe | 当前帧已经下载完成； readyState值为1
dataunavailable | 因为没有数据而不能播放； readyState值为0
durationchange | duration属性的值改变
emptied | 网络连接关闭
empty | 发生错误阻止了媒体下载
ended | 媒体已播放到末尾，播放停止
error | 下载期间发生网络错误
load | 所有媒体已加载完成。这个事件可能会被废弃，建议使用canplaythrough
loadeddata | 媒体的第一帧已加载完成
loadedmetadata | 媒体的元数据已加载完成
loadstart | 下载已开始
pause | 播放已暂停
play | 媒体已接收到指令开始播放
playing | 媒体已实际开始播放
progress | 正在下载
ratechange | 播放媒体的速度改变
seeked | 搜索结束
seeking | 正移动到新位置
stalled | 浏览器尝试下载，但未接收到数据
timeupdate | currentTime被以不合理或意外的方式更新
volumechange | volume属性值或muted属性值已改变
waiting | 播放暂停，等待下载更多数据

### 自定义媒体播放器
使用<audio>和<video>元素的 play()和 pause()方法，可以手工控制媒体文件的播放。组合使
用属性、事件和这两个方法，很容易创建一个自定义的媒体播放器，如下面的例子所示。
```html
<div class="mediaplayer">
<div class="video">
<video id="player" src="movie.mov" poster="mymovie.jpg"
width="300" height="200">
Video player not available.
</video>
</div>
<div class="controls">
<input type="button" value="Play" id="video-btn">
<span id="curtime">0</span>/<span id="duration">0</span>
</div>
</div>
```
```javascript
//取得元素的引用
var player = document.getElementById("player"),
btn = document.getElementById("video-btn"),
curtime = document.getElementById("curtime"),
duration = document.getElementById("duration");
//更新播放时间
duration.innerHTML = player.duration;
//为按钮添加事件处理程序
EventUtil.addHandler(btn, "click", function(event){
if (player.paused){
player.play();
btn.value = "Pause";
} else {
player.pause();
btn.value = "Play";
}
});
//定时更新当前时间
setInterval(function(){
curtime.innerHTML = player.currentTime;
}, 250);
```

### 检测编解码器的支持情况
如前所述，并非所有浏览器都支持<video>和<audio>的所有编解码器，而这基本上就意味着你必
须提供多个媒体来源。不过，也有一个 JavaScript API 能够检测浏览器是否支持某种格式和编解码器。
这两个媒体元素都有一个 canPlayType()方法，该方法接收一种格式/编解码器字符串，返回
"probably"、 "maybe"或""（ 空字符串）。空字符串是假值，因此可以像下面这样在 if 语句中使用
canPlayType()：
```javascript
if (audio.canPlayType("audio/mpeg")){
//进一步处理
}
```
如果给 canPlayType()传入了一种 MIME 类型，则返回值很可能是"maybe"或空字符串。这是因
为媒体文件本身只不过是音频或视频的一个容器，而真正决定文件能否播放的还是编码的格式。在同时
传入 MIME 类型和编解码器的情况下，可能性就会增加，返回的字符串会变成"probably"。

音 频 | 字 符 串 | 支持的浏览器
--- | --- | ---
AAC | audio/mp4; codecs="mp4a.40.2" | IE9+、 Safari 4+、 iOS版Safari
MP3 | audio/mpeg | IE9+、 Chrome
Vorbis | audio/ogg; codecs="vorbis" | Firefox 3.5+、 Chrome、 Opera 10.5+
WAV | audio/wav; codecs="1" | Firefox 3.5+、 Opera 10.5+、 Chrome
当然，也可以使用 canPlayType()来检测视频格式。下表列出了已知的已得到支持的音频格式和
编解码器。

视 频 | 字 符 串 | 支持的浏览器
--- | --- | ---
H.264 | video/mp4; codecs="avc1.42E01E, mp4a.40.2" | IE9+、 Safari 4+、 iOS版Safari、 Android版WebKit
Theora | video/ogg; codecs="theora" | Firefox 3.5+、 Opera 10.5、 Chrome
WebM | video/webm; codecs="vp8, vorbis" | Firefox 4+、 Opera 10.6、 Chrome

### Audio类型
<audio>元素还有一个原生的 JavaScript 构造函数 Audio，可以在任何时候播放音频。从同为 DOM
元素的角度看， Audio 与 Image 很相似，但 Audio 不用像 Image 那样必须插入到文档中。只要创建一
个新实例，并传入音频源文件即可。
```javascript
var audio = new Audio("sound.mp3");
EventUtil.addHandler(audio, "canplaythrough", function(event){
audio.play();
})
```
## 历史状态管理
历史状态管理是现代 Web 应用开发中的一个难点。在现代 Web 应用中，用户的每次操作不一定会
打开一个全新的页面，因此“后退”和“前进”按钮也就失去了作用，导致用户很难在不同状态间切换。
要解决这个问题，首选使用 hashchange 事件（第 13 章曾讨论过）。 HTML5 通过更新 history 对象为
管理历史状态提供了方便。
通过 hashchange 事件，可以知道 URL 的参数什么时候发生了变化，即什么时候该有所反应。而
通 过 状 态 管 理 API ， 能 够 在 不 加 载 新 页 面 的 情 况 下 改 变 浏 览 器 的 URL 。 为 此 ， 需 要 使 用
history.pushState()方法，该方法可以接收三个参数：状态对象、新状态的标题和可选的相对 URL。
```javascript
history.pushState({name:"Nicholas"}, "Nicholas' page", "nicholas.html");
```
执行 pushState()方法后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的
相对 URL。但是，浏览器并不会真的向服务器发送请求，即使状态改变之后查询 location.href 也会
返回与地址栏中相同的地址。另外，第二个参数目前还没有浏览器实现，因此完全可以只传入一个空字
符串，或者一个短标题也可以。而第一个参数则应该尽可能提供初始化页面状态所需的各种信息。
因为 pushState()会创建新的历史状态，所以你会发现“后退”按钮也能使用了。按下“后退”
按钮，会触发 window 对象的 popstate 事件①。 popstate 事件的事件对象有一个 state 属性，这个
属性就包含着当初以第一个参数传递给 pushState()的状态对象。
```javascript
EventUtil.addHandler(window, "popstate", function(event){
var state = event.state;
if (state){ //第一个页面加载时 state 为空
processState(state);
}
});
```

---
# 错误处理与调试
## 浏览器报告的错误
IE、 Firefox、 Safari、 Chrome 和 Opera 等主流浏览器，都具有某种向用户报告 JavaScript 错误的机
制。默认情况下，所有浏览器都会隐藏此类信息，毕竟除了开发人员之外，很少有人关心这些内容。
因此，在基于浏览器编写 JavaScript 脚本时，别忘了启用浏览器的 JavaScript 报告功能，以便及时收到
错误通知。

### IE
IE 是唯一一个在浏览器的界面窗体（chrome）中显示 JavaScript 错误信息的浏览器。在发生 JavaScript
错误时，浏览器左下角会出现一个黄色的图标，图标旁边则显示着"Error on page"（页面中有错误）。
假如不是存心去看的话，你很可能不会注意这个图标。双击这个图标，就会看到一个包含错误消息的对
话框，其中还包含诸如行号、字符数、错误代码及文件名（其实就是你在查看的页面的 URL）等相关信
息。
这些信息对于一般用户还算说得过去，但对 Web 开发来说就远远不够了。可以通过设置让错误对
话框一发生错误就显示出来。为此，要打开“Tools”（工具）菜单中的“Internet Options”（Internet 选项）
对话框，切换到“Advanced”（高级）选项卡，选中“Display a notification about every script error”（显
示每个脚本错误的通知）复选框（参见图 17-2）。单击“OK”（确定）按钮保存设置。

### Firefox
默认情况下， Firefox 在 JavaScript 发生错误时不会通过浏览器界面给出提示。但它会在后台将错误
记录到错误控制台中。单击“Tools”（工具）菜单中的“Error Console”（错误控制台）可以显示错误控
制台。你会发现，错误控制台中实际上还包含与 JavaScript、 CSS 和 HTML 相关的警告和
信息，可以通过筛选找到错误。
在发生 JavaScript 错误时， Firefox 会将其记录为一个错误，包括错误消息、引发错误的 URL 和错误
所在的行号等信息。单击文件名即可以只读方式打开发生错误的脚本，发生错误的代码行会突出显示。
目前，最流行的 Firefox 插件 Firebug，已经成为开发人员必备的 JavaScript 纠错工具。这个可以从
www.getfirebug.com 下载到的插件，会在 Firefox 状态栏的右下角区域添加一个图标。默认情况下，右下
角区域显示的是一个绿色对勾图标。在有 JavaScript 错误发生时，图标会变成红叉，同时旁边显示错误
的数量。单击这个红叉会打开 Firebug 控制台，其中显示有错误消息、错误所在的代码行（不包含上下
文）、错误所在的 URL 以及行号。

### Safari
Windows 和 Mac OS 平台的 Safari 在默认情况下都会隐藏全部 JavaScript 错误。为了访问到这些信
息，必须启用“Develop”（开发）菜单。为此，需要单击“Edit”（编辑）菜单中的“Preferences”（偏
好设置），然后在“Advanced”（高级）选项卡中，选中“Show develop menu in menubar”（在菜单栏中
显示“开发”菜单）。启用此项设置之后，就会在 Safari 的菜单栏中看到一个“Develop”菜单。

### Opera
Opera 在默认情况下也会隐藏 JavaScript 错误，所有错误都会被记录到错误控制台中。要打开错误
控制台，需要单击“Tools”（工具）菜单，在“Advanced”（高级）子菜单项下面再单击“Error Console”
（错误控制台）。与 Firefox 一样， Opera 的错误控制台中也包含了除 JavaScript 错误之外的很多来源（如
HTML、 CSS、 XML、 XSLT 等）的错误和警告信息。要分类查看不同来源的消息，可以使用左下角的
下拉选择框。

### Chrome
与 Safari 和 Opera 一样， Chrome 在默认情况下也会隐藏 JavaScript 错误。所有错误都将被记录到
Web Inspector 控制台中。要查看错误消息，必须打开 Web Inspector。为此，要单击位于地址栏右侧的
“Control this page”（控制当前页）按钮， 选择“Developer”（开发人员）、“JavaScript console”（JavaScript
控制台）。

## 错误处理
错误处理在程序设计中的重要性是勿庸置疑的。任何有影响力的 Web 应用程序都需要一套完善的
错误处理机制，当然，大多数佼佼者确实做到了这一点，但通常只有服务器端应用程序才能做到如此。
实际上，服务器端团队往往会在错误处理机制上投入较大的精力，通常要考虑按照类型、频率，或者其
他重要的标准对错误进行分类。这样一来，开发人员就能够理解用户在使用简单数据库查询或者报告生
成脚本时，应用程序可能会出现的问题。
虽然客户端应用程序的错误处理也同样重要，但真正受到重视，还是最近几年的事。实际上，我们
要面对这样一个不争的事实：使用 Web 的绝大多数人都不是技术高手，其中甚至有很多人根本就不明
白浏览器到底是什么，更不用说让他们说喜欢哪一个了。本章前面讨论过，每个浏览器在发生 JavaScript
错误时的行为都或多或少有一些差异。有的会显示小图标，有的则什么动静也没有，浏览器对 JavaScript
错误的这些默认行为对最终用户而言，毫无规律可循。最理想的情况下，用户遇到错误搞不清为什么，
他们会再试着重做一次；最糟糕的情况下，用户会恼羞成怒，一去不复返了。良好的错误处理机制可以
让用户及时得到提醒，知道到底发生了什么事，因而不会惊惶失措。为此，作为开发人员，我们必须理
解在处理 JavaScript 错误的时候，都有哪些手段和工具可以利用。

### try-catch语句
ECMA-262 第 3 版引入了 try-catch 语句，作为 JavaScript 中处理异常的一种标准方式。基本的语
法如下所示，显而易见，这与 Java 中的 try-catch 语句是完全相同的。
```javascript
try{
// 可能会导致错误的代码
} catch(error){
// 在错误发生时怎么处理
}
```
也就是说，我们应该把所有可能会抛出错误的代码都放在 try 语句块中，而把那些用于错误处理的
代码放在 catch 块中。
```javascript
try {
window.someNonexistentFunction();
} catch (error){
alert("An error happened!");
}
```
如果 try 块中的任何代码发生了错误，就会立即退出代码执行过程，然后接着执行 catch 块。此
时， catch 块会接收到一个包含错误信息的对象。与在其他语言中不同的是，即使你不想使用这个错误
对象，也要给它起个名字。这个对象中包含的实际信息会因浏览器而异，但共同的是有一个保存着错误
消息的 message 属性。 ECMA-262 还规定了一个保存错误类型的 name 属性；当前所有浏览器都支持这
个属性（Opera 9 之前的版本不支持这个属性）。因此，在发生错误时，就可以像下面这样实事求是地显
示浏览器给出的消息。

1. finally子句
虽然在 try-catch 语句中是可选的，但 finally 子句一经使用，其代码无论如何都会执行。换句
话说， try 语句块中的代码全部正常执行， finally 子句会执行；如果因为出错而执行了 catch 语句
块， finally 子句照样还会执行。只要代码中包含 finally 子句，则无论 try 或 catch 语句块中包
含什么代码——甚至 return 语句，都不会阻止 finally 子句的执行。来看下面这个函数。

2. 错误类型
执行代码期间可能会发生的错误有多种类型。每种错误都有对应的错误类型，而当错误发生时，就
会抛出相应类型的错误对象。 ECMA-262 定义了下列 7 种错误类型：
- Error
- EvalError
- RangeError
- ReferenceError
- SyntaxError
- TypeError
- URIError
其中， Error 是基类型，其他错误类型都继承自该类型。因此，所有错误类型共享了一组相同的属
性（错误对象中的方法全是默认的对象方法）。 Error 类型的错误很少见，如果有也是浏览器抛出的；
这个基类型的主要目的是供开发人员抛出自定义错误。
EvalError 类型的错误会在使用 eval()函数而发生异常时被抛出。 ECMA-262 中对这个错误有如
下描述：“如果以非直接调用的方式使用 eval 属性的值（换句话说，没有明确地将其名称作为一个
Identifier，即用作 CallExpression 中的 MemberExpression），或者为 eval 属性赋值。”简单
地说，如果没有把 eval()当成函数调用，就会抛出错误。

3. 合理使用try-catch
当 try-catch 语句中发生错误时，浏览器会认为错误已经被处理了，因而不会通过本章前面讨论
的机制记录或报告错误。对于那些不要求用户懂技术，也不需要用户理解错误的 Web 应用程序，这应
该说是个理想的结果。不过， try-catch 能够让我们实现自己的错误处理机制。
使用 try-catch 最适合处理那些我们无法控制的错误。假设你在使用一个大型 JavaScript 库中的
函数，该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码，所以大可将对该函
数的调用放在 try-catch 语句当中，万一有什么错误发生，也好恰当地处理它们。
在明明白白地知道自己的代码会发生错误时，再使用 try-catch 语句就不太合适了。例如，如果
传递给函数的参数是字符串而非数值，就会造成函数出错，那么就应该先检查参数的类型，然后再决定
如何去做。在这种情况下，不应用使用 try-catch 语句。

### 抛出错误
与 try-catch 语句相配的还有一个 throw 操作符，用于随时抛出自定义错误。抛出错误时，必须
要给 throw 操作符指定一个值，这个值是什么类型，没有要求。

1. 抛出错误的时机
要针对函数为什么会执行失败给出更多信息，抛出自定义错误是一种很方便的方式。应该在出现某
种特定的已知错误条件，导致函数无法正常执行时抛出错误。换句话说，浏览器会在某种特定的条件下
执行函数时抛出错误。

2. 抛出错误与使用try-catch
关于何时该抛出错误，而何时该使用 try-catch 来捕获它们，是一个老生常谈的问题。一般来说，
应用程序架构的较低层次中经常会抛出错误，但这个层次并不会影响当前执行的代码，因而错误通常得
不到真正的处理。如果你打算编写一个要在很多应用程序中使用的 JavaScript 库，甚至只编写一个可能
会在应用程序内部多个地方使用的辅助函数，我都强烈建议你在抛出错误时提供详尽的信息。然后，即
可在应用程序中捕获并适当地处理这些错误。
说到抛出错误与捕获错误，我们认为只应该捕获那些你确切地知道该如何处理的错误。捕获错误的
目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。

### 错误（error）事件
任何没有通过 try-catch 处理的错误都会触发 window 对象的 error 事件。这个事件是 Web 浏览
器最早支持的事件之一， IE、 Firefox 和 Chrome 为保持向后兼容，并没有对这个事件作任何修改（Opera
和 Safari 不支持 error 事件）。在任何 Web 浏览器中， onerror 事件处理程序都不会创建 event 对象，
但它可以接收三个参数：错误消息、错误所在的 URL 和行号。多数情况下，只有错误消息有用，因为
URL 只是给出了文档的位置，而行号所指的代码行既可能出自嵌入的 JavaScript 代码，也可能出自外部
的文件。要指定 onerror 事件处理程序，必须使用如下所示的 DOM0 级技术，它没有遵循“DOM2 级
事件”的标准格式。

### 处理错误的策略
过去，所谓 Web 应用程序的错误处理策略仅限于服务器端。在谈到错误与错误处理时，通常要考
虑很多方面，涉及一些工具，例如记录和监控系统。这些工具的用途在于分析错误模式，追查错误原因，
同时帮助确定错误会影响到多少用户。
在 Web 应用程序的 JavaScript 这一端，错误处理策略也同样重要。由于任何 JavaScript 错误都可能
导致网页无法使用，因此搞清楚何时以及为什么发生错误至关重要。绝大多数 Web 应用程序的用户都
不懂技术，遇到错误时很容易心烦意乱。有时候，他们可能会刷新页面以期解决问题，而有时候则会放
弃努力。作为开发人员，必须要知道代码何时可能出错，会出什么错，同时还要有一个跟踪此类问题的
系统。

### 常见的错误类型
错误处理的核心，是首先要知道代码里会发生什么错误。由于 JavaScript 是松散类型的，而且也不
会验证函数的参数，因此错误只会在代码运行期间出现。一般来说，需要关注三种错误：
- 类型转换错误
- 数据类型错误
- 通信错误
以上错误分别会在特定的模式下或者没有对值进行足够的检查的情况下发生。

1. 类型转换错误
类型转换错误发生在使用某个操作符，或者使用其他可能会自动转换值的数据类型的语言结构时。
在使用相等（==）和不相等（!=）操作符，或者在 if、 for 及 while 等流控制语句中使用非布尔值时，
最常发生类型转换错误。
由于在非动态语言中，
开发人员都使用相同的符号执行直观的比较， 因此在 JavaScript 中往往也会以相同方式错误地使用它们。
多数情况下，我们建议使用全等（===）和不全等（!==）操作符，以避免类型转换。

2. 数据类型错误
JavaScript 是松散类型的，也就是说，在使用变量和函数参数之前，不会对它们进行比较以确保它
们的数据类型正确。为了保证不会发生数据类型错误，只能依靠开发人员编写适当的数据类型检测代码。
在将预料之外的值传递给函数的情况下，最容易发生数据类型错误。

3. 通信错误
着 Ajax 编程的兴起（第 21 章讨论 Ajax）， Web 应用程序在其生命周期内动态加载信息或功能，
已经成为一件司空见惯的事。不过， JavaScript 与服务器之间的任何一次通信，都有可能会产生错误。
第一种通信错误与格式不正确的 URL 或发送的数据有关。最常见的问题是在将数据发送给服务器
之前，没有使用 encodeURIComponent()对数据进行编码。
 另外，在服务器响应的数据不正确时，也会发生通信错误。
 
### 区分致命错误和非致命错误
任何错误处理策略中最重要的一个部分，就是确定错误是否致命。对于非致命错误，可以根据下列
一或多个条件来确定：
- 不影响用户的主要任务；
- 只影响页面的一部分；
- 可以恢复；
- 重复相同操作可以消除错误。
本质上，非致命错误并不是需要关注的问题。例如， Yahoo! Mail（http://mail.yahoo.com）有一项功
能，允许用户在其界面上发送手机短信。如果由于某种原因，发不了手机短信了，那也不算是致命错误，
因为并不是应用程序的主要功能有问题。用户使用 Yahoo! Mail 主要是为了查收和撰写电子邮件。只在
这个主要功能正常，就没有理由打断用户。没有必要因为发生了非致命错误而对用户给出提示——可以
把页面中受到影响的区域替换掉，比如替换成说明相应功能无法使用的消息。但是，如果因此打断用户，
那确实没有必要。
致命错误，可以通过以下一或多个条件来确定：
- 应用程序根本无法继续运行；
- 错误明显影响到了用户的主要操作；
- 会导致其他连带错误。

### 把错误记录到服务器
开发 Web 应用程序过程中的一种常见的做法，就是集中保存错误日志，以便查找重要错误的原因。
在复杂的 Web 应用程序
中，我们同样推荐你把 JavaScript 错误也回写到服务器。换句话说，也要将这些错误写入到保存服务器
端错误的地方，只不过要标明它们来自前端。把前后端的错误集中起来，能够极大地方便对数据的分析。
要建立这样一种 JavaScript 错误记录系统，首先需要在服务器上创建一个页面（或者一个服务器入
口点），用于处理错误数据。这个页面的作用无非就是从查询字符串中取得数据，然后再将数据写入错
误日志中。

## 调试技术
### 将消息记录到控制台
IE8、 Firefox、 Opera、 Chrome 和 Safari 都有 JavaScript 控制台，可以用来查看 JavaScript 错误。而
且，在这些浏览器中，都可以通过代码向控制台输出消息。对 Firefox 而言，需要安装 Firebug
（www.getfirebug.com），因为 Firefox 要使用 Firebug 的控制台。对 IE8、 Firefox、 Chrome 和 Safari 来说，
则可以通过 console 对象向 JavaScript 控制台中写入消息，这个对象具有下列方法。
- error(message)：将错误消息记录到控制台
- info(message)：将信息性消息记录到控制台
- log(message)：将一般消息记录到控制台
- warn(message)：将警告消息记录到控制台
在 IE8、 Firebug、 Chrome 和 Safari 中，用来记录消息的方法不同，控制台中显示的错误消息也不
一样。错误消息带有红色图标，而警告消息带有黄色图标。
还有一种方案是使用 LiveConnect，也就是在 JavaScript 中运行 Java 代码。 Firefox、 Safari 和 Opera
都支持 LiveConnect，因此可以操作 Java 控制台。

### 将消息记录到当前页面
另一种输出调试消息的方式，就是在页面中开辟一小块区域，用以显示消息。这个区域通常是一个
元素，而该元素可以总是出现在页面中，但仅用于调试目的；也可以是一个根据需要动态创建的元素。
```javascript
function log(message){
var console = document.getElementById("debuginfo");
if (console === null){
console = document.createElement("div");
console.id = "debuginfo";
console.style.background = "#dedede";
console.style.border = "1px solid silver";
console.style.padding = "5px";
console.style.width = "400px";
console.style.position = "absolute";
console.style.right = "0px";
console.style.top = "0px";
document.body.appendChild(console);
}
console.innerHTML += "<p>" + message + "</p>";
}
```
### 抛出错误
如前所述，抛出错误也是一种调试代码的好办法。如果错误消息很具体，基本上就可以把它当作确
定错误来源的依据。但这种错误消息必须能够明确给出导致错误的原因，才能省去其他调试操作。



## 常见的IE错误
多年以来， IE 一直都是最难于调试 JavaScript 错误的浏览器。 IE 给出的错误消息一般很短又语焉不
详，而且上下文信息也很少，有时甚至一点都没有。但作为用户最多的浏览器，如何看懂 IE 给出的错
误也是最受关注的。下面几小节将分别探讨一些在 IE 中难于调试的 JavaScript 错误。

### 操作终止
在 IE8 之前的版本中，存在一个相对于其他浏览器而言，最令人迷惑、讨厌，也最难于调试的错误：
操作终止（operation aborted）。在修改尚未加载完成的页面时，就会发生操作终止错误。发生错误时，
会出现一个模态对话框，告诉你“操作终止。”单击确定（OK）按钮，则卸载整个页面，继而显示一张
空白屏幕；此时要进行调试非常困难。

### 无效字符
根据语法， JavaScript 文件必须只包含特定的字符。在 JavaScript 文件中存在无效字符时， IE 会抛出
无效字符（invalid character）错误。所谓无效字符，就是 JavaScript 语法中未定义的字符。例如，有一
个很像减号但却由 Unicode 值 8211 表示的字符（\u2013），就不能用作常规的减号（ASCII 编码为 45），
因为 JavaScript 语法中没有定义该字符。这个字符通常是在 Word 文档中自动插入的。如果你的代码是
从 Word 文档中复制到文本编辑器中，然后又在 IE 中运行的，那么就可能会遇到无效字符错误。其他浏
览器对无效字符做出的反应与 IE 类似， Firefox 会抛出非法字符（illegal character）错误， Safari 会报告
发生了语法错误，而 Opera 则会报告发生了 ReferenceError（引用错误），因为它会将无效字符解释
为未定义的标识符。

### 未找到成员
### 位置运行时错误
### 语法错误
### 系统无法找到指定资源


---
# JavaScript与XML
## 浏览器对XML DOM的支持
### DOM2级核心
### DOMParser类型
### XMLSerializer类型
### IE8及之前版本中的XML
### 跨浏览器处理XML


## 浏览器对XPath的支持
### DOM3级XPath
### IE中的XPath
### 跨浏览器使用XPath


## 浏览器对XSLT的支持
### IE中的XSLT
### XSLTProcessor类型
### 跨浏览器使用XSLT


---
# E4X
## E4X的类型
### XML类型
### XMLList类型
### Namespace类型
### QName类型


## 一般用法
### 访问特性
### 其他节点类型
### 查询
### 构建和操作XML
### 解析和序列化
### 命名空间


## 其他变化



## 全面启用E4X




---
# JSON
## 语法
### 简单值
### 对象
### 数组



## 解析与序列化
### JSON对象
### 序列化选项
### 解析选项

---
# Ajax与Comet
## XMLHttpRequest对象
### XHR的用法
### HTTP头部信息
### GET请求
### POST请求


## XMLHttpRequest2级
### FormData
### 超时设定
### overrideMimeType()方法


## 进度事件
### load事件
### progress事件

## 跨源资源共享
### IE对CORS的实现
### 其他浏览器对CORS的实现
### Prefighted Requests
### 带凭据的请求
### 跨浏览器的CORS


## 其他跨域技术
### 图像Ping
### JSONP
### Comet
### 服务器发送事件
### Web Sockets
### SSE与Web Sockets


## 安全

---
# 高级技巧
## 高级函数
### 安全的类型检测
### 作用域安全的构造函数
### 惰性载入函数
### 函数绑定
### 函数柯里化


## 防篡改对象
### 不可扩展对象
### 密封的对象
### 冻结的对象


## 高级定时器
### 重复的定时器
### Yielding Processes
### 函数节流


## 自定义事件



## 拖放
### 修缮拖动功能
### 添加自定义事件

---
# 离线应用于客户端存储
## 离线检测



## 应用缓存



## 数据存储
### Cookie
### IE用户数据
### Web存储机制
### IndexedDB


---
# 最佳实践
## 可维护性
### 什么是可维护的代码
### 代码约定
### 松散耦合
### 编程实践


## 性能
### 注意作用域
### 选择正确方法
### 最小化语句数
### 优化DOM交互


## 部署
### 构建过程
### 验证
### 压缩

---
# 新兴的API
## requestAnimatonFrame()
### 早起动画循环
### 循环间隔的问题
### mozRequestAnimatonFrame
### webkitRequestAnimatonFrame与msRequestAnimatonFrame


## Page Visibility API



## Geolocation API



## File API
### FileReader类型
### 读取部分内容
### 对象URL
### 读取拖放的文件
### 使用XHR上传文件


## Web计时


## Web Workers
### 使用Worker
### Worker全局作用域
### 包含其他脚本
### Web Worker的未来