[TOC]

《JavaScript高级程序设计（第三版）》读书笔记
# 简介
一个完整的JavaScript实现由三部分组成：
- 核心(ECMAScript)
- 文档对象模型(DOM)
- 浏览器对象模型(BOM)

1. ECMAScript规定的内容：
- 语法
- 类型
- 语句
- 关键字
- 保留字
- 操作符
- 对象

2. 文档对象模型(DOM)
文档对象模型(DOM，Document Object Model)是针对XML但经过扩展用于HTML的应用程序编程接口(API，Application Programming Interface)。

    1. DOM级别：
    DOM1级由两个模块组成：DOM核心和DOM HTML。其中DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。\
    DOM2级引入以下模块：
    - DOM视图：定义了跟踪不同文档(例如，应用CSS之前和之后的文档)视图的接口；
    - DOM事件：定义了事件和事件处理的接口；
    - DOM样式：定义了基于CSS为元素应用样式的接口；
    - DOM遍历和视图：定义了遍历和操作文档树的接口；
    
    DOM3引入了以统一方式加载和保存文档的方法——在DOM加载和保存模块中定义；新增了验证文档的方法——在DOM验证模块中定义。
      
    2. 其他DOM标准
    除了DOM核心和DOM HTML接口之外，另外几种语言还发布了只针对自己的DOM标准。
    - SVG(可伸缩矢量图)1.0
    - MathML(数学标记语言)1.0
    - SMIL(同步多媒体集成语言)
    
    3. Web浏览器对DOM的支持
3. 浏览器对象模型(BOM)
---
# 在HTML中使用JavaScript

1. `<script>`元素
向HTML页面插入JavaScript的主要方法，HTML4.01为`<script>`定义了下列6个属性：
- async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效。
- charset：可选。表示通过src属性指定的代码的字符集。（大多数浏览器会忽略该值）
- defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。
- language：已废弃。
- src：可选。表示包含要执行代码的外部文件（如果需要包含JavaScript文件，则src属性就是必需的）。
- type：可选。可看做language的替代属性；表示编写代码使用脚本语言的内容类型（也称为MIME类型）。
    1. 标签的位置：现代Web应用程序一般都把全部JavaScript引用放在`<body>`元素中页面内容的后面。
    2. 延迟脚本：defer属性是表明脚本在执行时不会影响页面的构造。脚本被延迟到整个页面都解析完毕后再运行。defer属性只适用于外部脚本文件。
    3. 异步脚本：async脚本同样只用于外部脚本文件。
    4. 在XHTML中的用法：HTML的代码块在XHTML中无法正常识别，因为<在XHTML中被当做开始的新标签来解析。避免在XHTML中出现类似语法错误的方法有两个。一个是用相应的HTML实体(&lt替换<)；一个是用一个CDATA片段包含JavaScript代码`<script><![CDATA[代码片段]]></script>`

2. 嵌入外部代码与外部文件
- 可维护性：遍历不同HTML页面的JavaScript会造成维护问题。但把所有JavaScript文件都放在一个文件夹中，维护就方便多了。
- 可缓存：浏览器能够根据具体的设置缓存链接的所有外部JavaScript文件。
- 适应未来：通过外部文件来包含JavaScript无须使用前面提到XHTML或者注释hack。

3. 文档模式
混合模式（quirks mode）
标准模式（standards mode）：
```html
<!-- HTML 4.01严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3c.org/TR/html4/strict.dtd">
<!-- XHTML 1.0严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3c.org/TR/xhtml/DTD/XHTML-strict.dtd">
<!-- HTML 5 -->
<!DOCTYPE HTML>
```
对于标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发。
4. `<noscript>`模式
- 浏览器不支持脚本
- 浏览器支持脚本，但脚本被禁用

---
# 基本概念
## 语法
### 区分大小写

### 标识符
所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。格式规则为：
- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
- 其他字符可以是字母、下划线、美元符号或数字。
- 不能把关键字、保留字、true、false和null用作标识符。

### 注释
ECMAScript使用C风格的注释，包括单行注释和块级注释。单行注释以两个斜杠开头。
块级注释以一个斜杠和一个星号（/*）开头，以一个星号和一个斜杠（*/）结尾。
```html
// 单行注释
/*
* 这是一个多行
* （块级）注释
*/
```

### 严格模式
```js
"use strict"
```
看起来是字符串，也没有赋值给任何变量，其实是一个编译指令。

### 语句
以分号结尾；如果省略分号，则由解释器确定语句的结尾。

## 关键字和保留字
```
abstract
boolean break byte
case catch char class const continue
debugger default delete do double 
else enum export extends
false final finally float for function
goto
if implements import in instanceof int interface
long let
native new null
package private protected public
return
short static super switch synchronized
this throw throws transient true try typeof
var volatile void
while with
yield
```


## 变量
用var操作符定义的变量将成为定义该变量的作用域中的局部变量。

## 数据类型
ECMAScript中有5种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number、String。一种复杂数据类型：Object

### typeof操作符

对一个值使用typeof操作符返回下列某个字符串：

- "undefined"——如果这个值未定义；
- "boolean"——如果这个值是布尔值；
- "string"——如果这个值是字符串；
- "number"——如果这个值是数值；
- "object"——如果这个值是对象或null；
- "function"——如果这个值是函数。
typeof操作符的操作数可以是变量，也可以是数值字面量。\
typeof是一个操作符而不是函数

### Undefined类型
Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。

### Null类型
Null类型只有一个值，即特殊的null。null值表示一个空对象指针。
实际上，undefined值是派生自null值，因此对它们进行相等性测试返回true。
```js
alert(undefined == null); // true
alert(undefined === null); // false
```
### Boolean类型
Boolean类型只有两个字面值：true和false。区分大小写。这两个值与数字值不是一回事，true不一定等于1，false不一定等于0.
ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()。

数据类型 | 转换为true的值 | 转换为false的值
--- | --- | ---
Boolean | true | false
String | 任何非空字符串 | ""(空字符串)
Number | 任何非零数字值(包括无穷大) | 0 和NaN
Object | 任何对象 | null
Undefined | n/a(不适用) | undefined

### Number类型
最基本的数值字面量格式是十进制整数。整数还可以通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。\
其中，八进制字面量的第一位必须是零(0)，然后是八进制数字序列。十六进制字面值的前两位必须是0x，后跟任何十六进制数字(0-9及A-F)。
1. 浮点数值
所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。\
对于极大或极小的数值，可以用e表示法(即科学计数法)表示的浮点数值表示。
2. 数值范围
ECMAScript能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在Number_MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308.
3. NaN
NaN,即非数值是一个特殊的数值。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。
NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作都会返回NaN；其次，NaN与任何值都不相等，包括NaN本身。

4. 数值转换
Number()可用于任何数据类型，其转换规则如下：
- 如果是Boolean值，true和false将分别被转换为1和0；
- 如果是数字值，只是简单的传入和返回；
- 如果是null值，返回0；
- 如果是undefined，返回NaN;
- 如果是字符串，遵循以下规则：
    - 如果字符串中只包含数字，则将其转换为十进制数值；
    - 如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值；
    - 如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值；
    - 如果字符产是空的（不包含任何字符），则将其转换为0；
    - 如果字符串中包含除上述格式之外的字符，则将其转换为NaN.
- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN,则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

parseInt()函数在转换字符串时，会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN;如果第一个字符是数字字符，则继续解析直到解析完或者遇到非数字字符。（小数点不是有效的数字字符）
parseInt提供第二个参数，转换时使用的基数（即多少进制）。

parseFloat()函数只解析十进制。

### String类型
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号(")或单引号(')表示。

1. 字符串变量
String数据类型包含一些特殊的字符字面量，也叫转义序列。

字面量 | 含义
--- | ---
`\n` | 换行
`\t` | 制表
`\b` | 退格
`\r` | 回车
`\f` | 进纸
`\\` | 斜杠
`\'` | 单引号(')，在用单引号表示的字符串中使用。
`\"` | 双引号(")，在用双引号表示的字符串中使用。
`\xnn` | 以十六进制代码nn表示的一个字符（其中n为0-F）。
`\unnnn` | 以十六进制代码nnnn表示的一个Unicode字符（其中n为0-F）。

2. 字符串的特点
ECMAScript中字符串是不可变的。

3. 转换为字符串
第一种是使用几乎每个值都有的toString()方法（null和undefined除外）。该方法可以不传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。
第二种是String()，不知道转型的值是不是null和undefined时使用，转换规则如下：
- 如果值有toString()方法，则调用该方法并返回相应的结果；
- 如果值是null，则返回"null"；
- 如果值是undefined，则返回"undefined"。

### Object类型
ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。
Object的每个实例都具有下列属性和方法。
- constructor：保存着用于创建当前对象的函数。
- hasOwnproperty(propertyName)：用于检查给定属性在当前对象实例中（而不是在实例的原型中）是否存在。
- isPrototypeOf：用于检查传入的对象是否是传入对象的原型。
- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString()：返回对象的字符串表示。
- valueOf()：返回对象的字符串、数值或布尔值表示。

## 操作符
### 一元操作符
只能操作一个值的操作符叫做***一元操作符***。
1. 递增和递减操作符：前置型和后置型
2. 一元加和减操作符：表示正负

### 位操作符
位操作符用于最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript中所有数值都以IEEE-754 64
位格式储存，即位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再转换回64位

对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表述数值的符号：0表示正数，1表示负数。
正数以纯二进制格式存储。负数同样以二进制码存储，但使用的格式是二进制补码。
1. 按位非（NOT）
按位非操作符有一个波浪线（~）表示，执行按位非的结果就是返回数值的反码（操作数的负数减1）。

2. 按位与（AND）
按位与操作符由一个和号字符（&）表示，它有两个操作符数。按位与操作就是将两个数值的每一位对齐，
然后根据下表中的规则，对相同位置上的两个数执行AND操作：

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
1 | 1 | 1
1 | 0 | 0
0 | 1 | 0
0 | 0 | 0

3. 按位或（OR）
按位或操作符由一个竖线符号（|）表示，有两个操作数。按位或操作遵循下面这个真假表。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
1 | 1 | 1
1 | 0 | 1
0 | 1 | 1
0 | 0 | 0

4. 按位异或（XOR）
按位异或操作符由一个插入符号（^）表示，也是两个操作数。以下是按位异或的真假值。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
1 | 1 | 0
1 | 0 | 1
0 | 1 | 1
0 | 0 | 0

5. 左移
左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。

6. 有符号的右移
有符号的右移操作符由两个小于号（>>）表示，这个操作符会将数值的所有位向右移动，但保留符号位（即正负号标记）。

7. 无符号右移
无符号的右移操作符由三个小于号（>>>）表示，这个操作符会将数值的所有32都位向右移动。


### 布尔操作符
布尔操作符一共有3个：非（NOT）、与（AND）和或（OR）
1. 逻辑非
逻辑非操作符由一个叹号（！）表示，可以应用于ECMAScript中的任何值。逻辑非操作符遵循下列规则：
- 如果操作数是一个对象，返回false；
- 如果操作数是一个空字符串，返回true；
- 如果操作数是一个非空字符串，返回false；
- 如果操作数是数值0，返回true；
- 如果操作数是任意非0数值（包括Infinity），返回false；
- 如果操作数是null，返回true；
- 如果操作数是NaN，返回true；
- 如果操作数是undefined，返回true。

2. 逻辑与
逻辑与操作符由两个和号（&&）表示，有两个操作数。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
true | true | true
true | false | false
false | true | false
false | false | false

3. 逻辑或
逻辑或操作符由两个和号（||）表示，有两个操作数。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
true | true | true
true | false | true
false | true | true
false | false | false

### 乘性操作符
ECMAScript定义了3个乘性操作符：乘法、除法和求模。
1. 乘法
乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。遵循下列特殊的规则：
- 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，
而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了数值的表示范围，则返回Infinity或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity与0相乘，则结果是NaN;
- 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
- 如果是Infinity与Infinity相乘，则结果是Infinity；
- 如果有一个操作符不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

2. 除法
除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算。遵循下列特殊的规则：
- 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相乘的结果还是正数，
而如果只有一个操作数有符号，那么结果就是负数。如果商超过了数值的表示范围，则返回Infinity或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity被Infinity除，则结果是NaN;
- 如果是零被零除，则结果是NaN;
- 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
- 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

3. 求模
求模（余数）操作符由一个百分号（%）表示，规则如下：
- 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
- 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN;
- 如果被除数是有限大的数值而除数是零，则结果是NaN;
- 如果是Infinity被Infinity除，则结果是NaN;
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
- 如果被除数是零，则结果是零；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

### 加性操作符
1. 加法
如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：
- 如果有一个操作数是NaN,则结果是NaN;
- 如果是Infinity加Infinity，则结果是Infinity;
- 如果是-Infinity加-Infinity，则结果是-Infinity;
- 如果是Infinity加-Infinity，则结果是NaN;
- 如果是+0加+0，则结果是+0;
- 如果是-0加-0，则结果是-0;
- 如果是+0加-0，则结果是+0;
不过，如果有一个操作数是字符串，那么就要应用如下规则：
- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。

如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。
对于undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"。

2. 减法
- 如果两个操作符都是数值，执行常规的算数减法操作并返回结果；
- 如果有一个操作数是NaN,则结果是NaN;
- 如果是Infinity减Infinity，则结果是NaN;
- 如果是-Infinity减-Infinity，则结果是NaN;
- 如果是Infinity减-Infinity，则结果是Infinity;
- 如果是-Infinity减Infinity，则结果是-Infinity;
- 如果是+0减+0，则结果是+0;
- 如果是+0减-0，则结果是-0;
- 如果是+0减-0，则结果是+0;
- 如果有一个操作数是字符串、布尔值、null和undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。
如果转换的结果是NaN，则减法的结果就是NaN；
- 如果只有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。
如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用起toString()方法并将得到的字符串转换为数值。



### 关系操作符
小于（<）、大于（>）、小于等于（<=）、大于等于（>=）
- 如果两个操作数都是数值，则执行数值比较。
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执
  行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面
  的规则执行比较。
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。
### 相等操作符
ECMAScript 提供两组操作符： 相等和不相等——先转换再比较， 全等和不
全等——仅比较而不转换。
1. 相等和不相等
ECMAScript 中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回 true。而不
相等操作符由叹号后跟等于号（!=）表示，如果两个操作数不相等，则返回 true。这两个操作符都会
先转换操作数（通常称为强制转型），然后再比较它们的相等性。
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：
- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而
  true 转换为 1；
- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
- 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类
  型值按照前面的规则进行比较；
  这两个操作符在进行比较时则要遵循下列规则。
- null 和 undefined 是相等的。
- 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。
- 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：
  即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则， NaN 不等于 NaN。
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，
  则相等操作符返回 true；否则，返回 false。
  
2. 全等和不全等
 
### 条件操作符

### 赋值操作符
简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量，
每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：
- 乘/赋值（*=）；
- 除/赋值（/=）；
- 模/赋值（%=）；
- 加/赋值（+=）；
- 减/赋值（-=）；
- 左移/赋值（<<=）；
- 有符号右移/赋值（>>=）；
- 无符号右移/赋值（>>>=）。

### 逗号操作符
逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号
操作符总会返回表达式中的最后一项，

## 语句

### if语句

### do-while语句
do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。
换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。
### while语句
while 语句属于前测试循环语句， 也就是说， 在循环体内的代码被执行之前，就会对出口条件求值。
### for语句
for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代
码的能力。
### for-in语句
for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。
### label语句
使用 label 语句可以在代码中添加标签，以便将来使用。
### break和continue语句
break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，
强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶
部继续执行。
### with语句
with 语句的作用是将代码的作用域设置到一个特定的对象中。
### switch语句
switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。
可以在
switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有
问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。


## 函数
函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、
任何时候调用执行。 ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。
### 理解参数
ECMAScript 函数的参数与大多数其他语言中函数的参数有所不同。 ECMAScript 函数不介意传递进
来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，
在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不
会有什么怨言。之所以会这样，原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收
到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任
何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来
访问这个参数数组，从而获取传递给函数的每一个参数。
### 没有重载
ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数
编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述， ECMAScirpt
函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可
能做到的。


---
# 变量、作用域和内存问题

## 基本类型和引用类型的值
ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 基本类型值指的是
简单的数据段，而引用类型值指那些可能由多个值构成的对象。


### 动态的属性
定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保
存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属
性和方法，也可以改变和删除其属性和方法。

### 复制变量值
除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不
同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制
到为新变量分配的位置上。

### 传递参数
ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参
数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而
引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因
为访问变量有按值和按引用两种方式，而参数只能按值传递。

### 检测类型
 typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。如果变
量的值是一个对象或 null，则 typeof 操作符会返回"object"。
## 执行环境及作用域
执行环境（execution context，为简单起见，有时也称为“环境”）是 JavaScript 中最为重要的一个概
念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个
与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们
编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环
境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象（第 7 章将详细讨论），因
此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完
毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退
出——例如关闭网页或浏览器——时才会被销毁）。
每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。
而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 ECMAScript 程序中的执行流
正是由这个方便的机制控制着。
当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是
保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所
在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对
象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中
的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延
续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，
然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。
### 延长作用域链
虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。
这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移
除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会
得到加长：
 try-catch 语句的 catch 块；
 with 语句。
这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来说，会将指定的对象添加到
作用域链中。对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

### 没有块级作用域
1. 声明变量
使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部
环境；在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自
动被添加到全局环境。

2. 查询标识符
当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什
么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到
了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上
搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味
着该变量尚未声明。


## 垃圾收集
JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。
而在 C 和 C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问
题的一个根源。在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无
用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变
量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），
周期性地执行这一操作。

### 标记清除
JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函
数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变
量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其
标记为“离开环境”。
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方
式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记
的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器
完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
### 引用计数
另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每
个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。
如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取
得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这
个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那
些引用次数为零的值所占用的内存。
Netscape Navigator 3.0 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循
环引用。 循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的
引用。
### 性能问题

### 管理内存
使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是， JavaScript
在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web
浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，
目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量
分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。
因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行
中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个
做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在
它们离开执行环境时自动被解除引用。

---
# 引用类型

## Object类型
到目前为止，我们看到的大多数引用类型值都是 Object 类型的实例；而且， Object 也是
ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储
和传输数据而言，它们确实是非常理想的选择。
创建 Object 实例的方式有两种。第一种是使用 new 操作符后跟 Object 构造函数。\
另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建
包含大量属性的对象的过程。\
一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，
在 JavaScript 也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性
以字符串的形式放在方括号中。\
从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量
来访问属性。\
如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括
号表示法。
## Array类型
创建数组的基本方式有两种。第一种是使用 Array 构造函数，如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成 length属性的值。
也可以向 Array 构造函数传递数组中应该包含的项。
另外，在使用 Array 构造函数时也可以省略 new 操作符。

创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表
示，多个数组项之间以逗号隔开。

在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引，方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值。\
如果设置某个值的索引超过了数组现有项数，数组就会自动增加到该索引值加 1 的长度。

### 检测数组
ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。

### 转换方法
所有对象都具有 toLocaleString()、 toString()和 valueOf()方法。其中，调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。
而调用 valueOf()返回的还是数组。

### 栈方法
数组可以表
现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种 LIFO（Last-In-First-Out，
后进先出）的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做
弹出），只发生在一个位置——栈的顶部。 ECMAScript 为数组专门提供了 push()和 pop()方法，以便
实现类似栈的行为。
push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而
pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。

### 队列方法
栈数据结构的访问规则是 LIFO（后进先出），而队列数据结构的访问规则是 FIFO（First-In-First-Out，
先进先出）。队列在列表的末端添加项，从列表的前端移除项。由于 push()是向数组末端添加项的方法，
因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 shift()，它能够移
除数组中的第一个项并返回该项，同时将数组长度减 1。结合使用 shift()和 push()方法，可以像使
用队列一样使用数组。\
ECMAScript 还为数组提供了一个 unshift()方法。顾名思义，unshift()与 shift()的用途相反：
它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用 unshift()和 pop()方法，可以
从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。
### 重排序方法
数组中已经存在两个可以直接用来重排序的方法： reverse()和 sort()。
sort()方法接受参数。
比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等
则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。

### 操作方法
ECMAScript 为操作已经包含在数组中的项提供了很多方法。其中， concat()方法可以基于当前数
组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数
添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是
复制当前数组并返回副本。如果传递给 concat()方法的是一或多个数组，则该方法会将这些数组中的
每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。

下一个方法是 slice()，它能够基于当前数组中的一或多个项创建一个新数组。 slice()方法可以
接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该
参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项—
—但不包括结束位置的项。注意， slice()方法不会影响原始数组。

下面我们来介绍 splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。
splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种。
- 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。
  例如， splice(0,2)会删除数组中的前两项。
- 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）
  和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，
  splice(2,0,"red","green")会从当前数组的位置 2 开始插入字符串"red"和"green"。
- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起
  始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，
  splice (2,1,"red","green")会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串
  "red"和"green"。
  
### 位置方法
ECMAScript 5 为数组实例添加了两个位置方法： indexOf()和 lastIndexOf()。这两个方法都接收
两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， indexOf()方法从数组的开头（位
置 0）开始向后查找， lastIndexOf()方法则从数组的末尾开始向前查找。

### 迭代方法
ECMAScript 5 为数组定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和
（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数
组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能
会也可能不会影响方法的返回值。以下是这 5 个迭代方法的作用。
- every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。
- filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。
- forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
- some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。

### 归并方法
ECMAScript 5 还新增了两个归并数组的方法： reduce()和 reduceRight()。这两个方法都会迭
代数组的所有项，然后构建一个最终返回的值。其中， reduce()方法从数组的第一项开始，逐个遍历
到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。
这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给
 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这
个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第
一个参数是数组的第一项，第二个参数就是数组的第二项。



## Date类型
ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。为此， Date
类型使用自 UTC（Coordinated Universal Time，国际协调时间） 1970 年 1 月 1 日午夜（零时）开始经过
的毫秒数来保存日期。在使用这种数据存储格式的条件下， Date 类型保存的日期能够精确到 1970 年 1
月 1 日之前或之后的 285 616 年。\
在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根
据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从 UTC 时间 1970 年 1 月 1 日午
夜起至该日期止经过的毫秒数）。为了简化这一计算过程， ECMAScript 提供了两个方法： Date.parse()
和 Date.UTC()。\
其中， Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日
期的毫秒数。 ECMA-262 没有定义 Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现
而异，而且通常是因地区而异。将地区设置为美国的浏览器通常都接受下列日期格式：
- “月/日/年”，如 6/13/2004；
- “英文月名 日,年”，如 January 12,2004；
- “英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700。
- ISO 8601 扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ（例如 2004-05-25T00:00:00）。只有兼容
ECMAScript 5的实现支持这种格式。\

Date.UTC()方法同样也返回表示日期的毫秒数，但它与 Date.parse()在构建值时使用不同的信
息。 Date.UTC()的参数分别是年份、基于 0的月份（一月是 0，二月是 1，以此类推）、月中的哪一天
（1 到 31）、小时数（0 到 23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必
需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。\

ECMAScript 5 添加了 Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方
法简化了使用 Data 对象分析代码的工作。


### 继承的方法
与其他引用类型一样， Date 类型也重写了 toLocaleString()、toString()和 valueOf()方法；
但这些方法返回的值与其他类型中的方法不同。 Date 类型的 toLocaleString()方法会按照与浏览器
设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含 AM 或 PM，但不会包含时
区信息（当然，具体的格式会因浏览器而异）。而 toString()方法则通常返回带有时区信息的日期和
时间，其中时间一般以军用时间（即小时的范围是 0 到 23）表示。

### 日期格式化方法
Date 类型还有一些专门用于将日期格式化为字符串的方法，
- toDateString()——以特定于实现的格式显示星期几、月、日和年；
- toTimeString()——以特定于实现的格式显示时、分、秒和时区；
- toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
- toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
- toUTCString()——以特定于实现的格式完整的 UTC 日期。

与 toLocaleString()和 toString()方法一样，以上这些字符串格式方法的输出也是因浏览器
而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。

### 日期/时间组件方法
到目前为止，剩下还未介绍的 Date 类型的方法（如下表所示），都是直接取得和设置日期值中特
定部分的方法了。需要注意的是， UTC 日期指的是在没有时区偏差的情况下（将日期转换为 GMT 时间）
的日期值。

方法 | 说明
--- | ---
getTime() | 返回表示日期的毫秒数；与valueOf()方法返回的值相同
setTime(毫秒) | 以毫秒数设置日期，会改变整个日期
getFullYear() | 取得4位数的年份（如2007而非仅07）
getUTCFullYear() | 返回UTC日期的4位数年份
setFullYear(年) | 设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
setUTCFullYear(年) | 设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
getMonth() | 返回日期中的月份，其中0表示一月， 11表示十二月
getUTCMonth() | 返回UTC日期中的月份，其中0表示一月， 11表示十二月
setMonth(月) | 设置日期的月份。传入的月份值必须大于0，超过11则增加年份
setUTCMonth(月) | 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份
getDate() | 返回日期月份中的天数（1到31）
getUTCDate() | 返回UTC日期月份中的天数（1到31）
setDate(日) | 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
setUTCDate(日) | 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
getDay() | 返回日期中星期的星期几（其中0表示星期日， 6表示星期六）
getUTCDay() | 返回UTC日期中星期的星期几（其中0表示星期日， 6表示星期六）
getHours() | 返回日期中的小时数（0到23）
getUTCHours() | 返回UTC日期中的小时数（0到23）
setHours(时) | 设置日期中的小时数。传入的值超过了23则增加月份中的天数
setUTCHours(时) | 设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数
getMinutes() | 返回日期中的分钟数（0到59）
getUTCMinutes() | 返回UTC日期中的分钟数（0到59）
setMinutes(分) | 设置日期中的分钟数。传入的值超过59则增加小时数
setUTCMinutes(分) | 设置UTC日期中的分钟数。传入的值超过59则增加小时数
getSeconds() | 返回日期中的秒数（0到59）
getUTCSeconds() | 返回UTC日期中的秒数（0到59）
setSeconds(秒) | 设置日期中的秒数。传入的值超过了59会增加分钟数
setUTCSeconds(秒) | 设置UTC日期中的秒数。传入的值超过了59会增加分钟数
getMilliseconds() | 返回日期中的毫秒数
getUTCMilliseconds() | 返回UTC日期中的毫秒数
setMilliseconds(毫秒) | 设置日期中的毫秒数
setUTCMilliseconds(毫秒) | 设置UTC日期中的毫秒数
getTimezoneOffset() | 返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某
地进入夏令时的情况下，这个值会有所变化。

<<<<<<< HEAD:front_basic/chp6/profession.md
## RegExp方法
ECMAScript 通过 RegExp 类型来支持正则表达式。
其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、
向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。
正则表达式的匹配模式支持下列 3 个标志。
- g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即
停止；
- i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模
式匹配的项。

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。

方法 | 说明
--- | ---
getTime() | 返回表示日期的毫秒数；与valueOf()方法返回的值相同
setTime(毫秒) | 以毫秒数设置日期，会改变整个日期
getFullYear() | 取得4位数的年份（如2007而非仅07）
getUTCFullYear() |  返回UTC日期的4位数年份
setFullYear(年) | 设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
setUTCFullYear(年) | 设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
getMonth() | 返回日期中的月份，其中0表示一月， 11表示十二月
getUTCMonth()  | 返回UTC日期中的月份，其中0表示一月， 11表示十二月
setMonth(月)  | 设置日期的月份。传入的月份值必须大于0，超过11则增加年份
setUTCMonth(月) | 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份
getDate() | 返回日期月份中的天数（1到31）
getUTCDate() | 返回UTC日期月份中的天数（1到31）
setDate(日) | 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
setUTCDate(日) | 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加
getDay() | 返回日期中星期的星期几（其中0表示星期日， 6表示星期六）
getUTCDay() | 返回UTC日期中星期的星期几（其中0表示星期日， 6表示星期六）
getHours() | 返回日期中的小时数（0到23）
getUTCHours() | 返回UTC日期中的小时数（0到23）
setHours(时) | 设置日期中的小时数。传入的值超过了23则增加月份中的天数
setUTCHours(时) | 设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数
getMinutes() | 返回日期中的分钟数（0到59）
getUTCMinutes() | 返回UTC日期中的分钟数（0到59）
setMinutes(分) | 设置日期中的分钟数。传入的值超过59则增加小时数
setUTCMinutes(分) | 设置UTC日期中的分钟数。传入的值超过59则增加小时数
getSeconds()  | 返回日期中的秒数（0到59）
getUTCSeconds()  | 返回UTC日期中的秒数（0到59）
setSeconds(秒) | 设置日期中的秒数。传入的值超过了59会增加分钟数
setUTCSeconds(秒) | 设置UTC日期中的秒数。传入的值超过了59会增加分钟数
getMilliseconds() | 返回日期中的毫秒数
getUTCMilliseconds() | 返回UTC日期中的毫秒数
setMilliseconds(毫秒) | 设置日期中的毫秒数
setUTCMilliseconds(毫秒) | 设置UTC日期中的毫秒数
getTimezoneOffset() | 返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某
地进入夏令时的情况下，这个值会有所变化。

## RegExp方法
ECMAScript 通过 RegExp 类型来支持正则表达式。使用下面类似 Perl 的语法，就可以创建一个正
则表达式。
```javascript
var expression = / pattern /flags ;
```
其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、
向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。
正则表达式的匹配模式支持下列 3 个标志。
- g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即
停止；
- i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模
式匹配的项。

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：
`( [ { \ ^ $ | ) ? * + .]}`
这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，
就必须对它们进行转义。
### RegExp实例属性
RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。
- global：布尔值，表示是否设置了 g 标志。
- ignoreCase：布尔值，表示是否设置了 i 标志。
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。
- multiline：布尔值，表示是否设置了 m 标志。
- source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。
通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含
在模式声明中。

### RegExp实例方法
RegExp 对象的主要方法是 exec()，该方法是专门为捕获组而设计的。 exec()接受一个参数，即
要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null。
返回的数组虽然是 Array 的实例，但包含两个额外的属性： index 和 input。其中， index 表示匹配
项在字符串中的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配
的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。

正则表达式的第二个方法是 test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回
true；否则，返回 false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的
情况下，使用这个方法非常方便。因此， test()方法经常被用在 if 语句中。

### RegExp构造函数属性
RegExp 构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用
域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独
特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名
（Opera 是例外，它不支持短属性名）。

长属性名 | 短属性名 | 说 明
--- | --- | ---
input | $_ | 最近一次要匹配的字符串。 Opera未实现此属性
lastMatch | $& | 最近一次的匹配项。 Opera未实现此属性
lastParen | $+ | 最近一次匹配的捕获组。 Opera未实现此属性
leftContext | $` | input字符串中lastMatch之前的文本
multiline | $* | 布尔值，表示是否所有表达式都使用多行模式。 IE和Opera未实现此属性
rightContext | $' | Input字符串中lastMatch之后的文本

除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。访问这些属性的语
法是 RegExp.$1、 RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在
调用 exec()或 test()方法时，这些属性会被自动填充。

### 模式的局限性
尽管 ECMAScript 中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是 Perl）所支
持的高级正则表达式特性。下面列出了 ECMAScript 正则表达式不支持的特性（要了解更多相关信息，
请访问 www.regular-expressions.info）。
- 匹配字符串开始和结尾的\A 和\Z 锚①
- 向后查找（lookbehind） ②
- 并集和交集类
- 原子组（atomic grouping）
- Unicode 支持（单个字符除外，如\uFFFF）
- 命名的捕获组③
- s（single，单行）和 x（free-spacing，无间隔）匹配模式
- 条件匹配
- 正则表达式注释

## Function类型
每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函
数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函
数声明语法定义的。
```javascript
function sum (num1, num2) {
return num1 + num2;
}

var sum = function(num1, num2){
return num1 + num2;
};
```

function 关键字后面没有函数名。这是因为在使用函数表达式定义函数时，没有必要使用函数名——通过变量 sum 即可以引
用函数。另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。
最后一种定义函数的方式是使用 Function 构造函数。Function 构造函数可以接收任意数量的参数，
但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。
### 没有重载（深入理解）
将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。

### 函数声明与函数表达式
而实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行
任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真
正被解释执行。
```javascript
alert(sum(10,10));
function sum(num1, num2){
return num1 + num2;
}
```
以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升
（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时， JavaScript
引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后
面， JavaScript 引擎也能把函数声明提升到顶部。如果像下面例子所示的，把上面的函数声明改为等价
的函数表达式，就会在执行期间导致错误。
```javascript
alert(sum(10,10));  // 报错
var sum = function(num1, num2){
return num1 + num2;
};
```
 
### 作为值的函数
因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以
像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。


### 函数内部属性
在函数内部，有两个特殊的对象： arguments 和 this。其中， arguments 在第 3 章曾经介绍过，
它是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，
但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。
```
function factorial(num){
if (num <=1) {
return 1;
} else {
return num * factorial(num-1)
}
}
```
定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变
的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为
了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee。
```js
function factorial(num){
if (num <=1) {
return 1;
} else {
return num * arguments.callee(num-1)
}
}
```
### 函数属性和方法
每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数。
每个函数都包含两个非继承而来的方法：apply()和call()。
这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。
首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数值。其中，第二个参数可以是Array的实例，也可以是arguments对象。
call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。使用call()方法时，传递给函数的参数必须逐个列举出来。

事实上，传递参数并非 apply()和 call()真正的用武之地；它们真正强大的地方是能够扩充函数
赖以运行的作用域。
```js
window.color = "red";
var o = { color: "blue" };
function sayColor(){
alert(this.color);
}
sayColor(); //red
sayColor.call(this); //red
sayColor.call(window); //red
sayColor.call(o); //blue
```
使用 call()（或 apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。

ECMAScript 5 还定义了一个方法： bind()。这个方法会创建一个函数的实例，其 this 值会被绑
定到传给 bind()函数的值。

## 基本包装类型
为了便于操作基本类型值， ECMAScript 还提供了 3 个特殊的引用类型： Boolean、 Number 和
String。这些类型与其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。
实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们
能够调用一些方法来操作这些数据。

引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，
在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一
行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。

当然，可以显式地调用 Boolean、 Number 和 String 来创建基本包装类型的对象。不过，应该在
绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的
值。对基本包装类型的实例调用 typeof 会返回"object"，而且所有基本包装类型的对象都会被转换
为布尔值 true。
### Boolean类型
Boolean 类型是与布尔值对应的引用类型。
基本类型与引用类型的布尔值还有两个区别。首先， typeof 操作符对基本类型返回"boolean"，
而对引用类型返回"object"。其次，由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof
操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false。
### Number类型
Number 是与数字值对应的引用类型。要创建 Number 对象，可以在调用 Number 构造函数时向其
中传递相应的数值。

这里给 toFixed()方法传入了数值 2，意思是显示几位小数。于是，这个方法返回了"10.00"，即
以 0 填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值
就会舍入。

另外可用于格式化数值的方法是 toExponential()，该方法返回以指数表示法（也称 e 表示法）
表示的数值的字符串形式。与 toFixed()一样， toExponential()也接收一个参数，而且该参数同样
也是指定输出结果中的小数位数。

### String类型
String 类型是字符串的对象包装类型，String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf()、toLocale
String()和 toString()方法，都返回对象所表示的基本字符串值。

1. 字符方法
两个用于访问字符串中特定字符的方法是： charAt()和 charCodeAt()。这两个方法都接收一个
参数，即基于 0 的字符位置。其中， charAt()方法以单字符字符串的形式返回给定位置的那个字符
（ECMAScript 中没有字符类型）。

2. 字符串操作方法
 concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。
ECMAScript还提供了三个基于子字符串创建新字符串的方法： slice()、 substr()和 substring()。
这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字
符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说， slice()和
substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而 substr()的第二个参数指
定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与
concat()方法一样， slice()、 substr()和 substring()也不会修改字符串本身的值——它们只是
返回一个基本类型的字符串值，对原始字符串没有任何影响。

在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中， slice()方法会将传
入的负值与字符串的长度相加， substr()方法将负的第一个参数加上字符串的长度，而将负的第二个
参数转换为 0。最后， substring()方法会把所有负值参数都转换为 0。

3. 字符串位置方法
有两个可以从字符串中查找子字符串的方法： indexOf()和 lastIndexOf()。这两个方法都是从
一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。
这两个方法的区别在于： indexOf()方法从字符串的开头向后搜索子字符串，而 lastIndexOf()方法
是从字符串的末尾向前搜索子字符串。这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。

4. trim()方法
ECMAScript 5 为所有字符串定义了 trim()方法。这个方法会创建一个字符串的副本，删除前置及
后缀的所有空格，然后返回结果。

5. 字符串大小写转换方法
ECMAScript 中涉及字符串大小写转换的方
法有 4 个： toLowerCase()、 toLocaleLowerCase()、 toUpperCase()和 toLocaleUpperCase()。
其中， toLowerCase()和 toUpperCase()是两个经典的方法，借鉴自 java.lang.String 中的同名
方法。而 toLocaleLowerCase()和 toLocaleUpperCase()方法则是针对特定地区的实现。对有些地
区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为 Unicode 大小
写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。

6. 字符串的模式匹配方法
String 类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是 match()，在字符串上
调用这个方法，本质上与调用 RegExp 的 exec()方法相同。 match()方法只接受一个参数，要么是一
个正则表达式，要么是一个 RegExp 对象。

replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的
情况下，会向这个函数传递 3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在
正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹
配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始
字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace()方法的第
二个参数可以实现更加精细的替换操作。

7. localeCompare()方法
与操作字符串有关的最后一个方法是 localeCompare()，这个方法比较两个字符串，并返回下列
值中的一个：
- 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体
  的值要视实现而定）；
- 如果字符串等于字符串参数，则返回 0；
- 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1，具体的
  值同样要视实现而定）。

8. fromCharCode()方法
另外， String 构造函数本身还有一个静态方法： fromCharCode()。这个方法的任务是接收一或
多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法 charCodeAt()
执行的是相反的操作。

## 单体内置对象
ECMA-262 对内置对象的定义是：“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对
象在 ECMAScript 程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因
为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如 Object、 Array 和 String。
ECMA-262 还定义了两个单体内置对象： Global 和 Math。

### Global对象
不属于任何其他对象的属性和方法，最终都是它的属性和方法。

1. URI编码方法
Global 对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform Resource
Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如
空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，
从而让浏览器能够接受和理解。
其中， encodeURI()主要用于整个 URI（例如， http://www.wrox.com/illegal value.htm），而 encodeURIComponent()主要用于对 URI 中的某一段（例如前面 URI 中的 illegal value.htm）进行编码。
它们的主要区别在于， encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、
问号和井字号；而 encodeURIComponent()则会对它发现的任何非标准字符进行编码。

与 encodeURI()和 encodeURIComponent()方法对应的两个方法分别是 decodeURI()和
decodeURIComponent()。其中， decodeURI()只能对使用 encodeURI()替换的字符进行解码。
同样地， decodeURIComponent()能够解码使用 encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。

2. eval()方法
现在，我们介绍最后一个——大概也是整个 ECMAScript 语言中最强大的一个方法：eval()。eval()
方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的 ECMAScript （或 JavaScript）
字符串。

当解析器发现代码中调用 eval()方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，
然后把执行结果插入到原位置。通过 eval()执行的代码被认为是包含该次调用的执行环境的一部分，
因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过 eval()执行的代码可以引用在包
含环境中定义的变量。

严格模式下，在外部访问不到 eval()中创建的任何变量或函数。

3. Global对象的属性

属性 | 说明
--- | ---
 undefined | 特殊值undefined
 NaN | 特殊值NaN
 Infinity | 特殊值Infinity
 Object | 构造函数Object
 Array | 构造函数Array
 Function | 构造函数Function
 Boolean | 构造函数Boolean
 String | 构造函数String
 Number | 构造函数Number
 Date | 构造函数Date
 RegExp | 构造函数RegExp
 Error | 构造函数Error
 EvalError | 构造函数EvalError
 RangeError | 构造函数RangeError
 ReferenceError | 构造函数ReferenceError
 SyntaxError | 构造函数SyntaxError
 TypeError | 构造函数TypeError
 URIError | 构造函数URIError
 ECMAScript 5 明确禁止给 undefined、 NaN 和 Infinity 赋值，这样做即使在非严格模式下也会
 导致错误。
 
 4. window对象
 ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为
 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window
 对象的属性。
 
### Math对象
ECMAScript 还为保存数学公式和信息提供了一个公共位置，即 Math 对象。与我们在 JavaScript 直
接编写的计算功能相比， Math 对象提供的计算功能执行起来要快得多。 Math 对象中还提供了辅助完成
这些计算的属性和方法。

1. Math对象的属性

属性 | 说明
--- | ---
Math.E | 自然对数的底数，即常量e的值
Math.LN10 | 10的自然对数
Math.LN2 | 2的自然对数
Math.LOG2E | 以2为底e的对数
Math.LOG10E | 以10为底e的对数
Math.PI | π的值
Math.SQRT1_2 | 1/2的平方根（即2的平方根的倒数
Math.SQRT2 | 2的平方根

2. min()和max()方法
Math 对象还包含许多方法，用于辅助完成简单和复杂的数学计算。
其中， min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多
个数值参数。

3. 舍入方法
下面来介绍将小数值舍入为整数的几个方法： Math.ceil()、 Math.floor()和 Math.round()。
这三个方法分别遵循下列舍入规则：
- Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；
- Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；
- Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课
上学到的舍入规则）。

4. random()方法
Math.random()方法返回大于等于 0 小于 1 的一个随机数。

5. 其他方法
Math 对象中还包含其他一些与完成各种简单或复杂计算有关的方法，但详细讨论其中每一个方法
的细节及适用情形超出了本书的范围。下面我们就给出一个表格，其中列出了这些没有介绍到的 Math
对象的方法。

方法 | 说明
--- | ---
Math.abs(num) | 返回num 的绝对值 
Math.asin(x) | 返回x 的反正弦值
Math.exp(num) | 返回Math.E 的num 次幂 
Math.atan(x) | 返回x 的反正切值
Math.log(num) | 返回num 的自然对数
Math.atan2(y,x) | 返回y/x 的反正切值
Math.pow(num,power) | 返回num 的power 次幂 
Math.cos(x) | 返回x 的余弦值
Math.sqrt(num) | 返回num 的平方根 
Math.sin(x) | 返回x 的正弦值
Math.acos(x) | 返回x 的反余弦值 
Math.tan(x) | 返回x 的正切值

---
# 面向对象的程序设计


---
# 函数表达式

---
# BOM

---
# 客户端检测

---
# DOM

---
# DOM扩展

---
# DOM2和DOM3

---
# 事件

---
# 表单脚本


---
# 使用Canvas绘图

---
# HTML脚本编程

---
# 错误处理与调试

---
# JavaScript与XML

---
# E4X


---
# JSON


---
# Ajax与Comet


---
# 高级技巧


---
# 离线应用于客户端存储


---
# 最佳实践



---
# 新兴的API