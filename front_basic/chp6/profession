[TOC]

《JavaScript高级程序设计（第三版）》读书笔记
# 简介
一个完整的JavaScript实现由三部分组成：
- 核心(ECMAScript)
- 文档对象模型(DOM)
- 浏览器对象模型(BOM)

1. ECMAScript规定的内容：
- 语法
- 类型
- 语句
- 关键字
- 保留字
- 操作符
- 对象

2. 文档对象模型(DOM)
文档对象模型(DOM，Document Object Model)是针对XML但经过扩展用于HTML的应用程序编程接口(API，Application Programming Interface)。

    1. DOM级别：
    DOM1级由两个模块组成：DOM核心和DOM HTML。其中DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。\
    DOM2级引入以下模块：
    - DOM视图：定义了跟踪不同文档(例如，应用CSS之前和之后的文档)视图的接口；
    - DOM事件：定义了事件和事件处理的接口；
    - DOM样式：定义了基于CSS为元素应用样式的接口；
    - DOM遍历和视图：定义了遍历和操作文档树的接口；
    
    DOM3引入了以统一方式加载和保存文档的方法——在DOM加载和保存模块中定义；新增了验证文档的方法——在DOM验证模块中定义。
      
    2. 其他DOM标准
    除了DOM核心和DOM HTML接口之外，另外几种语言还发布了只针对自己的DOM标准。
    - SVG(可伸缩矢量图)1.0
    - MathML(数学标记语言)1.0
    - SMIL(同步多媒体集成语言)
    
    3. Web浏览器对DOM的支持
3. 浏览器对象模型(BOM)
---
# 在HTML中使用JavaScript

1. `<script>`元素
向HTML页面插入JavaScript的主要方法，HTML4.01为`<script>`定义了下列6个属性：
- async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效。
- charset：可选。表示通过src属性指定的代码的字符集。（大多数浏览器会忽略该值）
- defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。
- language：已废弃。
- src：可选。表示包含要执行代码的外部文件（如果需要包含JavaScript文件，则src属性就是必需的）。
- type：可选。可看做language的替代属性；表示编写代码使用脚本语言的内容类型（也称为MIME类型）。
    1. 标签的位置：现代Web应用程序一般都把全部JavaScript引用放在`<body>`元素中页面内容的后面。
    2. 延迟脚本：defer属性是表明脚本在执行时不会影响页面的构造。脚本被延迟到整个页面都解析完毕后再运行。defer属性只适用于外部脚本文件。
    3. 异步脚本：async脚本同样只用于外部脚本文件。
    4. 在XHTML中的用法：HTML的代码块在XHTML中无法正常识别，因为<在XHTML中被当做开始的新标签来解析。避免在XHTML中出现类似语法错误的方法有两个。一个是用相应的HTML实体(&lt替换<)；一个是用一个CDATA片段包含JavaScript代码`<script><![CDATA[代码片段]]></script>`

2. 嵌入外部代码与外部文件
- 可维护性：遍历不同HTML页面的JavaScript会造成维护问题。但把所有JavaScript文件都放在一个文件夹中，维护就方便多了。
- 可缓存：浏览器能够根据具体的设置缓存链接的所有外部JavaScript文件。
- 适应未来：通过外部文件来包含JavaScript无须使用前面提到XHTML或者注释hack。

3. 文档模式
混合模式（quirks mode）
标准模式（standards mode）：
```html
<!-- HTML 4.01严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3c.org/TR/html4/strict.dtd">
<!-- XHTML 1.0严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3c.org/TR/xhtml/DTD/XHTML-strict.dtd">
<!-- HTML 5 -->
<!DOCTYPE HTML>
```
对于标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发。
4. `<noscript>`模式
- 浏览器不支持脚本
- 浏览器支持脚本，但脚本被禁用

---
# 基本概念
## 语法
### 区分大小写

### 标识符
所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。格式规则为：
- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
- 其他字符可以是字母、下划线、美元符号或数字。
- 不能把关键字、保留字、true、false和null用作标识符。

### 注释
ECMAScript使用C风格的注释，包括单行注释和块级注释。单行注释以两个斜杠开头。
块级注释以一个斜杠和一个星号（/*）开头，以一个星号和一个斜杠（*/）结尾。
```html
// 单行注释
/*
* 这是一个多行
* （块级）注释
*/
```

### 严格模式
```js
"use strict"
```
看起来是字符串，也没有赋值给任何变量，其实是一个编译指令。

### 语句
以分号结尾；如果省略分号，则由解释器确定语句的结尾。

## 关键字和保留字
```
abstract
boolean break byte
case catch char class const continue
debugger default delete do double 
else enum export extends
false final finally float for function
goto
if implements import in instanceof int interface
long let
native new null
package private protected public
return
short static super switch synchronized
this throw throws transient true try typeof
var volatile void
while with
yield
```


## 变量
用var操作符定义的变量将成为定义该变量的作用域中的局部变量。

## 数据类型
ECMAScript中有5种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number、String。一种复杂数据类型：Object

### typeof操作符

对一个值使用typeof操作符返回下列某个字符串：

- "undefined"——如果这个值未定义；
- "boolean"——如果这个值是布尔值；
- "string"——如果这个值是字符串；
- "number"——如果这个值是数值；
- "object"——如果这个值是对象或null；
- "function"——如果这个值是函数。
typeof操作符的操作数可以是变量，也可以是数值字面量。\
typeof是一个操作符而不是函数

### Undefined类型
Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。

### Null类型
Null类型只有一个值，即特殊的null。null值表示一个空对象指针。
实际上，undefined值是派生自null值，因此对它们进行相等性测试返回true。
```js
alert(undefined == null); // true
alert(undefined === null); // false
```
### Boolean类型
Boolean类型只有两个字面值：true和false。区分大小写。这两个值与数字值不是一回事，true不一定等于1，false不一定等于0.
ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()。

数据类型 | 转换为true的值 | 转换为false的值
--- | --- | ---
Boolean | true | false
String | 任何非空字符串 | ""(空字符串)
Number | 任何非零数字值(包括无穷大) | 0 和NaN
Object | 任何对象 | null
Undefined | n/a(不适用) | undefined

### Number类型
最基本的数值字面量格式是十进制整数。整数还可以通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。\
其中，八进制字面量的第一位必须是零(0)，然后是八进制数字序列。十六进制字面值的前两位必须是0x，后跟任何十六进制数字(0-9及A-F)。
1. 浮点数值
所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。\
对于极大或极小的数值，可以用e表示法(即科学计数法)表示的浮点数值表示。
2. 数值范围
ECMAScript能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在Number_MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308.
3. NaN
NaN,即非数值是一个特殊的数值。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。
NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作都会返回NaN；其次，NaN与任何值都不相等，包括NaN本身。

4. 数值转换
Number()可用于任何数据类型，其转换规则如下：
- 如果是Boolean值，true和false将分别被转换为1和0；
- 如果是数字值，只是简单的传入和返回；
- 如果是null值，返回0；
- 如果是undefined，返回NaN;
- 如果是字符串，遵循以下规则：
    - 如果字符串中只包含数字，则将其转换为十进制数值；
    - 如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值；
    - 如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值；
    - 如果字符产是空的（不包含任何字符），则将其转换为0；
    - 如果字符串中包含除上述格式之外的字符，则将其转换为NaN.
- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN,则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

parseInt()函数在转换字符串时，会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN;如果第一个字符是数字字符，则继续解析直到解析完或者遇到非数字字符。（小数点不是有效的数字字符）
parseInt提供第二个参数，转换时使用的基数（即多少进制）。

parseFloat()函数只解析十进制。

### String类型
String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号(")或单引号(')表示。

1. 字符串变量
String数据类型包含一些特殊的字符字面量，也叫转义序列。

字面量 | 含义
--- | ---
`\n` | 换行
`\t` | 制表
`\b` | 退格
`\r` | 回车
`\f` | 进纸
`\\` | 斜杠
`\'` | 单引号(')，在用单引号表示的字符串中使用。
`\"` | 双引号(")，在用双引号表示的字符串中使用。
`\xnn` | 以十六进制代码nn表示的一个字符（其中n为0-F）。
`\unnnn` | 以十六进制代码nnnn表示的一个Unicode字符（其中n为0-F）。

2. 字符串的特点
ECMAScript中字符串是不可变的。

3. 转换为字符串
第一种是使用几乎每个值都有的toString()方法（null和undefined除外）。该方法可以不传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。
第二种是String()，不知道转型的值是不是null和undefined时使用，转换规则如下：
- 如果值有toString()方法，则调用该方法并返回相应的结果；
- 如果值是null，则返回"null"；
- 如果值是undefined，则返回"undefined"。

### Object类型
ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。
Object的每个实例都具有下列属性和方法。
- constructor：保存着用于创建当前对象的函数。
- hasOwnproperty(propertyName)：用于检查给定属性在当前对象实例中（而不是在实例的原型中）是否存在。
- isPrototypeOf：用于检查传入的对象是否是传入对象的原型。
- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。
- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString()：返回对象的字符串表示。
- valueOf()：返回对象的字符串、数值或布尔值表示。

## 操作符
### 一元操作符
只能操作一个值的操作符叫做***一元操作符***。
1. 递增和递减操作符：前置型和后置型
2. 一元加和减操作符：表示正负

### 位操作符
位操作符用于最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript中所有数值都以IEEE-754 64
位格式储存，即位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再转换回64位

对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表述数值的符号：0表示正数，1表示负数。
正数以纯二进制格式存储。负数同样以二进制码存储，但使用的格式是二进制补码。
1. 按位非（NOT）
按位非操作符有一个波浪线（~）表示，执行按位非的结果就是返回数值的反码（操作数的负数减1）。

2. 按位与（AND）
按位与操作符由一个和号字符（&）表示，它有两个操作符数。按位与操作就是将两个数值的每一位对齐，
然后根据下表中的规则，对相同位置上的两个数执行AND操作：

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
1 | 1 | 1
1 | 0 | 0
0 | 1 | 0
0 | 0 | 0

3. 按位或（OR）
按位或操作符由一个竖线符号（|）表示，有两个操作数。按位或操作遵循下面这个真假表。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
1 | 1 | 1
1 | 0 | 1
0 | 1 | 1
0 | 0 | 0

4. 按位异或（XOR）
按位异或操作符由一个插入符号（^）表示，也是两个操作数。以下是按位异或的真假值。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
1 | 1 | 0
1 | 0 | 1
0 | 1 | 1
0 | 0 | 0

5. 左移
左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。

6. 有符号的右移
有符号的右移操作符由两个小于号（>>）表示，这个操作符会将数值的所有位向右移动，但保留符号位（即正负号标记）。

7. 无符号右移
无符号的右移操作符由三个小于号（>>>）表示，这个操作符会将数值的所有32都位向右移动。


### 布尔操作符
布尔操作符一共有3个：非（NOT）、与（AND）和或（OR）
1. 逻辑非
逻辑非操作符由一个叹号（！）表示，可以应用于ECMAScript中的任何值。逻辑非操作符遵循下列规则：
- 如果操作数是一个对象，返回false；
- 如果操作数是一个空字符串，返回true；
- 如果操作数是一个非空字符串，返回false；
- 如果操作数是数值0，返回true；
- 如果操作数是任意非0数值（包括Infinity），返回false；
- 如果操作数是null，返回true；
- 如果操作数是NaN，返回true；
- 如果操作数是undefined，返回true。

2. 逻辑与
逻辑与操作符由两个和号（&&）表示，有两个操作数。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
true | true | true
true | false | false
false | true | false
false | false | false

3. 逻辑或
逻辑或操作符由两个和号（||）表示，有两个操作数。

第一个数值的位 | 第二个数值的位 | 结果
--- | --- | ---
true | true | true
true | false | true
false | true | true
false | false | false

### 乘性操作符
ECMAScript定义了3个乘性操作符：乘法、除法和求模。
1. 乘法
乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。遵循下列特殊的规则：
- 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，
而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了数值的表示范围，则返回Infinity或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity与0相乘，则结果是NaN;
- 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
- 如果是Infinity与Infinity相乘，则结果是Infinity；
- 如果有一个操作符不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

2. 除法
除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算。遵循下列特殊的规则：
- 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相乘的结果还是正数，
而如果只有一个操作数有符号，那么结果就是负数。如果商超过了数值的表示范围，则返回Infinity或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity被Infinity除，则结果是NaN;
- 如果是零被零除，则结果是NaN;
- 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
- 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

3. 求模
求模（余数）操作符由一个百分号（%）表示，规则如下：
- 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
- 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN;
- 如果被除数是有限大的数值而除数是零，则结果是NaN;
- 如果是Infinity被Infinity除，则结果是NaN;
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
- 如果被除数是零，则结果是零；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

### 加性操作符
1. 加法
如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：
- 如果有一个操作数是NaN,则结果是NaN;
- 如果是Infinity加Infinity，则结果是Infinity;
- 如果是-Infinity加-Infinity，则结果是-Infinity;
- 如果是Infinity加-Infinity，则结果是NaN;
- 如果是+0加+0，则结果是+0;
- 如果是-0加-0，则结果是-0;
- 如果是+0加-0，则结果是+0;
不过，如果有一个操作数是字符串，那么就要应用如下规则：
- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。

如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。
对于undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"。

2. 减法
- 如果两个操作符都是数值，执行常规的算数减法操作并返回结果；
- 如果有一个操作数是NaN,则结果是NaN;
- 如果是Infinity减Infinity，则结果是NaN;
- 如果是-Infinity减-Infinity，则结果是NaN;
- 如果是Infinity减-Infinity，则结果是Infinity;
- 如果是-Infinity减Infinity，则结果是-Infinity;
- 如果是+0减+0，则结果是+0;
- 如果是+0减-0，则结果是-0;
- 如果是+0减-0，则结果是+0;
- 如果有一个操作数是字符串、布尔值、null和undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。
如果转换的结果是NaN，则减法的结果就是NaN；
- 如果只有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。
如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用起toString()方法并将得到的字符串转换为数值。



### 关系操作符
小于（<）、大于（>）、小于等于（<=）、大于等于（>=）
- 如果两个操作数都是数值，则执行数值比较。
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执
  行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面
  的规则执行比较。
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。
### 相等操作符
ECMAScript 提供两组操作符： 相等和不相等——先转换再比较， 全等和不
全等——仅比较而不转换。
1. 相等和不相等
ECMAScript 中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回 true。而不
相等操作符由叹号后跟等于号（!=）表示，如果两个操作数不相等，则返回 true。这两个操作符都会
先转换操作数（通常称为强制转型），然后再比较它们的相等性。
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：
- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而
  true 转换为 1；
- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
- 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类
  型值按照前面的规则进行比较；
  这两个操作符在进行比较时则要遵循下列规则。
- null 和 undefined 是相等的。
- 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。
- 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：
  即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则， NaN 不等于 NaN。
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，
  则相等操作符返回 true；否则，返回 false。
  
2. 全等和不全等
 
### 条件操作符

### 赋值操作符
简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量，
每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：
- 乘/赋值（*=）；
- 除/赋值（/=）；
- 模/赋值（%=）；
- 加/赋值（+=）；
- 减/赋值（-=）；
- 左移/赋值（<<=）；
- 有符号右移/赋值（>>=）；
- 无符号右移/赋值（>>>=）。

### 逗号操作符
逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号
操作符总会返回表达式中的最后一项，

## 语句

### if语句

### do-while语句
do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。
换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。
### while语句
while 语句属于前测试循环语句， 也就是说， 在循环体内的代码被执行之前，就会对出口条件求值。
### for语句
for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代
码的能力。
### for-in语句
for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。
### label语句
使用 label 语句可以在代码中添加标签，以便将来使用。
### break和continue语句
break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，
强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶
部继续执行。
### with语句
with 语句的作用是将代码的作用域设置到一个特定的对象中。
### switch语句
switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。
可以在
switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有
问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。


## 函数
函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、
任何时候调用执行。 ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。
### 理解参数
ECMAScript 函数的参数与大多数其他语言中函数的参数有所不同。 ECMAScript 函数不介意传递进
来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，
在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不
会有什么怨言。之所以会这样，原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收
到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任
何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来
访问这个参数数组，从而获取传递给函数的每一个参数。
### 没有重载
ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数
编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述， ECMAScirpt
函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可
能做到的。


---
# 变量、作用域和内存问题

## 基本类型和引用类型的值
ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 基本类型值指的是
简单的数据段，而引用类型值指那些可能由多个值构成的对象。


### 动态的属性
定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保
存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属
性和方法，也可以改变和删除其属性和方法。

### 复制变量值
除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不
同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制
到为新变量分配的位置上。

### 传递参数
ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参
数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而
引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因
为访问变量有按值和按引用两种方式，而参数只能按值传递。

### 检测类型
 typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。如果变
量的值是一个对象或 null，则 typeof 操作符会返回"object"。
## 执行环境及作用域
执行环境（execution context，为简单起见，有时也称为“环境”）是 JavaScript 中最为重要的一个概
念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个
与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们
编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环
境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象（第 7 章将详细讨论），因
此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完
毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退
出——例如关闭网页或浏览器——时才会被销毁）。
每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。
而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 ECMAScript 程序中的执行流
正是由这个方便的机制控制着。
当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是
保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所
在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对
象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中
的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延
续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，
然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。
### 延长作用域链
虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。
这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移
除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会
得到加长：
 try-catch 语句的 catch 块；
 with 语句。
这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来说，会将指定的对象添加到
作用域链中。对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

### 没有块级作用域
1. 声明变量
使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部
环境；在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自
动被添加到全局环境。

2. 查询标识符
当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什
么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到
了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上
搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味
着该变量尚未声明。


## 垃圾收集
JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。
而在 C 和 C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问
题的一个根源。在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无
用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变
量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），
周期性地执行这一操作。

### 标记清除
JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函
数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变
量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其
标记为“离开环境”。
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方
式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记
的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器
完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
### 引用计数
另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每
个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。
如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取
得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这
个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那
些引用次数为零的值所占用的内存。
Netscape Navigator 3.0 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循
环引用。 循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的
引用。
### 性能问题

### 管理内存
使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是， JavaScript
在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web
浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，
目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量
分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。
因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行
中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个
做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在
它们离开执行环境时自动被解除引用。

---
# 引用类型

## Object类型
到目前为止，我们看到的大多数引用类型值都是 Object 类型的实例；而且， Object 也是
ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储
和传输数据而言，它们确实是非常理想的选择。
创建 Object 实例的方式有两种。第一种是使用 new 操作符后跟 Object 构造函数。\
另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建
包含大量属性的对象的过程。\
一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，
在 JavaScript 也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性
以字符串的形式放在方括号中。\
从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量
来访问属性。\
如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括
号表示法。
## Array类型
创建数组的基本方式有两种。第一种是使用 Array 构造函数，如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成 length属性的值。
也可以向 Array 构造函数传递数组中应该包含的项。
另外，在使用 Array 构造函数时也可以省略 new 操作符。

创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表
示，多个数组项之间以逗号隔开。

在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引，方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值。\
如果设置某个值的索引超过了数组现有项数，数组就会自动增加到该索引值加 1 的长度。

### 检测数组
ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。

### 转换方法
所有对象都具有 toLocaleString()、 toString()和 valueOf()方法。其中，调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。
而调用 valueOf()返回的还是数组。

### 栈方法
数组可以表
现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种 LIFO（Last-In-First-Out，
后进先出）的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做
弹出），只发生在一个位置——栈的顶部。 ECMAScript 为数组专门提供了 push()和 pop()方法，以便
实现类似栈的行为。
push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而
pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。

### 队列方法
栈数据结构的访问规则是 LIFO（后进先出），而队列数据结构的访问规则是 FIFO（First-In-First-Out，
先进先出）。队列在列表的末端添加项，从列表的前端移除项。由于 push()是向数组末端添加项的方法，
因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 shift()，它能够移
除数组中的第一个项并返回该项，同时将数组长度减 1。结合使用 shift()和 push()方法，可以像使
用队列一样使用数组。\
ECMAScript 还为数组提供了一个 unshift()方法。顾名思义，unshift()与 shift()的用途相反：
它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用 unshift()和 pop()方法，可以
从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。
### 重排序方法
数组中已经存在两个可以直接用来重排序的方法： reverse()和 sort()。
sort()方法接受参数。
比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等
则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。

### 操作方法
ECMAScript 为操作已经包含在数组中的项提供了很多方法。其中， concat()方法可以基于当前数
组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数
添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是
复制当前数组并返回副本。如果传递给 concat()方法的是一或多个数组，则该方法会将这些数组中的
每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。

下一个方法是 slice()，它能够基于当前数组中的一或多个项创建一个新数组。 slice()方法可以
接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该
参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项—
—但不包括结束位置的项。注意， slice()方法不会影响原始数组。

下面我们来介绍 splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。
splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种。
- 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。
  例如， splice(0,2)会删除数组中的前两项。
- 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）
  和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，
  splice(2,0,"red","green")会从当前数组的位置 2 开始插入字符串"red"和"green"。
- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起
  始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，
  splice (2,1,"red","green")会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串
  "red"和"green"。
  
### 位置方法
ECMAScript 5 为数组实例添加了两个位置方法： indexOf()和 lastIndexOf()。这两个方法都接收
两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， indexOf()方法从数组的开头（位
置 0）开始向后查找， lastIndexOf()方法则从数组的末尾开始向前查找。

### 迭代方法

### 归并方法


## Date类型

### 继承的方法

### 日期格式化方法

### 日期/时间组件方法

## RegExp方法

### RegExp实例属性

### RegExp实例方法

### RegExp构造函数属性

### 模式的局限性

## Function类型

### 没有重载（深入理解）

### 函数声明与函数表达式

### 作为值的函数

### 函数内部属性

### 函数属性和方法

## 基本包装类型

### Boolean类型

### Number类型

### String类型

## 单体内置对象

### Global对象

### Math对象





---
# 面向对象的程序设计


---
# 函数表达式

---
# BOM

---
# 客户端检测

---
# DOM

---
# DOM扩展

---
# DOM2和DOM3

---
# 事件

---
# 表单脚本


---
# 使用Canvas绘图

---
# HTML脚本编程

---
# 错误处理与调试

---
# JavaScript与XML

---
# E4X


---
# JSON


---
# Ajax与Comet


---
# 高级技巧


---
# 离线应用于客户端存储


---
# 最佳实践



---
# 新兴的API